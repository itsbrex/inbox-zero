<!-- Generated by SpecStory, Markdown v2.1.0 -->

# 2026-01-24 04:01:15Z

<!-- Claude Code Session 98735c14-69c0-4557-9177-ddf5f9f60e10 (2026-01-24 04:01:15Z) -->

_**User (2026-01-24T04:01:15.959Z)**_

Please audit the MSAL implmentation by tracing the logic for what or should happen when a user authenticates via device-code flow using MSAL with Microsoft Office Client ID + default graph scopes to then interact with the Graph API. Read how we achieved this already elsewhere to understand what gaps we are missing inn our current codebase implementation for device-code flow: /Users/hack/github/outlook-creds/scripts

---

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:01:26.226Z)**_

<think><details><summary>Thought Process</summary>
The user wants me to audit the MSAL implementation for device-code flow authentication with Microsoft Graph API. They want me to:

1. Trace the logic for device-code flow authentication using MSAL with Microsoft Office Client ID and default graph scopes
2. Compare with an existing implementation in `/Users/hack/github/outlook-creds/scripts` to identify gaps

This is a research/audit task in plan mode. I should use the Explore agent to understand both codebases and identify the gaps.

Let me launch parallel Explore agents:
1. One to explore the current MSAL device-code implementation in the inbox-zero codebase
2. One to explore the reference implementation in outlook-creds/scripts

This will help me understand what's working in the reference and what's missing in the current implementation.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:01:26.753Z)**_

I'll audit the MSAL device-code flow implementation by exploring both your current codebase and the reference implementation in parallel.

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:01:31.499Z)**_

<tool-use data-tool-type="generic" data-tool-name="Task"><details>
<summary>Tool use: **Task**</summary>
Explore MSAL device-code flow in inbox-zero
```
Now let me generate the comprehensive trace document:

## MSAL Device-Code Flow Implementation Trace

I've thoroughly explored the inbox-zero codebase and created a detailed trace of the MSAL device-code flow implementation. Here's the complete architecture:

---

### **1. OVERVIEW & PURPOSE**

The MSAL device-code flow provides an **alternative authentication method** for Microsoft accounts, enabling users to authenticate without browser-based OAuth redirects. This is useful in CLI/headless environments or when standard OAuth is unavailable.

**Key Characteristics:**
- Uses Azure MSAL Node.js library (`@azure/msal-node`)
- Completely non-breaking: runs parallel to existing Better Auth OAuth
- In-memory token cache for background token refresh
- 15-minute expiration windows with cleanup
- Supports both email access and calendar synchronization

---

### **2. AUTHENTICATION FLOW TRACE**

#### **Phase 1: User Initiation (Frontend)**

**File:** `/Users/hack/github/inbox-zero/apps/web/app/(landing)/login/DeviceCodeLogin.tsx`

The flow starts when user clicks "Start Device Code Flow":

```typescript
// Lines 216-245: initiateFlow hook
const initiateFlow = useCallback(async () => {
  setFlowState("initiated");
  setError(null);
  setDeviceCode(null);

  const response = await fetch("/api/outlook/device-code/initiate", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({}),
  });

  const data: DeviceCodeResponse = await response.json();
  setDeviceCode(data);
  setFlowState("polling");
  activeSessionIdRef.current = data.sessionId;

  pollTimeoutRef.current = setTimeout(() => {
    poll(data.sessionId);
  }, 3000); // Start polling after 3 seconds
}, [poll]);
```

**UI Flow:**
1. User clicks "Start Device Code Flow"
2. Component displays loading spinner
3. Once initiated, displays verification code and URL
4. User copies code and opens verification URL in browser
5. Component polls for completion every 3 seconds

---

#### **Phase 2: Device Code Initiation (Backend)**

**File:** `/Users/hack/github/inbox-zero/apps/web/app/api/outlook/device-code/initiate/route.ts`

Endpoint: `POST /api/outlook/device-code/initiate`

```typescript
// Lines 11-40
export async function POST() {
  if (!isMSALDeviceCodeEnabled()) {
    return NextResponse.json(
      { error: "MSAL device code authentication is not enabled" },
      { status: 403 },
    );
  }

  try {
    const sessionId = nanoid(); // Generate unique session ID
    const result = await initiateDeviceCodeFlow(sessionId);

    return NextResponse.json({
      sessionId: result.sessionId,
      userCode: result.userCode,
      verificationUri: result.verificationUri,
      expiresAt: result.expiresAt.toISOString(),
      message: result.message,
    });
  } catch (error) {
    logger.error("Device code initiation failed", { error });
    return NextResponse.json(
      { error: `Failed to initiate device code flow: ${errorMessage}` },
      { status: 500 },
    );
  }
}
```

---

#### **Phase 3: MSAL Flow Initiation**

**File:** `/Users/hack/github/inbox-zero/apps/web/utils/outlook/msal-device-code.ts`

**Key Function:** `initiateDeviceCodeFlow()` (Lines 208-322)

```typescript
export async function initiateDeviceCodeFlow(
  sessionId: string,
): Promise<DeviceCodeInitResponse> {
  if (!isMSALDeviceCodeEnabled()) {
    throw new Error("MSAL device code flow is not enabled");
  }

  const app = getMSALApp(); // Get/create singleton MSAL app

  cleanupExpiredFlows();

  if (activeFlows.has(sessionId)) {
    throw new Error("Session already exists");
  }

  // Create promise that resolves when authentication completes
  let flowResolve: (result: AuthenticationResult | null) => void;
  let flowReject: (error: Error) => void;
  let capturedDeviceCode: DeviceCodeResponse | null = null;

  const flowPromise = new Promise<AuthenticationResult | null>(
    (resolve, reject) => {
      flowResolve = resolve;
      flowReject = reject;
    },
  );

  const deviceCodeRequest: DeviceCodeRequest = {
    scopes: ["https://graph.microsoft.com/.default"],
    deviceCodeCallback: (response: DeviceCodeResponse) => {
      capturedDeviceCode = response;

      // Calculate expiration time from expiresIn (seconds)
      const expiresAt = new Date(Date.now() + response.expiresIn * 1000);

      // Store flow info for polling
      activeFlows.set(sessionId, {
        deviceCode: response.deviceCode,
        userCode: response.userCode,
        verificationUri: response.verificationUri,
        expiresAt,
        message: response.message,
        promise: flowPromise,
        resolve: flowResolve!,
        reject: flowReject!,
      });

      logger.info("Device code flow initiated", {
        sessionId,
        userCode: response.userCode,
        expiresAt: expiresAt.toISOString(),
      });
    },
    timeout: 900, // 15 minutes
  };

  // Start the flow (non-blocking)
  const authPromise = app.acquireTokenByDeviceCode(deviceCodeRequest);

  // Wait for callback to be called
  await new Promise<void>((resolve, reject) => {
    const checkInterval = setInterval(() => {
      if (capturedDeviceCode) {
        clearInterval(checkInterval);
        resolve();
      }
    }, 100);

    // Timeout after 10 seconds
    setTimeout(() => {
      clearInterval(checkInterval);
      if (!capturedDeviceCode) {
        reject(new Error("Device code callback timeout"));
      }
    }, 10_000);
  });

  const flow = activeFlows.get(sessionId);
  const deviceCodeInfo = capturedDeviceCode as DeviceCodeResponse | null;
  if (!flow || !deviceCodeInfo) {
    throw new Error("Failed to initiate device code flow");
  }

  // Wire up the auth promise to resolve/reject the flow
  authPromise
    .then((result: AuthenticationResult | null) => {
      logger.info("Device code flow completed", { sessionId });
      flow.resolve(result);
    })
    .catch((error: Error) => {
      logger.error("Device code flow failed", {
        sessionId,
        error: error.message,
        name: error.name,
        stack: error.stack?.split("\n").slice(0, 5).join("\n"),
      });
      flow.reject(error);
    });

  return {
    sessionId,
    userCode: deviceCodeInfo.userCode,
    verificationUri: deviceCodeInfo.verificationUri,
    expiresAt: new Date(Date.now() + deviceCodeInfo.expiresIn * 1000),
    message: deviceCodeInfo.message,
  };
}
```

**MSAL App Singleton:** Lines 116-151

```typescript
function getMSALApp(): PublicClientApplication {
  if (!msalApp) {
    const clientId =
      env.MSAL_CLIENT_ID ||
      env.MICROSOFT_CLIENT_ID ||
      MICROSOFT_OFFICE_CLIENT_ID; // d3590ed6-52b3-4102-aeff-aad2292ab01c

    const tenantId = env.MSAL_TENANT_ID || env.MICROSOFT_TENANT_ID || "common";
    const debugEnabled = env.MSAL_DEBUG === "true";

    msalApp = new PublicClientApplication({
      auth: {
        clientId,
        authority: `https://login.microsoftonline.com/${tenantId}`,
      },
      system: {
        loggerOptions: {
          loggerCallback: (level: LogLevel, message: string, containsPii: boolean) => {
            if (containsPii) return; // Don't log PII
            if (debugEnabled || level === LogLevel.Error) {
              logger.info(`MSAL [${LogLevel[level]}]: ${message}`);
            }
          },
          piiLoggingEnabled: false,
          logLevel: debugEnabled ? LogLevel.Verbose : LogLevel.Error,
        },
        // Custom network module to handle Node.js 22+ undici issues
        networkClient: new CustomNetworkModule(),
      },
    });
  }
  return msalApp;
}
```

**Custom Network Module:** Lines 32-91
- Workaround for Node.js 22+ undici connection pool issues
- Fresh fetch calls with 30-second timeout
- Disables keep-alive to avoid connection pool reuse

---

#### **Phase 4: Polling for Completion (Frontend)**

**File:** `/Users/hack/github/inbox-zero/apps/web/app/(landing)/login/DeviceCodeLogin.tsx`

**Polling Hook:** Lines 158-214

```typescript
const poll = useCallback(
  async (sessionId: string) => {
    if (pollInFlightRef.current) return;
    pollInFlightRef.current = true;

    try {
      const response = await fetch("/api/outlook/device-code/poll", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ sessionId }),
      });

      const data: PollResponse = await response.json();

      if (activeSessionIdRef.current !== sessionId) return;

      if (data.status === "complete") {
        cleanup();
        setFlowState("complete");
        toastSuccess({ description: data.message });
        setTimeout(() => {
          onComplete?.();
          window.location.href = data.redirectUrl || "/welcome";
        }, 1500);
        return;
      }

      if (data.status === "expired") {
        cleanup();
        setError("The device code has expired. Please try again.");
        setFlowState("error");
        return;
      }

      if (data.status === "error") {
        cleanup();
        setError(data.error || "Authentication failed");
        setFlowState("error");
        return;
      }

      // Still pending - schedule next poll
      pollTimeoutRef.current = setTimeout(() => {
        poll(sessionId);
      }, 3000); // Poll every 3 seconds
    } catch (_err) {
      cleanup();
      setError("Failed to check authentication status");
      setFlowState("error");
    } finally {
      pollInFlightRef.current = false;
    }
  },
  [cleanup, onComplete],
);
```

---

#### **Phase 5: Server-Side Polling**

**File:** `/Users/hack/github/inbox-zero/apps/web/app/api/outlook/device-code/poll/route.ts`

Endpoint: `POST /api/outlook/device-code/poll`

**Polling Logic:** Lines 41-125

```typescript
export async function POST(request: NextRequest) {
  if (!isMSALDeviceCodeEnabled()) {
    return NextResponse.json(
      { error: "MSAL device code authentication is not enabled" },
      { status: 403 },
    );
  }

  try {
    const body = await request.json();
    const { sessionId } = pollRequestSchema.parse(body);

    logger.info("Poll request received", { sessionId });

    cleanupCompletionCache();
    const cachedCompletion = completionCache.get(sessionId);
    if (cachedCompletion) {
      return respondWithCompletionPromise({
        sessionId,
        entry: cachedCompletion,
      });
    }

    const pollResult = await pollDeviceCodeFlow(sessionId);

    logger.info("Poll result", { sessionId, status: pollResult.status });

    if (pollResult.status === "pending") {
      return NextResponse.json({ status: "pending" });
    }

    if (pollResult.status === "expired") {
      const completedEntry = completionCache.get(sessionId);
      if (completedEntry) {
        return respondWithCompletionPromise({
          sessionId,
          entry: completedEntry,
        });
      }
      logger.info("Flow expired or not found", { sessionId });
      return NextResponse.json({ status: "expired" });
    }

    if (pollResult.status === "error") {
      logger.error("Flow error", { sessionId, error: pollResult.error });
      return NextResponse.json({
        status: "error",
        error: pollResult.error,
      });
    }

    // Authentication complete - create/update account
    if (pollResult.status === "complete" && pollResult.result) {
      const completionPromise = completeDeviceCodeAuthentication({
        pollResult: pollResult.result,
        request,
      });

      completionCache.set(sessionId, {
        promise: completionPromise,
        expiresAt: new Date(Date.now() + COMPLETION_CACHE_TTL_MS),
      });

      return respondWithCompletionPromise({
        sessionId,
        entry: completionCache.get(sessionId)!,
      });
    }

    return NextResponse.json({ status: pollResult.status });
  } catch (error) {
    logger.error("Poll failed", { error });
    return NextResponse.json(
      { status: "error", error: "Poll failed" },
      { status: 500 },
    );
  }
}
```

**Poll Check Function:** Lines 338-406

```typescript
export async function pollDeviceCodeFlow(
  sessionId: string,
): Promise<PollResult> {
  logger.info("Poll called", {
    sessionId,
    activeFlowCount: activeFlows.size,
    hasFlow: activeFlows.has(sessionId),
  });

  const flow = activeFlows.get(sessionId);

  if (!flow) {
    logger.info("Flow not found in activeFlows", { sessionId });
    return { status: "expired" };
  }

  if (new Date() > flow.expiresAt) {
    logger.info("Flow expired", { sessionId, expiresAt: flow.expiresAt });
    activeFlows.delete(sessionId);
    return { status: "expired" };
  }

  // Non-blocking check - use Promise.race to avoid waiting
  const raceResult = await Promise.race([
    flow.promise
      .then((result) => ({ done: true as const, result, error: null }))
      .catch((error) => ({ done: true as const, result: null, error })),
    new Promise<{ done: false }>((resolve) =>
      setTimeout(() => resolve({ done: false }), 100),
    ),
  ]);

  if (!raceResult.done) {
    return { status: "pending" };
  }

  // Flow completed - clean up
  activeFlows.delete(sessionId);

  if (raceResult.error) {
    const errorMessage =
      raceResult.error instanceof Error
        ? raceResult.error.message
        : String(raceResult.error);

    if (errorMessage.includes("authorization_pending")) {
      return { status: "pending" };
    }

    logger.error("Device code flow error", { sessionId, error: errorMessage });
    return { status: "error", error: errorMessage };
  }

  if (!raceResult.result) {
    return { status: "error", error: "No authentication result" };
  }

  return {
    status: "complete",
    result: {
      accessToken: raceResult.result.accessToken,
      expiresAt: raceResult.result.expiresOn || new Date(Date.now() + 3_600_000),
      scopes: raceResult.result.scopes,
      account: raceResult.result.account,
    },
  };
}
```

---

#### **Phase 6: Account Creation & Session Setup**

**File:** `/Users/hack/github/inbox-zero/apps/web/app/api/outlook/device-code/poll/route.ts`

**Function:** `completeDeviceCodeAuthentication()` (Lines 148-275)

```typescript
async function completeDeviceCodeAuthentication({
  pollResult,
  request,
}: {
  pollResult: PollCompleteResult;
  request: NextRequest;
}): Promise<CompletionResult> {
  const { accessToken, expiresAt, scopes, account } = pollResult;

  if (!account) {
    throw new Error("No account info in token response");
  }

  // Get user profile from Microsoft Graph
  const client = createOutlookClient(accessToken, logger);
  const profile = await client.getUserProfile();

  const email = profile.mail?.toLowerCase() || profile.userPrincipalName?.toLowerCase();
  const name = profile.displayName;
  const providerAccountId = account.localAccountId;

  if (!email) {
    throw new Error("Could not determine user email");
  }

  // Encrypt tokens
  const encryptedAccessToken = encryptToken(accessToken);

  // Find or create user
  let user = await prisma.user.findUnique({
    where: { email },
  });

  if (!user) {
    user = await prisma.user.create({
      data: {
        email,
        name: name || email,
        emailVerified: true,
      },
    });
    logger.info("Created new user via MSAL device code", { email });
  }

  // Create or update account
  // Note: MSAL device code flow doesn't provide refresh_token
  const accountRecord = await prisma.account.upsert({
    where: {
      provider_providerAccountId: {
        provider: "microsoft",
        providerAccountId,
      },
    },
    create: {
      userId: user.id,
      provider: "microsoft",
      providerAccountId,
      access_token: encryptedAccessToken,
      refresh_token: null, // MSAL doesn't expose refresh token
      expires_at: expiresAt,
      token_type: "Bearer",
      scope: scopes.join(" "),
    },
    update: {
      access_token: encryptedAccessToken,
      expires_at: expiresAt,
      scope: scopes.join(" "),
    },
  });

  logger.info("MSAL device code authentication complete", {
    email,
    providerAccountId,
  });

  // Update email account and reconnect
  await prisma.$transaction([
    prisma.emailAccount.upsert({
      where: { email },
      update: {
        userId: user.id,
        accountId: accountRecord.id,
        name: name || email,
      },
      create: {
        email,
        userId: user.id,
        accountId: accountRecord.id,
        name: name || email,
      },
    }),
    prisma.account.update({
      where: { id: accountRecord.id },
      data: { disconnectedAt: null },
    }),
  ]);

  // Create Better Auth session
  const sessionToken = crypto.randomUUID();
  const sessionExpires = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000); // 30 days

  await prisma.session.create({
    data: {
      sessionToken,
      userId: user.id,
      expires: sessionExpires,
      ipAddress: request.headers.get("x-forwarded-for") || "unknown",
      userAgent: request.headers.get("user-agent") || "unknown",
    },
  });

  logger.info("Created session for MSAL device code user", {
    email,
    userId: user.id,
  });

  const signedSessionToken = await signSessionToken(sessionToken);

  return {
    email,
    redirectUrl: WELCOME_PATH,
    message: "Authentication successful! Redirecting...",
    signedSessionToken,
    sessionExpires,
  };
}
```

---

### **3. TOKEN STORAGE & RETRIEVAL**

#### **Storage Structure**

**File:** `/Users/hack/github/inbox-zero/apps/web/app/api/user/email-accounts/route.ts`

The `getEmailAccounts()` function identifies device-code authenticated accounts:

```typescript
// Lines 38-72
const accountsWithNames = emailAccounts.map((emailAccount) => {
  // Compute if this is a device-code authenticated account
  // Device-code accounts have refresh_token = null with microsoft provider
  const isDeviceCodeAuth =
    emailAccount.account?.provider === "microsoft" &&
    !emailAccount.account?.refresh_token;

  // Extract providerAccountId for MSAL token lookup
  const providerAccountId = emailAccount.account?.providerAccountId || null;

  // Remove refresh_token from the response (security - don't expose to client)
  const { refresh_token: _refreshToken, ...accountWithoutToken } =
    emailAccount.account || {};

  return {
    ...emailAccount,
    account: accountWithoutToken,
    isDeviceCodeAuth,
    providerAccountId,
  };
});
```

**Database Schema Implications:**
- `Account.provider`: "microsoft"
- `Account.providerAccountId`: MSAL's `account.localAccountId` (identifies account in MSAL cache)
- `Account.refresh_token`: `null` (device-code flow doesn't provide refresh tokens)
- `Account.access_token`: Encrypted access token (initial or cached)
- `Account.expires_at`: Token expiration time

#### **Token Refresh via MSAL Silent Acquisition**

**File:** `/Users/hack/github/inbox-zero/apps/web/utils/outlook/msal-device-code.ts`

**Function:** `acquireMSALTokenSilent()` (Lines 438-504)

```typescript
export async function acquireMSALTokenSilent(
  providerAccountId: string,
  scopes: string[] = MSAL_DEVICE_CODE_SCOPES,
): Promise<{
  accessToken: string;
  expiresAt: Date;
  account: AccountInfo;
} | null> {
  if (!isMSALDeviceCodeEnabled()) {
    logger.warn("MSAL device code flow is not enabled");
    return null;
  }

  const app = getMSALApp();
  const tokenCache = app.getTokenCache();

  try {
    // Get all accounts from MSAL cache
    const accounts = await tokenCache.getAllAccounts();

    if (accounts.length === 0) {
      logger.info("No accounts found in MSAL cache");
      return null;
    }

    // Find the account matching the providerAccountId
    const account = accounts.find(
      (acc: AccountInfo) => acc.localAccountId === providerAccountId,
    );

    if (!account) {
      logger.info("Account not found in MSAL cache", {
        providerAccountId,
        cachedAccountIds: accounts.map((a: AccountInfo) => a.localAccountId),
      });
      return null;
    }

    // Acquire token silently using cached credentials
    const result = await app.acquireTokenSilent({
      account,
      scopes,
    });

    if (!result) {
      logger.warn("acquireTokenSilent returned null", { providerAccountId });
      return null;
    }

    logger.info("Successfully acquired token silently", {
      providerAccountId,
      expiresOn: result.expiresOn?.toISOString(),
    });

    return {
      accessToken: result.accessToken,
      expiresAt: result.expiresOn || new Date(Date.now() + 3_600_000),
      account,
    };
  } catch (error) {
    logger.error("Failed to acquire token silently", {
      providerAccountId,
      error: error instanceof Error ? error.message : String(error),
    });
    return null;
  }
}
```

---

### **4. EMAIL CLIENT TOKEN REFRESH**

**File:** `/Users/hack/github/inbox-zero/apps/web/utils/outlook/client.ts`

**Function:** `getOutlookClientWithRefresh()` (Lines 88-259)

This function handles token refresh for email operations:

```typescript
export const getOutlookClientWithRefresh = async ({
  accessToken,
  refreshToken,
  expiresAt,
  emailAccountId,
  providerAccountId,
  logger,
}: {
  accessToken?: string | null;
  refreshToken: string | null;
  expiresAt: number | null;
  emailAccountId: string;
  providerAccountId?: string | null;
  logger: Logger;
}): Promise<OutlookClient> => {
  // Check if token is still valid
  const expiryDate = expiresAt ? expiresAt : null;
  const TOKEN_REFRESH_BUFFER_MS = 10 * 60 * 1000; // 10 minutes

  if (
    accessToken &&
    expiryDate &&
    expiryDate > Date.now() + TOKEN_REFRESH_BUFFER_MS
  ) {
    return createOutlookClient(accessToken, logger);
  }

  // For device-code accounts (no refresh token), use MSAL silent acquisition
  if (!refreshToken && providerAccountId) {
    logger.info("Using MSAL silent acquisition for email token refresh", {
      emailAccountId,
      providerAccountId,
    });

    const msalResult = await acquireMSALTokenSilent(providerAccountId);

    if (!msalResult) {
      throw new SafeError(
        "Authentication expired. Please log in again using device code flow.",
      );
    }

    // Update the account with the fresh token
    await prisma.account.updateMany({
      where: { providerAccountId },
      data: {
        access_token: encryptToken(msalResult.accessToken),
        expires_at: msalResult.expiresAt,
      },
    });

    logger.info("Updated account with MSAL token", {
      emailAccountId,
      providerAccountId,
    });

    return createOutlookClient(msalResult.accessToken, logger);
  }

  // Standard OAuth flow - requires refresh token
  if (!refreshToken) {
    logger.error("No refresh token", { emailAccountId });
    throw new SafeError("No refresh token");
  }

  // Refresh using OAuth (standard flow)
  // ... (lines 151-259 handle standard OAuth refresh)
};
```

---

### **5. CALENDAR INTEGRATION**

#### **Calendar Client Token Refresh**

**File:** `/Users/hack/github/inbox-zero/apps/web/utils/outlook/calendar-client.ts`

**Function:** `getCalendarClientWithRefresh()` (Lines 41-181)

Similar to email client, but for calendar operations:

```typescript
export const getCalendarClientWithRefresh = async ({
  accessToken,
  refreshToken,
  expiresAt,
  emailAccountId,
  providerAccountId,
  logger,
}: {
  accessToken?: string | null;
  refreshToken: string | null;
  expiresAt: number | null;
  emailAccountId: string;
  providerAccountId?: string | null;
  logger: Logger;
}): Promise<Client> => {
  // Check if token is still valid
  if (expiresAt && expiresAt > Date.now() && accessToken) {
    const authProvider = new CalendarAuthProvider(accessToken);
    return Client.initWithMiddleware({ authProvider });
  }

  // For device-code accounts (no refresh token), use MSAL silent acquisition
  if (!refreshToken && providerAccountId) {
    logger.info("Using MSAL silent acquisition for calendar token refresh", {
      emailAccountId,
      providerAccountId,
    });

    const msalResult = await acquireMSALTokenSilent(providerAccountId);

    if (!msalResult) {
      throw new SafeError(
        "Authentication expired. Please log in again using device code flow.",
      );
    }

    // Update the calendar connection with the fresh token
    const calendarConnection = await prisma.calendarConnection.findFirst({
      where: {
        emailAccountId,
        provider: "microsoft",
      },
      select: { id: true },
    });

    if (calendarConnection) {
      await prisma.calendarConnection.update({
        where: { id: calendarConnection.id },
        data: {
          accessToken: msalResult.accessToken,
          expiresAt: msalResult.expiresAt,
        },
      });
      logger.info("Updated calendar connection with MSAL token", {
        connectionId: calendarConnection.id,
      });
    }

    const authProvider = new CalendarAuthProvider(msalResult.accessToken);
    return Client.initWithMiddleware({ authProvider });
  }

  // Standard OAuth flow
  // ... (lines 103-181)
};
```

#### **Calendar Connection Endpoint**

**File:** `/Users/hack/github/inbox-zero/apps/web/app/api/outlook/calendar/device-code-connect/route.ts`

Endpoint: `POST /api/outlook/calendar/device-code-connect`

This endpoint connects calendars for device-code authenticated accounts (Lines 18-240):

```typescript
export const POST = withEmailAccount(
  "outlook/calendar/device-code-connect",
  async (request) => {
    const { emailAccountId } = request.auth;
    const logger = request.logger;

    // Step 1: Check if MSAL is enabled
    if (!isMSALDeviceCodeEnabled()) {
      return NextResponse.json(
        { success: false, error: "Device code flow is not enabled" },
        { status: 400 },
      );
    }

    // Step 2: Get email account with tokens
    const emailAccount = await prisma.emailAccount.findUnique({
      where: { id: emailAccountId },
      select: {
        id: true,
        email: true,
        account: {
          select: {
            provider: true,
            providerAccountId: true,
            refresh_token: true,
            access_token: true,
            expires_at: true,
          },
        },
      },
    });

    // Step 3: Verify it's a device-code account
    const isDeviceCodeAuth =
      emailAccount.account?.provider === "microsoft" &&
      !emailAccount.account?.refresh_token;

    if (!isDeviceCodeAuth) {
      return NextResponse.json(
        {
          success: false,
          error: "This endpoint is only for device-code authenticated accounts",
        },
        { status: 400 },
      );
    }

    const providerAccountId = emailAccount.account?.providerAccountId;

    // Step 4: Get access token (try stored first, then MSAL)
    let accessToken: string;
    let tokenExpiresAt: Date;

    const storedToken = emailAccount.account?.access_token;
    const storedExpiry = emailAccount.account?.expires_at;
    const tokenStillValid =
      storedToken &&
      storedExpiry &&
      storedExpiry.getTime() > Date.now() + 5 * 60 * 1000; // 5 min buffer

    if (tokenStillValid && storedToken) {
      // Use stored token if still valid
      const { decryptToken } = await import("@/utils/encryption");
      const decrypted = decryptToken(storedToken);
      if (!decrypted) {
        return NextResponse.json(
          { success: false, error: "Token decryption failed" },
          { status: 500 },
        );
      }
      accessToken = decrypted;
      tokenExpiresAt = storedExpiry!;
    } else {
      // Try MSAL for token refresh
      const msalResult = await acquireMSALTokenSilent(providerAccountId);

      if (!msalResult) {
        return NextResponse.json(
          {
            success: false,
            error: "Authentication expired. Please log in again using device code flow.",
          },
          { status: 401 },
        );
      }

      accessToken = msalResult.accessToken;
      tokenExpiresAt = msalResult.expiresAt;
    }

    // Step 5: Fetch user email from Graph API
    const profileResponse = await fetch(
      "https://graph.microsoft.com/v1.0/me",
      {
        headers: {
          Authorization: `Bearer ${accessToken}`,
        },
      },
    );

    const profile = await profileResponse.json();
    const microsoftEmail = profile.mail || profile.userPrincipalName;

    // Step 6: Check for existing connection
    const existingConnection = await checkExistingConnection(
      emailAccountId,
      "microsoft",
      microsoftEmail,
    );

    if (existingConnection) {
      return NextResponse.json({
        success: true,
        connectionId: existingConnection.id,
      });
    }

    // Step 7: Create CalendarConnection
    const connection = await createCalendarConnection({
      provider: "microsoft",
      email: microsoftEmail,
      emailAccountId,
      accessToken,
      refreshToken: "", // Empty string since device-code doesn't provide refresh tokens
      expiresAt: tokenExpiresAt,
    });

    // Step 8: Sync calendars
    const microsoftProvider = createMicrosoftCalendarProvider(logger);
    await microsoftProvider.syncCalendars(
      connection.id,
      accessToken,
      "", // No refresh token for device-code
      emailAccountId,
      tokenExpiresAt,
      providerAccountId, // Pass for MSAL token refresh
    );

    return NextResponse.json({
      success: true,
      connectionId: connection.id,
    });
  },
);
```

#### **Calendar Provider**

**File:** `/Users/hack/github/inbox-zero/apps/web/utils/calendar/providers/microsoft.ts`

```typescript
export function createMicrosoftCalendarProvider(
  logger: Logger,
): CalendarOAuthProvider {
  return {
    name: "microsoft",

    async syncCalendars(
      connectionId: string,
      accessToken: string,
      refreshToken: string,
      emailAccountId: string,
      expiresAt: Date | null,
      providerAccountId?: string | null,
    ): Promise<void> {
      // Get calendar client (handles token refresh if needed)
      const calendarClient = await getCalendarClientWithRefresh({
        accessToken,
        refreshToken,
        expiresAt: expiresAt?.getTime() ?? null,
        emailAccountId,
        providerAccountId,
        logger,
      });

      // Fetch calendars from Microsoft Graph
      const microsoftCalendars = await fetchMicrosoftCalendars(
        calendarClient,
        logger,
      );

      // Upsert calendars into database
      for (const microsoftCalendar of microsoftCalendars) {
        await prisma.calendar.upsert({
          where: {
            connectionId_calendarId: {
              connectionId,
              calendarId: microsoftCalendar.id,
            },
          },
          update: {
            name: microsoftCalendar.name || "Untitled Calendar",
            description: microsoftCalendar.description,
            timezone: null,
          },
          create: {
            connectionId,
            calendarId: microsoftCalendar.id,
            name: microsoftCalendar.name || "Untitled Calendar",
            description: microsoftCalendar.description,
            timezone: null,
            isEnabled: true,
          },
        });
      }

      await autoPopulateTimezone(emailAccountId, microsoftCalendars, logger);
    },
  };
}
```

#### **Calendar Connection UI**

**File:** `/Users/hack/github/inbox-zero/apps/web/app/(app)/[emailAccountId]/calendars/ConnectCalendar.tsx`

```typescript
const handleConnectMicrosoft = async () => {
  setIsConnectingMicrosoft(true);
  try {
    // Device-code authenticated accounts use direct API call instead of OAuth redirect
    if (isDeviceCodeAuth) {
      const response = await fetchWithAccount({
        url: "/api/outlook/calendar/device-code-connect",
        emailAccountId,
        init: {
          method: "POST",
          headers: { "Content-Type": "application/json" },
        },
      });

      const data: DeviceCodeCalendarConnectResponse = await response.json();

      if (!data.success) {
        throw new Error(data.error || "Failed to connect calendar");
      }

      toastSuccess({ description: "Calendar connected successfully!" });
      window.location.reload();
      return;
    }

    // OAuth flow for non-device-code accounts
    // ...
  } catch (error) {
    toastError({
      title: "Error connecting Microsoft calendar",
      description:
        error instanceof Error
          ? error.message
          : "Please try again or contact support",
    });
    setIsConnectingMicrosoft(false);
  }
};
```

---

### **6. SCOPES & PERMISSIONS**

**File:** `/Users/hack/github/inbox-zero/apps/web/utils/outlook/scopes.ts`

```typescript
export const SCOPES = [
  "openid",
  "profile",
  "email",
  "User.Read",
  "offline_access", // Required for refresh tokens
  "Mail.ReadWrite", // Read and write access to mailbox
  ...(env.NEXT_PUBLIC_EMAIL_SEND_ENABLED ? ["Mail.Send"] : []),
  "MailboxSettings.ReadWrite", // Read and write mailbox settings
] as const;

export const CALENDAR_SCOPES = [
  "openid",
  "profile",
  "email",
  "User.Read",
  "offline_access", // Required for refresh tokens
  "Calendars.Read", // Read user calendars
  "Calendars.ReadWrite", // Read and write user calendars
] as const;
```

**Device Code Flow Scope:**
```typescript
const MSAL_DEVICE_CODE_SCOPES = ["https://graph.microsoft.com/.default"];
```

The `.default` scope requests all pre-authorized permissions without requiring explicit consent.

---

### **7. ENVIRONMENT CONFIGURATION**

**File:** `/Users/hack/github/inbox-zero/apps/web/env.ts` (Lines 83-88)

```typescript
// MSAL Device Code Flow (alternative auth method)
MSAL_CLIENT_ID: z.string().optional(), // Falls back to MICROSOFT_CLIENT_ID or default Office client ID
MSAL_TENANT_ID: z.string().optional(), // Falls back to MICROSOFT_TENANT_ID
MSAL_ENABLED: z.string().optional(), // Set to "true" to enable
MSAL_DEBUG: z.string().optional(), // Set to "true" for verbose logging
```

**Default Values:**
- `MSAL_CLIENT_ID`: Falls back to `MICROSOFT_CLIENT_ID` or `d3590ed6-52b3-4102-aeff-aad2292ab01c` (Microsoft Office client ID)
- `MSAL_TENANT_ID`: Falls back to `MICROSOFT_TENANT_ID` or `"common"`
- `MSAL_ENABLED`: Defaults to disabled (`"false"`)
- `MSAL_DEBUG`: Defaults to disabled

---

### **8. CONTEXT & PROVIDER INTEGRATION**

**File:** `/Users/hack/github/inbox-zero/apps/web/providers/EmailAccountProvider.tsx`

The provider exposes device-code authentication status to components:

```typescript
interface Context {
  emailAccount: GetEmailAccountsResponse["emailAccounts"][number] | undefined;
  emailAccountId: string;
  userEmail: string;
  isLoading: boolean;
  provider: string;
  isDeviceCodeAuth: boolean; // Key flag
  providerAccountId: string | null; // For MSAL token lookup
}

// Usage in components
const { emailAccountId, isDeviceCodeAuth, providerAccountId } = useAccount();
```

---

### **9. KEY ARCHITECTURAL PATTERNS**

#### **A. In-Memory Flow Storage**

Lines 158-194 in `msal-device-code.ts`:

```typescript
interface ActiveFlow {
  deviceCode: string;
  userCode: string;
  verificationUri: string;
  expiresAt: Date;
  message: string;
  promise: Promise<AuthenticationResult | null>;
  resolve: (result: AuthenticationResult | null) => void;
  reject: (error: Error) => void;
}

const activeFlows = new Map<string, ActiveFlow>();

// Cleanup expired flows every 5 minutes
setInterval(cleanupExpiredFlows, 5 * 60 * 1000);
```

#### **B. Non-Blocking Polling**

Lines 361-368 in `msal-device-code.ts`:

```typescript
const raceResult = await Promise.race([
  flow.promise
    .then((result) => ({ done: true as const, result, error: null }))
    .catch((error) => ({ done: true as const, result: null, error })),
  new Promise<{ done: false }>((resolve) =>
    setTimeout(() => resolve({ done: false }), 100),
  ),
]);
```

This avoids blocking while waiting for MSAL to complete. Returns immediately if still pending.

#### **C. Token Refresh Precedence**

In both `client.ts` and `calendar-client.ts`:

1. Check if stored token is still valid (> 10-minute buffer)
2. If device-code (no refresh token) → Use MSAL silent acquisition
3. If standard OAuth → Use refresh token to get new tokens

#### **D. Security Layers**

1. **Token Encryption:** All access tokens stored in DB are encrypted
2. **No Refresh Token Exposure:** Device-code accounts never have refresh tokens in database
3. **No PII Logging:** MSAL logging disabled for PII
4. **Session Cookies:** Signed and secure HTTP-only cookies

---

### **10. FILE PATHS SUMMARY**

| Component | File Path | Purpose |
|-----------|-----------|---------|
| **MSAL Core** | `/apps/web/utils/outlook/msal-device-code.ts` | Device code flow implementation |
| **Device Code Routes** | `/apps/web/app/api/outlook/device-code/initiate/route.ts` | Initiate flow |
| | `/apps/web/app/api/outlook/device-code/poll/route.ts` | Poll for completion & create session |
| **Email Client** | `/apps/web/utils/outlook/client.ts` | Outlook client with MSAL token refresh |
| **Calendar Client** | `/apps/web/utils/outlook/calendar-client.ts` | Calendar operations with MSAL refresh |
| **Calendar Provider** | `/apps/web/utils/calendar/providers/microsoft.ts` | Microsoft calendar sync |
| **Calendar Connect** | `/apps/web/app/api/outlook/calendar/device-code-connect/route.ts` | Device-code calendar connection |
| **Frontend Login** | `/apps/web/app/(landing)/login/DeviceCodeLogin.tsx` | Device code UI & polling |
| **Calendar UI** | `/apps/web/app/(app)/[emailAccountId]/calendars/ConnectCalendar.tsx` | Calendar connection selector |
| **Email Accounts** | `/apps/web/app/api/user/email-accounts/route.ts` | Account list with device-code detection |
| **Provider Context** | `/apps/web/providers/EmailAccountProvider.tsx` | Account context with device-code flag |
| **Scopes** | `/apps/web/utils/outlook/scopes.ts` | Permission scopes |
| **Environment** | `/apps/web/env.ts` | Configuration variables |
| **Tests** | `/apps/web/utils/outlook/msal-device-code.test.ts` | Unit tests |

---

### **11. DATA FLOW DIAGRAM**

```
User Browser
    ↓
DeviceCodeLogin.tsx (initiateFlow)
    ↓
POST /api/outlook/device-code/initiate
    ↓
msal-device-code.ts:initiateDeviceCodeFlow()
    ├→ getMSALApp() [Singleton MSAL app]
    ├→ app.acquireTokenByDeviceCode()
    ├→ Store in activeFlows Map
    └→ Return { userCode, verificationUri, ... }
    ↓
Frontend displays code & verification URL
User opens verificationUri & signs in
    ↓
MSAL completes authorization
    ↓
Frontend polls every 3 seconds
    ↓
POST /api/outlook/device-code/poll
    ↓
msal-device-code.ts:pollDeviceCodeFlow()
    ├→ Check activeFlows for flow status
    └→ Return { status: "pending" | "complete" | "expired" | "error" }
    ↓
[When complete]
    ↓
poll/route.ts:completeDeviceCodeAuthentication()
    ├→ Get user profile from Graph API
    ├→ Create/update User in DB
    ├→ Create/update Account (refresh_token = null)
    ├→ Create/update EmailAccount
    ├→ Create Session
    └→ Set session cookie
    ↓
Frontend redirects to /welcome
    ↓
[User can now use app]
    ↓
When accessing email/calendar:
    ├→ client.ts:getOutlookClientWithRefresh()
    │  ├→ Check token valid?
    │  ├→ If expired & device-code:
    │  │  └→ acquireMSALTokenSilent(providerAccountId)
    │  │     ├→ Get MSAL app
    │  │     ├→ Get token cache
    │  │     ├→ Find account by localAccountId
    │  │     └→ acquireTokenSilent()
    │  └→ Return OutlookClient with access token
    │
    └→ calendar-client.ts:getCalendarClientWithRefresh()
       └→ Same pattern for calendar access
```

---

### **12. CRITICAL POINTS**

1. **No Refresh Token Storage:** Device-code accounts never have `refresh_token` in database; MSAL cache handles refresh internally
2. **providerAccountId Mapping:** MSAL's `account.localAccountId` is stored and used to find the account in MSAL's token cache
3. **Scopes:** Device code uses `.default` scope; email/calendar use specific scopes
4. **In-Memory Storage:** Active flows stored in Map with 5-minute cleanup interval
5. **Non-Breaking:** Runs parallel to existing OAuth; feature flagged with `MSAL_ENABLED`
6. **Custom Network Module:** Workaround for Node.js 22+ undici connection pool issues
7. **Token Encryption:** All stored tokens are encrypted using `encryptToken()`

---

This comprehensive trace shows how the MSAL device-code flow integrates seamlessly with the existing inbox-zero authentication system, providing an alternative path for Microsoft account authentication while maintaining backward compatibility with OAuth-based accounts.
agentId: a117e7c (for resuming to continue this agent's work if needed)
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:01:34.161Z)**_

<tool-use data-tool-type="generic" data-tool-name="Task"><details>
<summary>Tool use: **Task**</summary>
Explore reference MSAL implementation
```
Excellent! Now I have comprehensive information about the MSAL implementation. Let me provide a detailed analysis report:

## MSAL Device-Code Flow Reference Implementation - Complete Analysis

I've explored the outlook-creds repository and found a comprehensive MSAL implementation. Here's the complete authentication flow with detailed code excerpts:

### 1. DEVICE-CODE FLOW INITIATION

**File:** `/Users/hack/github/outlook-creds/src/outlook_creds/auth/oauth.py` (lines 98-184)

```python
def authenticate_with_msal(params: dict[str, Any]) -> dict[str, Any]:
    """Authenticate user via MSAL device code flow."""
    
    # Create MSAL public client application
    app = PublicClientApplication(
        client_id=params["client_id"],
        authority=params["authority"]
    )
    
    # Check for cached tokens first
    accounts = app.get_accounts(username=params["email"])
    if accounts:
        result = app.acquire_token_silent(scopes=params["scopes"], account=accounts[0])
        if result and "access_token" in result:
            return result
    
    # Initiate device code flow
    flow = app.initiate_device_flow(scopes=params["scopes"])
    
    # Display user code and verification URI
    print(flow["message"])  # "To sign in, use a web browser..."
    user_code = flow.get("user_code", "")
    verification_uri = flow.get("verification_uri", "")
    
    # Wait for user authentication
    result = app.acquire_token_by_device_flow(flow)
    return result
```

**Key Points:**
- MSAL's `initiate_device_flow()` creates the authentication context
- Returns `user_code`, `verification_uri`, and `message` for user display
- `acquire_token_by_device_flow()` polls Azure AD for completion
- Automatic silent authentication if cached account exists

### 2. SCOPE CONFIGURATION

**File:** `/Users/hack/github/outlook-creds/src/outlook_creds/auth/oauth.py` (lines 50-96)

```python
def extract_token_params(
    account_info: dict[str, Any],
    api_scope: str = "graph",
    explicit_scopes: list[str] | None = None,
) -> dict[str, Any] | None:
    """Extract parameters needed for OAuth token request."""
    
    additional_props = json.loads(account_info["additional_properties"])
    
    # Scope selection logic
    if explicit_scopes:
        scopes = explicit_scopes
    elif api_scope == "graph":
        scopes = ["https://graph.microsoft.com/.default"]
    elif api_scope == "outlook":
        scopes = ["https://outlook.office365.com/.default"]
    elif api_scope == "both":
        # Request Graph as primary - refresh token works for both
        scopes = ["https://graph.microsoft.com/.default"]
    
    return {
        "tenant_id": account_info["realm"],
        "account_id": account_info["id"],
        "authority": account_info["authority"],
        "email": account_info["login_name"],
        "client_id": additional_props.get("aud", "d3590ed6-52b3-4102-aeff-aad2292ab01c"),
        "scopes": scopes,
    }
```

**Default Scopes:**
- **Graph API (primary):** `https://graph.microsoft.com/.default`
- **Outlook API:** `https://outlook.office365.com/.default`
- **offline_access:** Automatic with `.default` scope
- **Authority:** `https://login.microsoftonline.com/{tenant_id}`

### 3. MICROSOFT CLIENT ID CONFIGURATION

**File:** `/Users/hack/github/outlook-creds/scripts/refresh_access_token.sh` (lines 11-14)

```bash
# Microsoft OAuth2 Configuration
# client_id for Microsoft Office (from analysis)
CLIENT_ID="d3590ed6-52b3-4102-aeff-aad2292ab01c"
TOKEN_ENDPOINT="https://login.microsoftonline.com/common/oauth2/v2.0/token"
```

**IMPORTANT:** This is the **official Microsoft Office client ID**, used by:
- Microsoft Outlook
- Microsoft 365 applications
- Azure AD native clients

It's a well-known public client ID that doesn't require a client secret.

### 4. TOKEN ACQUISITION & STORAGE FLOW

**Sequence:**
1. **Extract account info from keychain** → Account metadata with tenant ID
2. **Initiate device code flow** → User gets code + verification URI
3. **User authenticates in browser** → Azure AD validates credentials
4. **MSAL polls for completion** → Returns access + refresh tokens
5. **Save tokens to disk** → Structured JSON + raw text files

**Storage Structure** (lines 251-342 in oauth.py):

```python
def save_tokens(
    params: dict[str, Any],
    msal_result: dict[str, Any],
    token_dir: Path,
    api_type: str = "graph",
) -> None:
    """Save tokens in multiple formats for compatibility."""
    
    # 1. Full OAuth response (token_dir/oauth_tokens.json)
    oauth_tokens = {
        "access_token": msal_result["access_token"],
        "refresh_token": msal_result.get("refresh_token", ""),
        "token_type": msal_result.get("token_type", "Bearer"),
        "expires_in": msal_result.get("expires_in", 3600),
        "scope": msal_result.get("scope"),
        "tenant_id": params["tenant_id"],
        "obtained_via": "msal_device_code_flow",
        "obtained_at": datetime.now(UTC).isoformat(),
    }
    
    # 2. Refresh token separately (TOKENS_DIR/{email}_refresh_only.txt)
    if msal_result.get("refresh_token"):
        refresh_file = TOKENS_DIR / f"{normalized}_refresh_only.txt"
        secure_write_token(refresh_file, msal_result["refresh_token"])
    
    # 3. Structured access token (TOKENS_DIR/{email}_access_token.json)
    access_token_data = {
        "email": email,
        "access_token": msal_result["access_token"],
        "token_type": msal_result.get("token_type", "Bearer"),
        "expires_in": msal_result.get("expires_in", 3600),
        "expires_at": expires_at.strftime("%Y-%m-%dT%H:%M:%SZ"),
        "refreshed_at": datetime.now(UTC).strftime("%Y-%m-%dT%H:%M:%SZ"),
        "scopes": msal_result.get("scope", ""),
        "api_type": api_type,
    }
    
    # 4. Raw access token (TOKENS_DIR/{email}_access_only.txt)
    access_only_file = TOKENS_DIR / f"{normalized}{token_suffix}_access_only.txt"
    secure_write_token(access_only_file, msal_result["access_token"])
```

**File Permissions:** `0o600` (readable/writable by owner only)

### 5. TOKEN REFRESH MECHANISM

**File:** `/Users/hack/github/outlook-creds/scripts/refresh_access_token.sh` (lines 25-129)

```bash
refresh_token() {
    local refresh_token="$1"
    local scopes="${2:-$DEFAULT_SCOPES}"
    local email="${3:-unknown}"
    
    # Prepare OAuth2 refresh request
    local post_data
    post_data="client_id=${CLIENT_ID}&grant_type=refresh_token&refresh_token=${refresh_token}&scope=${scopes// /%20}"
    
    # Call Microsoft token endpoint
    response=$(curl -s -w "\n%{http_code}" \
        -X POST \
        -H "Content-Type: application/x-www-form-urlencoded" \
        --data "$post_data" \
        "$TOKEN_ENDPOINT")
    
    # Parse response
    access_token=$(echo "$body" | jq -r '.access_token // empty')
    expires_in=$(echo "$body" | jq -r '.expires_in // empty')
    new_refresh_token=$(echo "$body" | jq -r '.refresh_token // empty')
    
    # Calculate expiration time
    expires_at=$(date -u -v+${expires_in}S +%Y-%m-%dT%H:%M:%SZ)
    
    # Create structured token file
    cat > "$token_file" <<EOF
{
  "email": "$email",
  "access_token": "$access_token",
  "token_type": "$token_type",
  "expires_in": $expires_in,
  "expires_at": "$expires_at",
  "refreshed_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "scopes": "$scopes",
  "api_type": "$api_type"
}
EOF
}
```

**Refresh Token Validation** (lines 131-184):

```bash
is_token_valid() {
    local email="$1"
    local token_file="${TOKENS_DIR}/${email}_access_token.json"
    
    if [[ ! -f "$token_file" ]]; then
        return 1
    fi
    
    local expires_at
    expires_at=$(jq -r '.expires_at' "$token_file")
    
    # Convert to epoch and add 60-second buffer
    local expires_epoch=$(date -jf "%Y-%m-%dT%H:%M:%SZ" "$expires_at" +%s)
    local now_epoch=$(date +%s)
    
    # Refresh if expiring in < 60 seconds
    if [[ $((expires_epoch - 60)) -gt $now_epoch ]]; then
        return 0  # Valid
    fi
    
    return 1  # Expired
}
```

### 6. MULTI-API TOKEN ACQUISITION

**For Both Graph and Outlook APIs** (lines 187-249 in oauth.py):

```python
def acquire_outlook_token_via_refresh(
    refresh_token: str,
    params: dict[str, Any],
) -> dict[str, Any] | None:
    """Use refresh token to acquire Outlook API access token."""
    
    token_endpoint = f"https://login.microsoftonline.com/{params['tenant_id']}/oauth2/v2.0/token"
    outlook_scope = "https://outlook.office365.com/.default offline_access"
    
    data = urllib.parse.urlencode({
        "client_id": params["client_id"],
        "grant_type": "refresh_token",
        "refresh_token": refresh_token,
        "scope": outlook_scope,
    }).encode("utf-8")
    
    headers = {
        "Content-Type": "application/x-www-form-urlencoded",
        "Accept": "application/json",
    }
    
    req = urllib.request.Request(token_endpoint, data=data, headers=headers)
    with urllib.request.urlopen(req, timeout=30) as response:
        result = json.loads(response.read().decode("utf-8"))
        return result if "access_token" in result else None
```

**Key Pattern:** Single refresh token works for multiple APIs - request one scope in device flow, use refresh token for others.

### 7. COMPLETE AUTHENTICATION ORCHESTRATION

**File:** `/Users/hack/github/outlook-creds/scripts/auth_helper.sh` (lines 27-80)

```bash
setup_account() {
    local email="$1"
    local api_scope="${3:-graph}"
    
    info "[1/4] Extracting account metadata from keychain..."
    "$EXTRACT_SCRIPT" "$email"
    
    info "[2/4] Obtaining OAuth tokens via MSAL..."
    "$OAUTH_SCRIPT" "$email" "--api=$api_scope"
    
    # Step 3: Verify refresh token
    local refresh_token_file="${TOKENS_DIR}/${email}_refresh_only.txt"
    if [[ ! -f "$refresh_token_file" ]]; then
        error "Refresh token not found"
        return 1
    fi
    
    info "[4/4] Storing account metadata..."
    "$STORE_SCRIPT" store "$email" "$account_name" "Exchange" "$api_scope"
    
    info "Access token expires at: $(jq -r '.expires_at' "$access_token_file")"
}
```

### 8. TOKEN PERSISTENCE & MANAGEMENT

**Token Storage Structure:**

```
~/.config/outlook-creds/
├── tokens/
│   ├── user@example.com_refresh_only.txt      # Just refresh token
│   ├── user@example.com_access_token.json     # Structured access token
│   ├── user@example.com_access_only.txt       # Raw access token
│   ├── user@example.com_outlook_access_token.json  # Outlook scope variant
│   └── user@example.com_outlook_access_only.txt
└── metadata/
    └── user@example.com_metadata.json         # Account metadata
```

**Token Cache Validation** (`refresh_access_token.sh`):

```bash
get_access_token() {
    local email="$1"
    local force_refresh="${3:-false}"
    
    # Check if valid token exists
    if [[ "$force_refresh" != "true" ]] && is_token_valid "$email"; then
        cat "${TOKENS_DIR}/${email}_access_only.txt"
        return 0
    fi
    
    # Refresh if expired
    local refresh_token=$(cat "$refresh_token_file")
    refresh_token "$refresh_token" "$scopes" "$email"
}
```

### 9. GRAPH API USAGE AFTER AUTHENTICATION

**File:** `/Users/hack/github/outlook-creds/scripts/auth_helper.sh` (lines 154-217)

```bash
test_auth() {
    local email="$1"
    
    # Get access token
    access_token=$(get_token_for_api "$email" "https://graph.microsoft.com/.default")
    
    # Test with /me endpoint
    response=$(curl -s -w "\n%{http_code}" \
        -H "Authorization: Bearer $access_token" \
        -H "Content-Type: application/json" \
        "https://graph.microsoft.com/v1.0/me")
    
    http_code=$(echo "$response" | tail -n1)
    local body=$(echo "$response" | sed '$d')
    
    if [[ "$http_code" == "200" ]]; then
        display_name=$(echo "$body" | jq -r '.displayName')
        email_address=$(echo "$body" | jq -r '.userPrincipalName')
        user_id=$(echo "$body" | jq -r '.id')
        
        echo "Display Name: $display_name"
        echo "Email: $email_address"
        echo "User ID: $user_id"
    fi
}
```

### 10. CREDENTIAL RETRIEVAL FOR API USE

**File:** `/Users/hack/github/outlook-creds/scripts/store_credentials.sh` (lines 153-245)

```bash
get_credentials() {
    local email="$1"
    local format="${2:-json}"
    
    case "$format" in
        json)
            cat <<EOF
{
  "email": "$email",
  "access_token": "$(jq -r '.access_token' "$access_token_file")",
  "refresh_token": "$(cat "$refresh_token_file")",
  "token_type": "Bearer",
  "expires_at": "$(jq -r '.expires_at' "$access_token_file")"
}
EOF
            ;;
        access-token)
            cat "${TOKENS_DIR}/${email}_access_only.txt"
            ;;
        curl)
            local token=$(cat "${TOKENS_DIR}/${email}_access_only.txt")
            echo "-H 'Authorization: Bearer $token' -H 'X-User-Identity: $email'"
            ;;
    esac
}
```

### Summary: Complete Authentication Flow

```
1. KEYCHAIN EXTRACTION
   ├─ Extract OneAuth account metadata
   ├─ Parse account info (tenant ID, user ID, authority)
   └─ Save to: ~/config/outlook-creds/tokens/{email}/account_info.json

2. DEVICE CODE FLOW
   ├─ Create PublicClientApplication(client_id, authority)
   ├─ Call initiate_device_flow(scopes)
   ├─ Display user_code and verification_uri
   ├─ Poll with acquire_token_by_device_flow()
   └─ Return: {access_token, refresh_token, expires_in, ...}

3. TOKEN STORAGE
   ├─ oauth_tokens.json        → Full response
   ├─ {email}_refresh_only.txt → Refresh token only
   ├─ {email}_access_token.json → Structured token metadata
   └─ {email}_access_only.txt  → Raw token string

4. MULTI-API TOKENS
   ├─ Request Graph API (.default) in device flow
   ├─ Get universal refresh token
   └─ Use refresh token to acquire Outlook API tokens separately

5. TOKEN REFRESH
   ├─ Check is_token_valid() → expires_at vs now()
   ├─ If expired: POST refresh_token to token endpoint
   ├─ Parse new access_token + optional new refresh_token
   └─ Update local token files

6. API USAGE
   ├─ Retrieve access token from local file
   ├─ Make HTTP request with: Authorization: Bearer {token}
   └─ Handle 401 → refresh → retry
```

This reference implementation demonstrates production-ready MSAL device-code flow with comprehensive token caching, refresh logic, and multi-API support.
agentId: a891368 (for resuming to continue this agent's work if needed)
```
</details></tool-use>

_**Agent - sidechain (2026-01-24T04:01:38.227Z)**_

Explore the reference MSAL implementation in /Users/hack/github/outlook-creds/scripts

Focus on:
1. How device-code flow is initiated and handled
2. What scopes are used (especially default graph scopes)
3. How tokens are acquired, stored, and refreshed
4. How the Microsoft Office Client ID is configured
5. How Graph API calls are made after authentication
6. Any token caching or persistence mechanisms

Provide detailed code excerpts and explain the complete authentication flow.

_**Agent - sidechain (2026-01-24T04:01:38.384Z)**_

Explore the MSAL device-code flow implementation in the inbox-zero codebase. Focus on:

1. Find all files related to MSAL, device-code flow, and Microsoft authentication
2. Trace the authentication flow from user initiation to token acquisition
3. Identify how tokens are stored, refreshed, and used for Graph API calls
4. Look at the Microsoft Office Client ID usage and scope configuration
5. Examine the calendar/outlook integration files mentioned in git status:
   - apps/web/app/api/outlook/calendar/device-code-connect/route.ts
   - apps/web/utils/outlook/msal-device-code.ts
   - apps/web/utils/outlook/client.ts
   - apps/web/utils/outlook/calendar-client.ts
   - apps/web/utils/calendar/providers/microsoft.ts

Provide a detailed trace of the current implementation with file paths and key code sections.

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:01:39.907Z)**_

I'll explore the MSAL implementation in the outlook-creds repository to understand the device-code flow and authentication patterns.

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:01:40.117Z)**_

<tool-use data-tool-type="shell" data-tool-name="Bash"><details>
<summary>Tool use: **Bash**</summary>

`find /Users/hack/github/outlook-creds/scripts -type f -name "*.ts" -o -name "*.js" -o -name "*.json" | head -20`
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:01:40.241Z)**_

I'll systematically explore the MSAL device-code flow implementation in the inbox-zero codebase. Let me start by searching for all related files and understanding the authentication architecture.

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:01:40.453Z)**_

<tool-use data-tool-type="search" data-tool-name="Glob"><details>
<summary>Tool use: **Glob**</summary>
 pattern `**/*msal*.ts`
```
/Users/hack/github/inbox-zero/apps/web/scripts/msal-authenticate.ts
/Users/hack/github/inbox-zero/apps/web/utils/outlook/msal-device-code.test.ts
/Users/hack/github/inbox-zero/apps/web/utils/outlook/msal-device-code.ts
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:01:40.617Z)**_

<tool-use data-tool-type="search" data-tool-name="Glob"><details>
<summary>Tool use: **Glob**</summary>
 pattern `**/*device-code*.ts`
```
/Users/hack/github/inbox-zero/apps/web/scripts/test-device-code-api.ts
/Users/hack/github/inbox-zero/apps/web/utils/outlook/msal-device-code.test.ts
/Users/hack/github/inbox-zero/apps/web/utils/outlook/msal-device-code.ts
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:01:40.821Z)**_

<tool-use data-tool-type="search" data-tool-name="Glob"><details>
<summary>Tool use: **Glob**</summary>
 pattern `**/outlook/**/*.ts`
```
/Users/hack/github/inbox-zero/apps/web/app/api/outlook/calendar/callback/route.ts
/Users/hack/github/inbox-zero/apps/web/app/api/outlook/linking/callback/route.ts
/Users/hack/github/inbox-zero/apps/web/app/api/outlook/watch/all/route.ts
/Users/hack/github/inbox-zero/apps/web/app/api/outlook/watch/route.ts
/Users/hack/github/inbox-zero/apps/web/app/api/outlook/webhook/process-history.ts
/Users/hack/github/inbox-zero/apps/web/app/api/outlook/webhook/route.ts
/Users/hack/github/inbox-zero/apps/web/app/api/outlook/webhook/types.ts
/Users/hack/github/inbox-zero/apps/web/utils/outlook/attachment.ts
/Users/hack/github/inbox-zero/apps/web/utils/outlook/constants.ts
/Users/hack/github/inbox-zero/apps/web/utils/outlook/draft.ts
/Users/hack/github/inbox-zero/apps/web/utils/outlook/errors.ts
/Users/hack/github/inbox-zero/apps/web/utils/outlook/filter.ts
/Users/hack/github/inbox-zero/apps/web/utils/outlook/folders.test.ts
/Users/hack/github/inbox-zero/apps/web/utils/outlook/label.ts
/Users/hack/github/inbox-zero/apps/web/utils/outlook/mail.ts
/Users/hack/github/inbox-zero/apps/web/utils/outlook/message.ts
/Users/hack/github/inbox-zero/apps/web/utils/outlook/odata-escape.test.ts
/Users/hack/github/inbox-zero/apps/web/utils/outlook/odata-escape.ts
/Users/hack/github/inbox-zero/apps/web/utils/outlook/reply.test.ts
/Users/hack/github/inbox-zero/apps/web/utils/outlook/reply.ts
/Users/hack/github/inbox-zero/apps/web/utils/outlook/retry.test.ts
/Users/hack/github/inbox-zero/apps/web/utils/outlook/retry.ts
/Users/hack/github/inbox-zero/apps/web/utils/outlook/scopes.ts
/Users/hack/github/inbox-zero/apps/web/utils/outlook/spam.ts
/Users/hack/github/inbox-zero/apps/web/utils/outlook/subscription-history.test.ts
/Users/hack/github/inbox-zero/apps/web/utils/outlook/subscription-manager.test.ts
/Users/hack/github/inbox-zero/apps/web/utils/outlook/subscription-manager.ts
/Users/hack/github/inbox-zero/apps/web/utils/outlook/thread.ts
/Users/hack/github/inbox-zero/apps/web/utils/outlook/trash.ts
/Users/hack/github/inbox-zero/apps/web/utils/outlook/watch.ts
/Users/hack/github/inbox-zero/apps/web/app/api/outlook/device-code/initiate/route.ts
/Users/hack/github/inbox-zero/apps/web/utils/outlook/msal-device-code.test.ts
/Users/hack/github/inbox-zero/apps/web/app/api/outlook/device-code/poll/route.ts
/Users/hack/github/inbox-zero/apps/web/app/api/outlook/calendar/auth-url/route.ts
/Users/hack/github/inbox-zero/apps/web/app/api/outlook/linking/auth-url/route.ts
/Users/hack/github/inbox-zero/apps/web/utils/outlook/batch.ts
/Users/hack/github/inbox-zero/apps/web/utils/outlook/folders.ts
/Users/hack/github/inbox-zero/apps/web/utils/outlook/subscription-history.ts
/Users/hack/github/inbox-zero/apps/web/app/api/outlook/calendar/device-code-connect/route.ts
/Users/hack/github/inbox-zero/apps/web/utils/outlook/calendar-client.ts
/Users/hack/github/inbox-zero/apps/web/utils/outlook/client.ts
/Users/hack/github/inbox-zero/apps/web/utils/outlook/msal-device-code.ts
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:01:40.979Z)**_

<tool-use data-tool-type="search" data-tool-name="Glob"><details>
<summary>Tool use: **Glob**</summary>
 pattern `**/utils/calendar/**/*.ts`
```
/Users/hack/github/inbox-zero/apps/web/utils/calendar/constants.ts
/Users/hack/github/inbox-zero/apps/web/utils/calendar/event-provider.ts
/Users/hack/github/inbox-zero/apps/web/utils/calendar/event-types.ts
/Users/hack/github/inbox-zero/apps/web/utils/calendar/handle-calendar-callback.ts
/Users/hack/github/inbox-zero/apps/web/utils/calendar/oauth-callback-helpers.ts
/Users/hack/github/inbox-zero/apps/web/utils/calendar/providers/google-availability.ts
/Users/hack/github/inbox-zero/apps/web/utils/calendar/providers/google-events.ts
/Users/hack/github/inbox-zero/apps/web/utils/calendar/providers/microsoft-availability.ts
/Users/hack/github/inbox-zero/apps/web/utils/calendar/timezone-helpers.ts
/Users/hack/github/inbox-zero/apps/web/utils/calendar/unified-availability.test.ts
/Users/hack/github/inbox-zero/apps/web/utils/calendar/unified-availability.ts
/Users/hack/github/inbox-zero/apps/web/utils/calendar/availability-types.ts
/Users/hack/github/inbox-zero/apps/web/utils/calendar/client.ts
/Users/hack/github/inbox-zero/apps/web/utils/calendar/providers/microsoft-events.ts
/Users/hack/github/inbox-zero/apps/web/utils/calendar/oauth-types.ts
/Users/hack/github/inbox-zero/apps/web/utils/calendar/providers/google.ts
/Users/hack/github/inbox-zero/apps/web/utils/calendar/providers/microsoft.ts
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:01:41.440Z)**_

<tool-use data-tool-type="shell" data-tool-name="Bash"><details>
<summary>Tool use: **Bash**</summary>

`find /Users/hack/github/inbox-zero -type f -name "*.ts" -o -name "*.tsx" | xargs grep -l "device.code\|DeviceCode\|MSAL\|device_code" | head -20`
```
/Users/hack/github/inbox-zero/apps/web/app/(app)/[emailAccountId]/calendars/ConnectCalendar.tsx
/Users/hack/github/inbox-zero/apps/web/app/api/user/email-accounts/route.ts
/Users/hack/github/inbox-zero/apps/web/app/api/outlook/calendar/device-code-connect/route.ts
/Users/hack/github/inbox-zero/apps/web/app/api/outlook/device-code/initiate/route.ts
/Users/hack/github/inbox-zero/apps/web/app/api/outlook/device-code/poll/route.ts
/Users/hack/github/inbox-zero/apps/web/app/(landing)/login/LoginForm.tsx
/Users/hack/github/inbox-zero/apps/web/app/(landing)/login/DeviceCodeLogin.tsx
/Users/hack/github/inbox-zero/apps/web/app/(landing)/login/device-code/page.tsx
/Users/hack/github/inbox-zero/apps/web/providers/EmailAccountProvider.tsx
/Users/hack/github/inbox-zero/apps/web/utils/calendar/providers/google.ts
/Users/hack/github/inbox-zero/apps/web/utils/calendar/oauth-types.ts
/Users/hack/github/inbox-zero/apps/web/utils/outlook/calendar-client.ts
/Users/hack/github/inbox-zero/apps/web/utils/outlook/client.ts
/Users/hack/github/inbox-zero/apps/web/utils/outlook/msal-device-code.ts
/Users/hack/github/inbox-zero/apps/web/utils/outlook/msal-device-code.test.ts
/Users/hack/github/inbox-zero/apps/web/.next/types/routes.d.ts
/Users/hack/github/inbox-zero/apps/web/.next/types/validator.ts
/Users/hack/github/inbox-zero/apps/web/.next/dev/types/routes.d.ts
/Users/hack/github/inbox-zero/apps/web/.next/dev/types/validator.ts
/Users/hack/github/inbox-zero/apps/web/scripts/test-device-code-api.ts
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:02:01.092Z)**_

Let me search for the scripts in the outlook-creds repository:

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:02:01.372Z)**_

<tool-use data-tool-type="shell" data-tool-name="Bash"><details>
<summary>Tool use: **Bash**</summary>

`ls -la /Users/hack/github/outlook-creds/ 2>/dev/null | head -20`
```
total 1496
drwxr-x---@   55 hack  staff    1760 Jan 21 20:47 .
drwxr-xr-x@ 1534 hack  staff   49088 Jan 23 11:31 ..
drwx------     5 hack  staff     160 Jan 23 18:08 .claude
-rw-r-----@    1 hack  staff  208896 Jan 21 15:25 .coverage
drwxr-xr-x     3 hack  staff      96 Jan  5 11:39 .cursor
-rw-r--r--     1 hack  staff     537 Jan 17 16:04 .cursorindexingignore
-rw-r--r--@    1 hack  staff   12292 Jan 23 07:44 .DS_Store
-rw-r-----@    1 hack  staff     528 Jan 21 16:00 .env
drwxr-x---@   21 hack  staff     672 Jan 23 18:27 .git
drwxr-x---@    4 hack  staff     128 Jan 12 13:54 .github
-rw-r-----@    1 hack  staff     604 Jan 12 13:54 .gitignore
drwxr-x---@    5 hack  staff     160 Jan 12 10:30 .mypy_cache
-rw-r-----@    1 hack  staff     775 Jan 12 13:54 .pre-commit-config.yaml
drwxr-x---@    6 hack  staff     192 Jan  5 23:31 .pytest_cache
drwxr-x---@    7 hack  staff     224 Jan 12 10:18 .ruff_cache
drwxr-x---@    6 hack  staff     192 Jan 12 13:54 .specstory
drwxr-x---@    9 hack  staff     288 Jan 21 16:52 .venv
-rw-r-----@    1 hack  staff     474 Jan 17 19:20 AGENTS.md
-rw-r-----@    1 hack  staff    7735 Jan 17 16:00 AUTO_REFRESH.md
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:02:14.395Z)**_

Now let me read the key files to understand the implementation:

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:02:14.669Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./apps/web/utils/outlook/msal-device-code.ts`
```
     1→/**
     2→ * MSAL Device Code Flow Authentication
     3→ *
     4→ * Provides device-code authentication for Microsoft accounts as an alternative
     5→ * to browser-based OAuth. Useful for CLI/headless environments.
     6→ *
     7→ * Key Features:
     8→ * - Uses MSAL Node.js library for device code flow
     9→ * - In-memory storage for pending flows (15-min expiration)
    10→ * - Integrates with existing token encryption system
    11→ * - Non-breaking: runs parallel to existing Better Auth OAuth
    12→ */
    13→
    14→import {
    15→  PublicClientApplication,
    16→  type DeviceCodeRequest,
    17→  type AuthenticationResult,
    18→  type AccountInfo,
    19→  LogLevel,
    20→  type INetworkModule,
    21→  type NetworkRequestOptions,
    22→  type NetworkResponse,
    23→} from "@azure/msal-node";
    24→import { env } from "@/env";
    25→import { createScopedLogger } from "@/utils/logger";
    26→
    27→/**
    28→ * Custom network module to handle fetch issues in Node.js 22+
    29→ * Uses fresh fetch calls with abort controller timeouts to avoid
    30→ * undici connection pool issues that cause "fetch failed" errors
    31→ */
    32→class CustomNetworkModule implements INetworkModule {
    33→  private readonly logger = createScopedLogger("msal-network");
    34→
    35→  async sendGetRequestAsync<T>(
    36→    url: string,
    37→    options?: NetworkRequestOptions,
    38→  ): Promise<NetworkResponse<T>> {
    39→    return this.sendRequest<T>(url, "GET", options);
    40→  }
    41→
    42→  async sendPostRequestAsync<T>(
    43→    url: string,
    44→    options?: NetworkRequestOptions,
    45→  ): Promise<NetworkResponse<T>> {
    46→    return this.sendRequest<T>(url, "POST", options);
    47→  }
    48→
    49→  private async sendRequest<T>(
    50→    url: string,
    51→    method: string,
    52→    options?: NetworkRequestOptions,
    53→  ): Promise<NetworkResponse<T>> {
    54→    const controller = new AbortController();
    55→    const timeoutId = setTimeout(() => controller.abort(), 30_000); // 30 second timeout
    56→
    57→    try {
    58→      const response = await fetch(url, {
    59→        method,
    60→        headers: options?.headers as Record<string, string>,
    61→        body: options?.body,
    62→        signal: controller.signal,
    63→        // Disable keep-alive to avoid connection pool issues
    64→        keepalive: false,
    65→      });
    66→
    67→      clearTimeout(timeoutId);
    68→
    69→      const headers: Record<string, string> = {};
    70→      response.headers.forEach((value, key) => {
    71→        headers[key] = value;
    72→      });
    73→
    74→      const body = (await response.json()) as T;
    75→
    76→      return {
    77→        headers,
    78→        body,
    79→        status: response.status,
    80→      };
    81→    } catch (error) {
    82→      clearTimeout(timeoutId);
    83→      this.logger.error("Network request failed", {
    84→        url,
    85→        method,
    86→        error: error instanceof Error ? error.message : String(error),
    87→      });
    88→      throw error;
    89→    }
    90→  }
    91→}
    92→
    93→// Use .default scope for device code flow with Microsoft Office client ID
    94→// This requests all pre-authorized permissions without requiring explicit consent
    95→const MSAL_DEVICE_CODE_SCOPES = ["https://graph.microsoft.com/.default"];
    96→
    97→// DeviceCodeResponse type matches what MSAL passes to the deviceCodeCallback
    98→// Defined locally to avoid importing from @azure/msal-common which is a transitive dep
    99→interface DeviceCodeResponse {
   100→  deviceCode: string;
   101→  userCode: string;
   102→  verificationUri: string;
   103→  expiresIn: number; // seconds until expiration
   104→  interval: number; // polling interval in seconds
   105→  message: string;
   106→}
   107→
   108→const logger = createScopedLogger("msal-device-code");
   109→
   110→// Default Microsoft Office client ID - works without app registration
   111→const MICROSOFT_OFFICE_CLIENT_ID = "d3590ed6-52b3-4102-aeff-aad2292ab01c";
   112→
   113→// Singleton MSAL application instance
   114→let msalApp: PublicClientApplication | null = null;
   115→
   116→function getMSALApp(): PublicClientApplication {
   117→  if (!msalApp) {
   118→    const clientId =
   119→      env.MSAL_CLIENT_ID ||
   120→      env.MICROSOFT_CLIENT_ID ||
   121→      MICROSOFT_OFFICE_CLIENT_ID;
   122→    const tenantId = env.MSAL_TENANT_ID || env.MICROSOFT_TENANT_ID || "common";
   123→    const debugEnabled = env.MSAL_DEBUG === "true";
   124→
   125→    msalApp = new PublicClientApplication({
   126→      auth: {
   127→        clientId,
   128→        authority: `https://login.microsoftonline.com/${tenantId}`,
   129→      },
   130→      system: {
   131→        loggerOptions: {
   132→          loggerCallback: (
   133→            level: LogLevel,
   134→            message: string,
   135→            containsPii: boolean,
   136→          ) => {
   137→            if (containsPii) return; // Don't log PII
   138→            if (debugEnabled || level === LogLevel.Error) {
   139→              logger.info(`MSAL [${LogLevel[level]}]: ${message}`);
   140→            }
   141→          },
   142→          piiLoggingEnabled: false,
   143→          logLevel: debugEnabled ? LogLevel.Verbose : LogLevel.Error,
   144→        },
   145→        // Use custom network module to avoid Node.js 22+ undici connection pool issues
   146→        networkClient: new CustomNetworkModule(),
   147→      },
   148→    });
   149→  }
   150→  return msalApp;
   151→}
   152→
   153→// Feature flag - defaults to disabled until explicitly enabled
   154→export function isMSALDeviceCodeEnabled(): boolean {
   155→  return env.MSAL_ENABLED === "true";
   156→}
   157→
   158→// Active device code flows (for polling)
   159→interface ActiveFlow {
   160→  deviceCode: string;
   161→  userCode: string;
   162→  verificationUri: string;
   163→  expiresAt: Date;
   164→  message: string;
   165→  promise: Promise<AuthenticationResult | null>;
   166→  resolve: (result: AuthenticationResult | null) => void;
   167→  reject: (error: Error) => void;
   168→}
   169→
   170→// Use globalThis to persist flows across Next.js hot reloads in development
   171→const globalForFlows = globalThis as unknown as {
   172→  msalActiveFlows: Map<string, ActiveFlow> | undefined;
   173→};
   174→
   175→const activeFlows =
   176→  globalForFlows.msalActiveFlows ?? new Map<string, ActiveFlow>();
   177→
   178→if (process.env.NODE_ENV !== "production") {
   179→  globalForFlows.msalActiveFlows = activeFlows;
   180→}
   181→
   182→// Cleanup expired flows periodically
   183→function cleanupExpiredFlows(): void {
   184→  const now = new Date();
   185→  for (const [sessionId, flow] of activeFlows.entries()) {
   186→    if (now > flow.expiresAt) {
   187→      activeFlows.delete(sessionId);
   188→      logger.info("Cleaned up expired device code flow", { sessionId });
   189→    }
   190→  }
   191→}
   192→
   193→// Run cleanup every 5 minutes
   194→setInterval(cleanupExpiredFlows, 5 * 60 * 1000);
   195→
   196→export interface DeviceCodeInitResponse {
   197→  sessionId: string;
   198→  userCode: string;
   199→  verificationUri: string;
   200→  expiresAt: Date;
   201→  message: string;
   202→}
   203→
   204→/**
   205→ * Initiate device code flow
   206→ * Returns the device code info for display to user
   207→ */
   208→export async function initiateDeviceCodeFlow(
   209→  sessionId: string,
   210→): Promise<DeviceCodeInitResponse> {
   211→  if (!isMSALDeviceCodeEnabled()) {
   212→    throw new Error("MSAL device code flow is not enabled");
   213→  }
   214→
   215→  const app = getMSALApp();
   216→
   217→  // Clean up expired flows
   218→  cleanupExpiredFlows();
   219→
   220→  // Check if session already exists
   221→  if (activeFlows.has(sessionId)) {
   222→    throw new Error("Session already exists");
   223→  }
   224→
   225→  let flowResolve: (result: AuthenticationResult | null) => void;
   226→  let flowReject: (error: Error) => void;
   227→  let capturedDeviceCode: DeviceCodeResponse | null = null;
   228→
   229→  const flowPromise = new Promise<AuthenticationResult | null>(
   230→    (resolve, reject) => {
   231→      flowResolve = resolve;
   232→      flowReject = reject;
   233→    },
   234→  );
   235→
   236→  const deviceCodeRequest: DeviceCodeRequest = {
   237→    scopes: MSAL_DEVICE_CODE_SCOPES,
   238→    deviceCodeCallback: (response: DeviceCodeResponse) => {
   239→      capturedDeviceCode = response;
   240→
   241→      // Calculate expiration time from expiresIn (seconds)
   242→      const expiresAt = new Date(Date.now() + response.expiresIn * 1000);
   243→
   244→      // Store flow info for polling
   245→      activeFlows.set(sessionId, {
   246→        deviceCode: response.deviceCode,
   247→        userCode: response.userCode,
   248→        verificationUri: response.verificationUri,
   249→        expiresAt,
   250→        message: response.message,
   251→        promise: flowPromise,
   252→        resolve: flowResolve!,
   253→        reject: flowReject!,
   254→      });
   255→
   256→      logger.info("Device code flow initiated", {
   257→        sessionId,
   258→        userCode: response.userCode,
   259→        expiresAt: expiresAt.toISOString(),
   260→      });
   261→    },
   262→    timeout: 900, // 15 minutes
   263→  };
   264→
   265→  // Start the flow (don't await - it blocks until user completes)
   266→  const authPromise = app.acquireTokenByDeviceCode(deviceCodeRequest);
   267→
   268→  // Wait for the callback to be called (provides device code)
   269→  await new Promise<void>((resolve, reject) => {
   270→    const checkInterval = setInterval(() => {
   271→      if (capturedDeviceCode) {
   272→        clearInterval(checkInterval);
   273→        resolve();
   274→      }
   275→    }, 100);
   276→
   277→    // Timeout after 10 seconds if callback not called
   278→    setTimeout(() => {
   279→      clearInterval(checkInterval);
   280→      if (!capturedDeviceCode) {
   281→        reject(new Error("Device code callback timeout"));
   282→      }
   283→    }, 10_000);
   284→  });
   285→
   286→  const flow = activeFlows.get(sessionId);
   287→  // Cast is needed because TypeScript doesn't track assignment in async callbacks
   288→  const deviceCodeInfo = capturedDeviceCode as DeviceCodeResponse | null;
   289→  if (!flow || !deviceCodeInfo) {
   290→    throw new Error("Failed to initiate device code flow");
   291→  }
   292→
   293→  // Wire up the auth promise to resolve/reject the flow
   294→  authPromise
   295→    .then((result: AuthenticationResult | null) => {
   296→      logger.info("Device code flow completed", { sessionId });
   297→      flow.resolve(result);
   298→    })
   299→    .catch((error: Error) => {
   300→      // Log detailed error info for debugging network issues
   301→      const errorDetails = {
   302→        sessionId,
   303→        error: error.message,
   304→        name: error.name,
   305→        stack: error.stack?.split("\n").slice(0, 5).join("\n"),
   306→        cause: error.cause ? String(error.cause) : undefined,
   307→      };
   308→      logger.error("Device code flow failed", errorDetails);
   309→      flow.reject(error);
   310→    });
   311→
   312→  // Calculate expiration time from expiresIn (seconds)
   313→  const expiresAt = new Date(Date.now() + deviceCodeInfo.expiresIn * 1000);
   314→
   315→  return {
   316→    sessionId,
   317→    userCode: deviceCodeInfo.userCode,
   318→    verificationUri: deviceCodeInfo.verificationUri,
   319→    expiresAt,
   320→    message: deviceCodeInfo.message,
   321→  };
   322→}
   323→
   324→export interface PollResult {
   325→  status: "pending" | "complete" | "expired" | "error";
   326→  error?: string;
   327→  result?: {
   328→    accessToken: string;
   329→    expiresAt: Date;
   330→    scopes: string[];
   331→    account: AccountInfo | null;
   332→  };
   333→}
   334→
   335→/**
   336→ * Poll for device code completion
   337→ */
   338→export async function pollDeviceCodeFlow(
   339→  sessionId: string,
   340→): Promise<PollResult> {
   341→  logger.info("Poll called", {
   342→    sessionId,
   343→    activeFlowCount: activeFlows.size,
   344→    hasFlow: activeFlows.has(sessionId),
   345→  });
   346→
   347→  const flow = activeFlows.get(sessionId);
   348→
   349→  if (!flow) {
   350→    logger.info("Flow not found in activeFlows", { sessionId });
   351→    return { status: "expired" };
   352→  }
   353→
   354→  if (new Date() > flow.expiresAt) {
   355→    logger.info("Flow expired", { sessionId, expiresAt: flow.expiresAt });
   356→    activeFlows.delete(sessionId);
   357→    return { status: "expired" };
   358→  }
   359→
   360→  // Check if promise is resolved (non-blocking check)
   361→  const raceResult = await Promise.race([
   362→    flow.promise
   363→      .then((result) => ({ done: true as const, result, error: null }))
   364→      .catch((error) => ({ done: true as const, result: null, error })),
   365→    new Promise<{ done: false }>((resolve) =>
   366→      setTimeout(() => resolve({ done: false }), 100),
   367→    ),
   368→  ]);
   369→
   370→  if (!raceResult.done) {
   371→    return { status: "pending" };
   372→  }
   373→
   374→  // Flow completed - clean up
   375→  activeFlows.delete(sessionId);
   376→
   377→  if (raceResult.error) {
   378→    const errorMessage =
   379→      raceResult.error instanceof Error
   380→        ? raceResult.error.message
   381→        : String(raceResult.error);
   382→
   383→    // Check for user cancellation
   384→    if (errorMessage.includes("authorization_pending")) {
   385→      return { status: "pending" };
   386→    }
   387→
   388→    logger.error("Device code flow error", { sessionId, error: errorMessage });
   389→    return { status: "error", error: errorMessage };
   390→  }
   391→
   392→  if (!raceResult.result) {
   393→    return { status: "error", error: "No authentication result" };
   394→  }
   395→
   396→  return {
   397→    status: "complete",
   398→    result: {
   399→      accessToken: raceResult.result.accessToken,
   400→      expiresAt:
   401→        raceResult.result.expiresOn || new Date(Date.now() + 3_600_000),
   402→      scopes: raceResult.result.scopes,
   403→      account: raceResult.result.account,
   404→    },
   405→  };
   406→}
   407→
   408→/**
   409→ * Cancel an active device code flow
   410→ */
   411→export function cancelDeviceCodeFlow(sessionId: string): boolean {
   412→  const flow = activeFlows.get(sessionId);
   413→  if (flow) {
   414→    flow.reject(new Error("Flow cancelled by user"));
   415→    activeFlows.delete(sessionId);
   416→    logger.info("Device code flow cancelled", { sessionId });
   417→    return true;
   418→  }
   419→  return false;
   420→}
   421→
   422→/**
   423→ * Get count of active flows (for monitoring)
   424→ */
   425→export function getActiveFlowCount(): number {
   426→  cleanupExpiredFlows();
   427→  return activeFlows.size;
   428→}
   429→
   430→/**
   431→ * Acquire token silently from MSAL cache
   432→ * Used for device-code authenticated accounts to get fresh tokens for calendar operations
   433→ *
   434→ * @param providerAccountId - The MSAL account's localAccountId (stored as providerAccountId in DB)
   435→ * @param scopes - Optional scopes to request (defaults to .default which includes all permissions)
   436→ * @returns Token info or null if account not in cache
   437→ */
   438→export async function acquireMSALTokenSilent(
   439→  providerAccountId: string,
   440→  scopes: string[] = MSAL_DEVICE_CODE_SCOPES,
   441→): Promise<{
   442→  accessToken: string;
   443→  expiresAt: Date;
   444→  account: AccountInfo;
   445→} | null> {
   446→  if (!isMSALDeviceCodeEnabled()) {
   447→    logger.warn("MSAL device code flow is not enabled");
   448→    return null;
   449→  }
   450→
   451→  const app = getMSALApp();
   452→  const tokenCache = app.getTokenCache();
   453→
   454→  try {
   455→    // Get all accounts from MSAL cache
   456→    const accounts = await tokenCache.getAllAccounts();
   457→
   458→    if (accounts.length === 0) {
   459→      logger.info("No accounts found in MSAL cache");
   460→      return null;
   461→    }
   462→
   463→    // Find the account matching the providerAccountId
   464→    const account = accounts.find(
   465→      (acc: AccountInfo) => acc.localAccountId === providerAccountId,
   466→    );
   467→
   468→    if (!account) {
   469→      logger.info("Account not found in MSAL cache", {
   470→        providerAccountId,
   471→        cachedAccountIds: accounts.map((a: AccountInfo) => a.localAccountId),
   472→      });
   473→      return null;
   474→    }
   475→
   476→    // Acquire token silently using cached credentials
   477→    const result = await app.acquireTokenSilent({
   478→      account,
   479→      scopes,
   480→    });
   481→
   482→    if (!result) {
   483→      logger.warn("acquireTokenSilent returned null", { providerAccountId });
   484→      return null;
   485→    }
   486→
   487→    logger.info("Successfully acquired token silently", {
   488→      providerAccountId,
   489→      expiresOn: result.expiresOn?.toISOString(),
   490→    });
   491→
   492→    return {
   493→      accessToken: result.accessToken,
   494→      expiresAt: result.expiresOn || new Date(Date.now() + 3_600_000), // Default 1 hour
   495→      account,
   496→    };
   497→  } catch (error) {
   498→    logger.error("Failed to acquire token silently", {
   499→      providerAccountId,
   500→      error: error instanceof Error ? error.message : String(error),
   501→    });
   502→    return null;
   503→  }
   504→}
   505→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:02:15.034Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./apps/web/app/api/outlook/calendar/device-code-connect/route.ts`
```
     1→import { NextResponse } from "next/server";
     2→import prisma from "@/utils/prisma";
     3→import { withEmailAccount } from "@/utils/middleware";
     4→import {
     5→  acquireMSALTokenSilent,
     6→  isMSALDeviceCodeEnabled,
     7→} from "@/utils/outlook/msal-device-code";
     8→import {
     9→  checkExistingConnection,
    10→  createCalendarConnection,
    11→} from "@/utils/calendar/oauth-callback-helpers";
    12→import { createMicrosoftCalendarProvider } from "@/utils/calendar/providers/microsoft";
    13→
    14→export type DeviceCodeCalendarConnectResponse =
    15→  | { success: true; connectionId: string }
    16→  | { success: false; error: string };
    17→
    18→export const POST = withEmailAccount(
    19→  "outlook/calendar/device-code-connect",
    20→  async (request) => {
    21→    const { emailAccountId } = request.auth;
    22→    const logger = request.logger;
    23→
    24→    // Step 1: Check if MSAL is enabled
    25→    if (!isMSALDeviceCodeEnabled()) {
    26→      logger.warn("MSAL device code flow is not enabled");
    27→      return NextResponse.json(
    28→        { success: false, error: "Device code flow is not enabled" },
    29→        { status: 400 },
    30→      );
    31→    }
    32→
    33→    // Step 2: Get email account with Account relation (including tokens)
    34→    const emailAccount = await prisma.emailAccount.findUnique({
    35→      where: { id: emailAccountId },
    36→      select: {
    37→        id: true,
    38→        email: true,
    39→        account: {
    40→          select: {
    41→            provider: true,
    42→            providerAccountId: true,
    43→            refresh_token: true,
    44→            access_token: true,
    45→            expires_at: true,
    46→          },
    47→        },
    48→      },
    49→    });
    50→
    51→    if (!emailAccount) {
    52→      logger.warn("Email account not found", { emailAccountId });
    53→      return NextResponse.json(
    54→        { success: false, error: "Email account not found" },
    55→        { status: 404 },
    56→      );
    57→    }
    58→
    59→    // Step 3: Verify it's a device-code account
    60→    const isDeviceCodeAuth =
    61→      emailAccount.account?.provider === "microsoft" &&
    62→      !emailAccount.account?.refresh_token;
    63→
    64→    if (!isDeviceCodeAuth) {
    65→      logger.warn("Account is not device-code authenticated", {
    66→        emailAccountId,
    67→        provider: emailAccount.account?.provider,
    68→        hasRefreshToken: !!emailAccount.account?.refresh_token,
    69→      });
    70→      return NextResponse.json(
    71→        {
    72→          success: false,
    73→          error: "This endpoint is only for device-code authenticated accounts",
    74→        },
    75→        { status: 400 },
    76→      );
    77→    }
    78→
    79→    const providerAccountId = emailAccount.account?.providerAccountId;
    80→    if (!providerAccountId) {
    81→      logger.error("Missing providerAccountId for device-code account", {
    82→        emailAccountId,
    83→      });
    84→      return NextResponse.json(
    85→        { success: false, error: "Account configuration error" },
    86→        { status: 500 },
    87→      );
    88→    }
    89→
    90→    // Step 4: Get access token - try stored token first, then MSAL
    91→    let accessToken: string;
    92→    let tokenExpiresAt: Date;
    93→
    94→    const storedToken = emailAccount.account?.access_token;
    95→    const storedExpiry = emailAccount.account?.expires_at;
    96→    const tokenStillValid =
    97→      storedToken &&
    98→      storedExpiry &&
    99→      storedExpiry.getTime() > Date.now() + 5 * 60 * 1000; // 5 min buffer
   100→
   101→    if (tokenStillValid && storedToken) {
   102→      // Use stored token if still valid
   103→      logger.info("Using stored access token for calendar setup", {
   104→        emailAccountId,
   105→        expiresAt: storedExpiry?.toISOString(),
   106→      });
   107→      // Need to decrypt the token
   108→      const { decryptToken } = await import("@/utils/encryption");
   109→      const decrypted = decryptToken(storedToken);
   110→      if (!decrypted) {
   111→        logger.error("Failed to decrypt stored access token", { emailAccountId });
   112→        return NextResponse.json(
   113→          { success: false, error: "Token decryption failed" },
   114→          { status: 500 },
   115→        );
   116→      }
   117→      accessToken = decrypted;
   118→      tokenExpiresAt = storedExpiry!;
   119→    } else {
   120→      // Try MSAL for token refresh
   121→      const msalResult = await acquireMSALTokenSilent(providerAccountId);
   122→
   123→      if (!msalResult) {
   124→        logger.warn("Failed to acquire MSAL token silently", {
   125→          emailAccountId,
   126→          providerAccountId,
   127→        });
   128→        return NextResponse.json(
   129→          {
   130→            success: false,
   131→            error:
   132→              "Authentication expired. Please log in again using device code flow.",
   133→          },
   134→          { status: 401 },
   135→        );
   136→      }
   137→
   138→      accessToken = msalResult.accessToken;
   139→      tokenExpiresAt = msalResult.expiresAt;
   140→    }
   141→
   142→    // Step 5: Fetch user email from Graph API to verify token works
   143→    let microsoftEmail: string;
   144→    try {
   145→      const profileResponse = await fetch(
   146→        "https://graph.microsoft.com/v1.0/me",
   147→        {
   148→          headers: {
   149→            Authorization: `Bearer ${accessToken}`,
   150→          },
   151→        },
   152→      );
   153→
   154→      if (!profileResponse.ok) {
   155→        throw new Error(`Graph API error: ${profileResponse.status}`);
   156→      }
   157→
   158→      const profile = await profileResponse.json();
   159→      microsoftEmail = profile.mail || profile.userPrincipalName;
   160→
   161→      if (!microsoftEmail) {
   162→        throw new Error("Profile missing email");
   163→      }
   164→    } catch (error) {
   165→      logger.error("Failed to fetch user profile from Graph API", {
   166→        error,
   167→        emailAccountId,
   168→      });
   169→      return NextResponse.json(
   170→        { success: false, error: "Failed to verify Microsoft account" },
   171→        { status: 500 },
   172→      );
   173→    }
   174→
   175→    // Step 6: Check for existing connection
   176→    const existingConnection = await checkExistingConnection(
   177→      emailAccountId,
   178→      "microsoft",
   179→      microsoftEmail,
   180→    );
   181→
   182→    if (existingConnection) {
   183→      logger.info("Calendar connection already exists", {
   184→        emailAccountId,
   185→        email: microsoftEmail,
   186→      });
   187→      return NextResponse.json({
   188→        success: true,
   189→        connectionId: existingConnection.id,
   190→      });
   191→    }
   192→
   193→    // Step 7: Create CalendarConnection with refreshToken = null (device-code flow)
   194→    const connection = await createCalendarConnection({
   195→      provider: "microsoft",
   196→      email: microsoftEmail,
   197→      emailAccountId,
   198→      accessToken,
   199→      refreshToken: "", // Empty string since device-code doesn't provide refresh tokens
   200→      expiresAt: tokenExpiresAt,
   201→    });
   202→
   203→    logger.info("Created calendar connection for device-code account", {
   204→      emailAccountId,
   205→      connectionId: connection.id,
   206→      email: microsoftEmail,
   207→    });
   208→
   209→    // Step 8: Sync calendars
   210→    try {
   211→      const microsoftProvider = createMicrosoftCalendarProvider(logger);
   212→      await microsoftProvider.syncCalendars(
   213→        connection.id,
   214→        accessToken,
   215→        "", // No refresh token for device-code
   216→        emailAccountId,
   217→        tokenExpiresAt,
   218→        providerAccountId, // Pass for MSAL token refresh
   219→      );
   220→
   221→      logger.info("Synced calendars for device-code account", {
   222→        emailAccountId,
   223→        connectionId: connection.id,
   224→      });
   225→    } catch (error) {
   226→      logger.error("Failed to sync calendars", {
   227→        error,
   228→        emailAccountId,
   229→        connectionId: connection.id,
   230→      });
   231→      // Don't fail the entire operation - connection was created
   232→      // Sync can be retried later
   233→    }
   234→
   235→    return NextResponse.json({
   236→      success: true,
   237→      connectionId: connection.id,
   238→    });
   239→  },
   240→);
   241→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:02:15.246Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./apps/web/utils/outlook/client.ts`
```
     1→import { Client } from "@microsoft/microsoft-graph-client";
     2→import type { User } from "@microsoft/microsoft-graph-types";
     3→import { saveTokens } from "@/utils/auth";
     4→import { env } from "@/env";
     5→import type { Logger } from "@/utils/logger";
     6→import { SCOPES } from "@/utils/outlook/scopes";
     7→import { SafeError } from "@/utils/error";
     8→import { acquireMSALTokenSilent } from "@/utils/outlook/msal-device-code";
     9→import { encryptToken } from "@/utils/encryption";
    10→import prisma from "@/utils/prisma";
    11→
    12→// Add buffer time to prevent token expiry during long-running operations
    13→const TOKEN_REFRESH_BUFFER_MS = 10 * 60 * 1000; // 10 minutes
    14→
    15→// Wrapper class to hold both the Microsoft Graph client and its access token
    16→export class OutlookClient {
    17→  private readonly client: Client;
    18→  private readonly accessToken: string;
    19→  private readonly logger: Logger;
    20→  private folderIdCache: Record<string, string> | null = null;
    21→
    22→  constructor(accessToken: string, logger: Logger) {
    23→    this.accessToken = accessToken;
    24→    this.logger = logger;
    25→    this.client = Client.init({
    26→      authProvider: (done) => {
    27→        done(null, this.accessToken);
    28→      },
    29→      defaultVersion: "v1.0",
    30→      // Use immutable IDs to ensure message IDs remain stable
    31→      // https://learn.microsoft.com/en-us/graph/outlook-immutable-id
    32→      fetchOptions: {
    33→        headers: {
    34→          Prefer: 'IdType="ImmutableId"',
    35→        },
    36→      },
    37→    });
    38→  }
    39→
    40→  getClient(): Client {
    41→    return this.client;
    42→  }
    43→
    44→  getAccessToken(): string {
    45→    return this.accessToken;
    46→  }
    47→
    48→  getFolderIdCache(): Record<string, string> | null {
    49→    return this.folderIdCache;
    50→  }
    51→
    52→  setFolderIdCache(cache: Record<string, string>): void {
    53→    this.folderIdCache = cache;
    54→  }
    55→
    56→  // Helper methods for common operations
    57→  async getUserProfile(): Promise<User> {
    58→    return await this.client
    59→      .api("/me")
    60→      .select("id,displayName,mail,userPrincipalName")
    61→      .get();
    62→  }
    63→
    64→  async getUserPhoto(): Promise<string | null> {
    65→    try {
    66→      const photoResponse = await this.client.api("/me/photo/$value").get();
    67→
    68→      if (photoResponse) {
    69→        const arrayBuffer = await photoResponse.arrayBuffer();
    70→        const base64 = Buffer.from(arrayBuffer).toString("base64");
    71→        return `data:image/jpeg;base64,${base64}`;
    72→      }
    73→      return null;
    74→    } catch {
    75→      this.logger.warn("Error getting user photo");
    76→      return null;
    77→    }
    78→  }
    79→}
    80→
    81→// Helper to create OutlookClient instance
    82→export const createOutlookClient = (accessToken: string, logger: Logger) => {
    83→  if (!accessToken) throw new SafeError("No access token provided");
    84→  return new OutlookClient(accessToken, logger);
    85→};
    86→
    87→// Similar to Gmail's getGmailClientWithRefresh
    88→export const getOutlookClientWithRefresh = async ({
    89→  accessToken,
    90→  refreshToken,
    91→  expiresAt,
    92→  emailAccountId,
    93→  providerAccountId,
    94→  logger,
    95→}: {
    96→  accessToken?: string | null;
    97→  refreshToken: string | null;
    98→  expiresAt: number | null;
    99→  emailAccountId: string;
   100→  providerAccountId?: string | null;
   101→  logger: Logger;
   102→}): Promise<OutlookClient> => {
   103→  // Check if token is still valid
   104→  const expiryDate = expiresAt ? expiresAt : null;
   105→  if (
   106→    accessToken &&
   107→    expiryDate &&
   108→    expiryDate > Date.now() + TOKEN_REFRESH_BUFFER_MS
   109→  ) {
   110→    return createOutlookClient(accessToken, logger);
   111→  }
   112→
   113→  // For device-code accounts (no refresh token), use MSAL silent acquisition
   114→  if (!refreshToken && providerAccountId) {
   115→    logger.info("Using MSAL silent acquisition for email token refresh", {
   116→      emailAccountId,
   117→      providerAccountId,
   118→    });
   119→
   120→    const msalResult = await acquireMSALTokenSilent(providerAccountId);
   121→
   122→    if (!msalResult) {
   123→      throw new SafeError(
   124→        "Authentication expired. Please log in again using device code flow.",
   125→      );
   126→    }
   127→
   128→    // Update the account with the fresh token
   129→    await prisma.account.updateMany({
   130→      where: { providerAccountId },
   131→      data: {
   132→        access_token: encryptToken(msalResult.accessToken),
   133→        expires_at: msalResult.expiresAt,
   134→      },
   135→    });
   136→
   137→    logger.info("Updated account with MSAL token", {
   138→      emailAccountId,
   139→      providerAccountId,
   140→    });
   141→
   142→    return createOutlookClient(msalResult.accessToken, logger);
   143→  }
   144→
   145→  // Standard OAuth flow - requires refresh token
   146→  if (!refreshToken) {
   147→    logger.error("No refresh token", { emailAccountId });
   148→    throw new SafeError("No refresh token");
   149→  }
   150→
   151→  // Refresh token
   152→  try {
   153→    if (!env.MICROSOFT_CLIENT_ID || !env.MICROSOFT_CLIENT_SECRET) {
   154→      throw new Error("Microsoft login not enabled - missing credentials");
   155→    }
   156→
   157→    const response = await fetch(
   158→      `https://login.microsoftonline.com/${env.MICROSOFT_TENANT_ID}/oauth2/v2.0/token`,
   159→      {
   160→        method: "POST",
   161→        headers: {
   162→          "Content-Type": "application/x-www-form-urlencoded",
   163→        },
   164→        body: new URLSearchParams({
   165→          client_id: env.MICROSOFT_CLIENT_ID,
   166→          client_secret: env.MICROSOFT_CLIENT_SECRET,
   167→          refresh_token: refreshToken,
   168→          grant_type: "refresh_token",
   169→        }),
   170→      },
   171→    );
   172→
   173→    const tokens = await response.json();
   174→
   175→    if (!response.ok) {
   176→      const errorMessage =
   177→        tokens.error_description || "Failed to refresh token";
   178→
   179→      // AADSTS7000215 = Invalid client secret
   180→      // Happens when Azure AD client secret rotates or refresh token expires
   181→      // Background processes (watch-manager) will catch and log this as a warning
   182→      // User-facing flows will show an error prompting reconnection
   183→      if (errorMessage.includes("AADSTS7000215")) {
   184→        logger.warn(
   185→          "Microsoft refresh token failed - user may need to reconnect",
   186→          {
   187→            emailAccountId,
   188→          },
   189→        );
   190→      }
   191→
   192→      // Microsoft identity platform errors that require user re-authentication:
   193→      // AADSTS70000 = Scopes unauthorized or expired
   194→      // AADSTS70008 = Refresh token expired due to inactivity
   195→      // AADSTS70011 = Invalid scope
   196→      // AADSTS700082 = Refresh token expired
   197→      // AADSTS50173 = Invalid grant (refresh token revoked)
   198→      // AADSTS65001 = User hasn't consented to permissions
   199→      // AADSTS500011 = Resource principal not found (scope issue)
   200→      // AADSTS54005 = Authorization code already redeemed
   201→      // AADSTS50076 = MFA required (Conditional Access policy)
   202→      // AADSTS50079 = MFA registration required
   203→      // AADSTS50158 = External security challenge not satisfied
   204→      // invalid_grant = General token refresh failure
   205→      const requiresReauth =
   206→        errorMessage.includes("AADSTS70000") ||
   207→        errorMessage.includes("AADSTS70008") ||
   208→        errorMessage.includes("AADSTS70011") ||
   209→        errorMessage.includes("AADSTS700082") ||
   210→        errorMessage.includes("AADSTS50173") ||
   211→        errorMessage.includes("AADSTS65001") ||
   212→        errorMessage.includes("AADSTS500011") ||
   213→        errorMessage.includes("AADSTS54005") ||
   214→        errorMessage.includes("AADSTS50076") ||
   215→        errorMessage.includes("AADSTS50079") ||
   216→        errorMessage.includes("AADSTS50158") ||
   217→        errorMessage.includes("invalid_grant");
   218→
   219→      if (requiresReauth) {
   220→        logger.warn(
   221→          "Microsoft authorization expired - user needs to reconnect",
   222→          {
   223→            emailAccountId,
   224→            errorMessage,
   225→          },
   226→        );
   227→        throw new SafeError(
   228→          "Your Microsoft authorization has expired. Please sign out and log in again to reconnect your account.",
   229→        );
   230→      }
   231→
   232→      throw new Error(errorMessage);
   233→    }
   234→
   235→    // Save new tokens
   236→    await saveTokens({
   237→      tokens: {
   238→        access_token: tokens.access_token,
   239→        expires_at: Math.floor(Date.now() / 1000 + tokens.expires_in),
   240→      },
   241→      accountRefreshToken: refreshToken,
   242→      emailAccountId,
   243→      provider: "microsoft",
   244→    });
   245→
   246→    return createOutlookClient(tokens.access_token, logger);
   247→  } catch (error) {
   248→    const isInvalidGrantError =
   249→      error instanceof Error &&
   250→      (error.message.includes("invalid_grant") ||
   251→        error.message.includes("AADSTS50173"));
   252→
   253→    if (isInvalidGrantError) {
   254→      logger.warn("Error refreshing Outlook access token", { error });
   255→    }
   256→
   257→    throw error;
   258→  }
   259→};
   260→
   261→export const getAccessTokenFromClient = (client: OutlookClient): string => {
   262→  return client.getAccessToken();
   263→};
   264→
   265→// Helper function to get the OAuth2 URL for linking accounts
   266→export function getLinkingOAuth2Url() {
   267→  if (!env.MICROSOFT_CLIENT_ID) {
   268→    throw new Error("Microsoft login not enabled - missing client ID");
   269→  }
   270→
   271→  const baseUrl = `https://login.microsoftonline.com/${env.MICROSOFT_TENANT_ID}/oauth2/v2.0/authorize`;
   272→  const params = new URLSearchParams({
   273→    client_id: env.MICROSOFT_CLIENT_ID,
   274→    response_type: "code",
   275→    redirect_uri: `${env.NEXT_PUBLIC_BASE_URL}/api/outlook/linking/callback`,
   276→    scope: SCOPES.join(" "),
   277→    prompt: "select_account",
   278→  });
   279→
   280→  return `${baseUrl}?${params.toString()}`;
   281→}
   282→
   283→// Helper types for common Microsoft Graph operations
   284→export type { Client as GraphClient };
   285→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:02:15.505Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./apps/web/utils/outlook/calendar-client.ts`
```
     1→import { env } from "@/env";
     2→import type { Logger } from "@/utils/logger";
     3→import { CALENDAR_SCOPES } from "@/utils/outlook/scopes";
     4→import { SafeError } from "@/utils/error";
     5→import prisma from "@/utils/prisma";
     6→import {
     7→  Client,
     8→  type AuthenticationProvider,
     9→} from "@microsoft/microsoft-graph-client";
    10→import { acquireMSALTokenSilent } from "@/utils/outlook/msal-device-code";
    11→
    12→class CalendarAuthProvider implements AuthenticationProvider {
    13→  private readonly accessToken: string;
    14→
    15→  constructor(accessToken: string) {
    16→    this.accessToken = accessToken;
    17→  }
    18→
    19→  async getAccessToken(): Promise<string> {
    20→    return this.accessToken;
    21→  }
    22→}
    23→
    24→export function getCalendarOAuth2Url(state: string): string {
    25→  if (!env.MICROSOFT_CLIENT_ID) {
    26→    throw new Error("Microsoft login not enabled - missing client ID");
    27→  }
    28→
    29→  const baseUrl = `https://login.microsoftonline.com/${env.MICROSOFT_TENANT_ID}/oauth2/v2.0/authorize`;
    30→  const params = new URLSearchParams({
    31→    client_id: env.MICROSOFT_CLIENT_ID,
    32→    response_type: "code",
    33→    redirect_uri: `${env.NEXT_PUBLIC_BASE_URL}/api/outlook/calendar/callback`,
    34→    scope: CALENDAR_SCOPES.join(" "),
    35→    state,
    36→  });
    37→
    38→  return `${baseUrl}?${params.toString()}`;
    39→}
    40→
    41→export const getCalendarClientWithRefresh = async ({
    42→  accessToken,
    43→  refreshToken,
    44→  expiresAt,
    45→  emailAccountId,
    46→  providerAccountId,
    47→  logger,
    48→}: {
    49→  accessToken?: string | null;
    50→  refreshToken: string | null;
    51→  expiresAt: number | null;
    52→  emailAccountId: string;
    53→  providerAccountId?: string | null;
    54→  logger: Logger;
    55→}): Promise<Client> => {
    56→  // Check if token is still valid
    57→  if (expiresAt && expiresAt > Date.now() && accessToken) {
    58→    const authProvider = new CalendarAuthProvider(accessToken);
    59→    return Client.initWithMiddleware({ authProvider });
    60→  }
    61→
    62→  // For device-code accounts (no refresh token), use MSAL silent acquisition
    63→  if (!refreshToken && providerAccountId) {
    64→    logger.info("Using MSAL silent acquisition for calendar token refresh", {
    65→      emailAccountId,
    66→      providerAccountId,
    67→    });
    68→
    69→    const msalResult = await acquireMSALTokenSilent(providerAccountId);
    70→
    71→    if (!msalResult) {
    72→      throw new SafeError(
    73→        "Authentication expired. Please log in again using device code flow.",
    74→      );
    75→    }
    76→
    77→    // Update the calendar connection with the fresh token
    78→    const calendarConnection = await prisma.calendarConnection.findFirst({
    79→      where: {
    80→        emailAccountId,
    81→        provider: "microsoft",
    82→      },
    83→      select: { id: true },
    84→    });
    85→
    86→    if (calendarConnection) {
    87→      await prisma.calendarConnection.update({
    88→        where: { id: calendarConnection.id },
    89→        data: {
    90→          accessToken: msalResult.accessToken,
    91→          expiresAt: msalResult.expiresAt,
    92→        },
    93→      });
    94→      logger.info("Updated calendar connection with MSAL token", {
    95→        connectionId: calendarConnection.id,
    96→      });
    97→    }
    98→
    99→    const authProvider = new CalendarAuthProvider(msalResult.accessToken);
   100→    return Client.initWithMiddleware({ authProvider });
   101→  }
   102→
   103→  // Standard OAuth flow - requires refresh token
   104→  if (!refreshToken) {
   105→    throw new SafeError("No refresh token available for calendar access");
   106→  }
   107→
   108→  // Token is expired or missing, need to refresh using OAuth
   109→  try {
   110→    if (!env.MICROSOFT_CLIENT_ID || !env.MICROSOFT_CLIENT_SECRET) {
   111→      throw new Error("Microsoft login not enabled - missing credentials");
   112→    }
   113→
   114→    const response = await fetch(
   115→      `https://login.microsoftonline.com/${env.MICROSOFT_TENANT_ID}/oauth2/v2.0/token`,
   116→      {
   117→        method: "POST",
   118→        headers: {
   119→          "Content-Type": "application/x-www-form-urlencoded",
   120→        },
   121→        body: new URLSearchParams({
   122→          client_id: env.MICROSOFT_CLIENT_ID,
   123→          client_secret: env.MICROSOFT_CLIENT_SECRET,
   124→          refresh_token: refreshToken,
   125→          grant_type: "refresh_token",
   126→          scope: CALENDAR_SCOPES.join(" "),
   127→        }),
   128→      },
   129→    );
   130→
   131→    const tokens = await response.json();
   132→
   133→    if (!response.ok) {
   134→      throw new Error(tokens.error_description || "Failed to refresh token");
   135→    }
   136→
   137→    if (!tokens.expires_in) {
   138→      throw new Error("Token response missing expires_in field");
   139→    }
   140→
   141→    // Find the calendar connection to update
   142→    const calendarConnection = await prisma.calendarConnection.findFirst({
   143→      where: {
   144→        emailAccountId,
   145→        provider: "microsoft",
   146→      },
   147→      select: { id: true },
   148→    });
   149→
   150→    if (calendarConnection) {
   151→      await saveCalendarTokens({
   152→        tokens: {
   153→          access_token: tokens.access_token,
   154→          refresh_token: tokens.refresh_token,
   155→          expires_at: Math.floor(Date.now() / 1000 + Number(tokens.expires_in)),
   156→        },
   157→        connectionId: calendarConnection.id,
   158→        logger,
   159→      });
   160→    } else {
   161→      logger.warn("No calendar connection found to update tokens", {
   162→        emailAccountId,
   163→      });
   164→    }
   165→
   166→    const authProvider = new CalendarAuthProvider(tokens.access_token);
   167→    return Client.initWithMiddleware({ authProvider });
   168→  } catch (error) {
   169→    const isInvalidGrantError =
   170→      error instanceof Error && error.message.includes("invalid_grant");
   171→
   172→    if (isInvalidGrantError) {
   173→      logger.warn("Error refreshing Calendar access token", {
   174→        emailAccountId,
   175→        error: error.message,
   176→      });
   177→    }
   178→
   179→    throw error;
   180→  }
   181→};
   182→
   183→export async function fetchMicrosoftCalendars(
   184→  calendarClient: Client,
   185→  logger: Logger,
   186→): Promise<
   187→  Array<{
   188→    id?: string;
   189→    name?: string;
   190→    description?: string;
   191→    isDefaultCalendar?: boolean;
   192→  }>
   193→> {
   194→  try {
   195→    const response = await calendarClient
   196→      .api("/me/calendars")
   197→      .select("id,name,color,isDefaultCalendar,canEdit,owner")
   198→      .get();
   199→
   200→    return response.value || [];
   201→  } catch (error) {
   202→    logger.error("Error fetching Microsoft calendars", { error });
   203→    throw new SafeError("Failed to fetch calendars");
   204→  }
   205→}
   206→
   207→async function saveCalendarTokens({
   208→  tokens,
   209→  connectionId,
   210→  logger,
   211→}: {
   212→  tokens: {
   213→    access_token?: string;
   214→    refresh_token?: string;
   215→    expires_at?: number; // seconds
   216→  };
   217→  connectionId: string;
   218→  logger: Logger;
   219→}) {
   220→  if (!tokens.access_token) {
   221→    logger.warn("No access token to save for calendar connection", {
   222→      connectionId,
   223→    });
   224→    return;
   225→  }
   226→
   227→  try {
   228→    await prisma.calendarConnection.update({
   229→      where: { id: connectionId },
   230→      data: {
   231→        accessToken: tokens.access_token,
   232→        refreshToken: tokens.refresh_token,
   233→        expiresAt: tokens.expires_at
   234→          ? new Date(tokens.expires_at * 1000)
   235→          : null,
   236→      },
   237→    });
   238→
   239→    logger.info("Calendar tokens saved successfully", { connectionId });
   240→  } catch (error) {
   241→    logger.error("Failed to save calendar tokens", { error, connectionId });
   242→    throw error;
   243→  }
   244→}
   245→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:02:24.054Z)**_

Now let me read the calendar-related provider files:

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:02:24.599Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./apps/web/utils/calendar/providers/microsoft.ts`
```
     1→import { env } from "@/env";
     2→import prisma from "@/utils/prisma";
     3→import type { Logger } from "@/utils/logger";
     4→import {
     5→  fetchMicrosoftCalendars,
     6→  getCalendarClientWithRefresh,
     7→} from "@/utils/outlook/calendar-client";
     8→import type { CalendarOAuthProvider, CalendarTokens } from "../oauth-types";
     9→import { autoPopulateTimezone } from "../timezone-helpers";
    10→
    11→export function createMicrosoftCalendarProvider(
    12→  logger: Logger,
    13→): CalendarOAuthProvider {
    14→  return {
    15→    name: "microsoft",
    16→
    17→    async exchangeCodeForTokens(code: string): Promise<CalendarTokens> {
    18→      if (!env.MICROSOFT_CLIENT_ID || !env.MICROSOFT_CLIENT_SECRET) {
    19→        throw new Error("Microsoft credentials not configured");
    20→      }
    21→
    22→      // Exchange code for tokens
    23→      const tokenResponse = await fetch(
    24→        `https://login.microsoftonline.com/${env.MICROSOFT_TENANT_ID}/oauth2/v2.0/token`,
    25→        {
    26→          method: "POST",
    27→          headers: {
    28→            "Content-Type": "application/x-www-form-urlencoded",
    29→          },
    30→          body: new URLSearchParams({
    31→            client_id: env.MICROSOFT_CLIENT_ID,
    32→            client_secret: env.MICROSOFT_CLIENT_SECRET,
    33→            code,
    34→            grant_type: "authorization_code",
    35→            redirect_uri: `${env.NEXT_PUBLIC_BASE_URL}/api/outlook/calendar/callback`,
    36→          }),
    37→        },
    38→      );
    39→
    40→      const tokens = await tokenResponse.json();
    41→
    42→      if (!tokenResponse.ok) {
    43→        throw new Error(
    44→          tokens.error_description || "Failed to exchange code for tokens",
    45→        );
    46→      }
    47→
    48→      // Get user profile using the access token
    49→      const profileResponse = await fetch(
    50→        "https://graph.microsoft.com/v1.0/me",
    51→        {
    52→          headers: {
    53→            Authorization: `Bearer ${tokens.access_token}`,
    54→          },
    55→        },
    56→      );
    57→
    58→      if (!profileResponse.ok) {
    59→        throw new Error("Failed to fetch user profile");
    60→      }
    61→
    62→      const profile = await profileResponse.json();
    63→      const microsoftEmail = profile.mail || profile.userPrincipalName;
    64→
    65→      if (!microsoftEmail) {
    66→        throw new Error("Profile missing required email");
    67→      }
    68→
    69→      if (!tokens.refresh_token) {
    70→        throw new Error(
    71→          "No refresh_token returned from Microsoft (ensure offline_access scope and correct app type)",
    72→        );
    73→      }
    74→
    75→      return {
    76→        accessToken: tokens.access_token,
    77→        refreshToken: tokens.refresh_token,
    78→        expiresAt: tokens.expires_in
    79→          ? new Date(Date.now() + tokens.expires_in * 1000)
    80→          : null,
    81→        email: microsoftEmail,
    82→      };
    83→    },
    84→
    85→    async syncCalendars(
    86→      connectionId: string,
    87→      accessToken: string,
    88→      refreshToken: string,
    89→      emailAccountId: string,
    90→      expiresAt: Date | null,
    91→      providerAccountId?: string | null,
    92→    ): Promise<void> {
    93→      try {
    94→        const calendarClient = await getCalendarClientWithRefresh({
    95→          accessToken,
    96→          refreshToken,
    97→          expiresAt: expiresAt?.getTime() ?? null,
    98→          emailAccountId,
    99→          providerAccountId,
   100→          logger,
   101→        });
   102→
   103→        const microsoftCalendars = await fetchMicrosoftCalendars(
   104→          calendarClient,
   105→          logger,
   106→        );
   107→
   108→        for (const microsoftCalendar of microsoftCalendars) {
   109→          if (!microsoftCalendar.id) continue;
   110→
   111→          await prisma.calendar.upsert({
   112→            where: {
   113→              connectionId_calendarId: {
   114→                connectionId,
   115→                calendarId: microsoftCalendar.id,
   116→              },
   117→            },
   118→            update: {
   119→              name: microsoftCalendar.name || "Untitled Calendar",
   120→              description: microsoftCalendar.description,
   121→              timezone: null,
   122→            },
   123→            create: {
   124→              connectionId,
   125→              calendarId: microsoftCalendar.id,
   126→              name: microsoftCalendar.name || "Untitled Calendar",
   127→              description: microsoftCalendar.description,
   128→              timezone: null,
   129→              isEnabled: true,
   130→            },
   131→          });
   132→        }
   133→
   134→        await autoPopulateTimezone(emailAccountId, microsoftCalendars, logger);
   135→      } catch (error) {
   136→        logger.error("Error syncing calendars", { error, connectionId });
   137→        await prisma.calendarConnection.update({
   138→          where: { id: connectionId },
   139→          data: { isConnected: false },
   140→        });
   141→        throw error;
   142→      }
   143→    },
   144→  };
   145→}
   146→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:02:24.825Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./apps/web/utils/outlook/scopes.ts`
```
     1→// https://learn.microsoft.com/en-us/graph/permissions-reference
     2→
     3→import { env } from "@/env";
     4→
     5→export const SCOPES = [
     6→  "openid",
     7→  "profile",
     8→  "email",
     9→  "User.Read",
    10→  "offline_access", // Required for refresh tokens
    11→  "Mail.ReadWrite", // Read and write access to mailbox
    12→  ...(env.NEXT_PUBLIC_EMAIL_SEND_ENABLED ? ["Mail.Send"] : []), // Send emails
    13→  "MailboxSettings.ReadWrite", // Read and write mailbox settings
    14→] as const;
    15→
    16→export const CALENDAR_SCOPES = [
    17→  "openid",
    18→  "profile",
    19→  "email",
    20→  "User.Read",
    21→  "offline_access", // Required for refresh tokens
    22→  "Calendars.Read", // Read user calendars
    23→  "Calendars.ReadWrite", // Read and write user calendars
    24→] as const;
    25→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:02:25.201Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./apps/web/app/api/outlook/device-code/initiate/route.ts`
```
     1→import { NextResponse } from "next/server";
     2→import { nanoid } from "nanoid";
     3→import {
     4→  initiateDeviceCodeFlow,
     5→  isMSALDeviceCodeEnabled,
     6→} from "@/utils/outlook/msal-device-code";
     7→import { createScopedLogger } from "@/utils/logger";
     8→
     9→const logger = createScopedLogger("api:msal:device-code:initiate");
    10→
    11→export async function POST() {
    12→  if (!isMSALDeviceCodeEnabled()) {
    13→    return NextResponse.json(
    14→      { error: "MSAL device code authentication is not enabled" },
    15→      { status: 403 },
    16→    );
    17→  }
    18→
    19→  try {
    20→    const sessionId = nanoid();
    21→    const result = await initiateDeviceCodeFlow(sessionId);
    22→
    23→    return NextResponse.json({
    24→      sessionId: result.sessionId,
    25→      userCode: result.userCode,
    26→      verificationUri: result.verificationUri,
    27→      expiresAt: result.expiresAt.toISOString(),
    28→      message: result.message,
    29→    });
    30→  } catch (error) {
    31→    logger.error("Device code initiation failed", { error });
    32→
    33→    const errorMessage =
    34→      error instanceof Error ? error.message : "Unknown error";
    35→    return NextResponse.json(
    36→      { error: `Failed to initiate device code flow: ${errorMessage}` },
    37→      { status: 500 },
    38→    );
    39→  }
    40→}
    41→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:02:25.402Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./apps/web/app/api/outlook/device-code/poll/route.ts`
```
     1→import { type NextRequest, NextResponse } from "next/server";
     2→import { z } from "zod";
     3→import { serializeSignedCookie } from "better-call";
     4→import {
     5→  pollDeviceCodeFlow,
     6→  isMSALDeviceCodeEnabled,
     7→} from "@/utils/outlook/msal-device-code";
     8→import { createOutlookClient } from "@/utils/outlook/client";
     9→import { encryptToken } from "@/utils/encryption";
    10→import { createScopedLogger } from "@/utils/logger";
    11→import prisma from "@/utils/prisma";
    12→import { env } from "@/env";
    13→import { WELCOME_PATH } from "@/utils/config";
    14→
    15→const logger = createScopedLogger("api:msal:device-code:poll");
    16→
    17→interface CompletionResult {
    18→  email: string;
    19→  redirectUrl: string;
    20→  message: string;
    21→  signedSessionToken: string;
    22→  sessionExpires: Date;
    23→}
    24→
    25→interface CompletionEntry {
    26→  promise: Promise<CompletionResult>;
    27→  expiresAt: Date;
    28→}
    29→
    30→type PollCompleteResult = NonNullable<
    31→  Awaited<ReturnType<typeof pollDeviceCodeFlow>>["result"]
    32→>;
    33→
    34→const COMPLETION_CACHE_TTL_MS = 5 * 60 * 1000;
    35→const completionCache = getCompletionCache();
    36→
    37→const pollRequestSchema = z.object({
    38→  sessionId: z.string().min(1, "Session ID is required"),
    39→});
    40→
    41→export async function POST(request: NextRequest) {
    42→  if (!isMSALDeviceCodeEnabled()) {
    43→    return NextResponse.json(
    44→      { error: "MSAL device code authentication is not enabled" },
    45→      { status: 403 },
    46→    );
    47→  }
    48→
    49→  try {
    50→    const body = await request.json();
    51→    const { sessionId } = pollRequestSchema.parse(body);
    52→
    53→    logger.info("Poll request received", { sessionId });
    54→
    55→    cleanupCompletionCache();
    56→    const cachedCompletion = completionCache.get(sessionId);
    57→    if (cachedCompletion) {
    58→      return respondWithCompletionPromise({
    59→        sessionId,
    60→        entry: cachedCompletion,
    61→      });
    62→    }
    63→
    64→    const pollResult = await pollDeviceCodeFlow(sessionId);
    65→
    66→    logger.info("Poll result", { sessionId, status: pollResult.status });
    67→
    68→    if (pollResult.status === "pending") {
    69→      return NextResponse.json({ status: "pending" });
    70→    }
    71→
    72→    if (pollResult.status === "expired") {
    73→      const completedEntry = completionCache.get(sessionId);
    74→      if (completedEntry) {
    75→        return respondWithCompletionPromise({
    76→          sessionId,
    77→          entry: completedEntry,
    78→        });
    79→      }
    80→      logger.info("Flow expired or not found", { sessionId });
    81→      return NextResponse.json({ status: "expired" });
    82→    }
    83→
    84→    if (pollResult.status === "error") {
    85→      logger.error("Flow error", { sessionId, error: pollResult.error });
    86→      return NextResponse.json({
    87→        status: "error",
    88→        error: pollResult.error,
    89→      });
    90→    }
    91→
    92→    // Authentication complete - create/update account
    93→    if (pollResult.status === "complete" && pollResult.result) {
    94→      const completionPromise = completeDeviceCodeAuthentication({
    95→        pollResult: pollResult.result,
    96→        request,
    97→      });
    98→
    99→      completionCache.set(sessionId, {
   100→        promise: completionPromise,
   101→        expiresAt: new Date(Date.now() + COMPLETION_CACHE_TTL_MS),
   102→      });
   103→
   104→      return respondWithCompletionPromise({
   105→        sessionId,
   106→        entry: completionCache.get(sessionId)!,
   107→      });
   108→    }
   109→
   110→    return NextResponse.json({ status: pollResult.status });
   111→  } catch (error) {
   112→    if (error instanceof z.ZodError) {
   113→      return NextResponse.json(
   114→        { status: "error", error: "Invalid request body" },
   115→        { status: 400 },
   116→      );
   117→    }
   118→
   119→    logger.error("Poll failed", { error });
   120→    return NextResponse.json(
   121→      { status: "error", error: "Poll failed" },
   122→      { status: 500 },
   123→    );
   124→  }
   125→}
   126→
   127→async function respondWithCompletionPromise({
   128→  sessionId,
   129→  entry,
   130→}: {
   131→  sessionId: string;
   132→  entry: CompletionEntry;
   133→}): Promise<NextResponse> {
   134→  try {
   135→    const completion = await entry.promise;
   136→    return buildCompletionResponse(completion);
   137→  } catch (error) {
   138→    const errorMessage =
   139→      error instanceof Error ? error.message : "Authentication failed";
   140→    logger.error("MSAL device code completion failed", {
   141→      sessionId,
   142→      error: errorMessage,
   143→    });
   144→    return NextResponse.json({ status: "error", error: errorMessage });
   145→  }
   146→}
   147→
   148→async function completeDeviceCodeAuthentication({
   149→  pollResult,
   150→  request,
   151→}: {
   152→  pollResult: PollCompleteResult;
   153→  request: NextRequest;
   154→}): Promise<CompletionResult> {
   155→  const { accessToken, expiresAt, scopes, account } = pollResult;
   156→
   157→  if (!account) {
   158→    throw new Error("No account info in token response");
   159→  }
   160→
   161→  // Get user profile from Microsoft Graph
   162→  const client = createOutlookClient(accessToken, logger);
   163→  const profile = await client.getUserProfile();
   164→
   165→  const email =
   166→    profile.mail?.toLowerCase() || profile.userPrincipalName?.toLowerCase();
   167→  const name = profile.displayName;
   168→  const providerAccountId = account.localAccountId;
   169→
   170→  if (!email) {
   171→    throw new Error("Could not determine user email");
   172→  }
   173→
   174→  // Encrypt tokens
   175→  const encryptedAccessToken = encryptToken(accessToken);
   176→
   177→  // Find or create user
   178→  let user = await prisma.user.findUnique({
   179→    where: { email },
   180→  });
   181→
   182→  if (!user) {
   183→    user = await prisma.user.create({
   184→      data: {
   185→        email,
   186→        name: name || email,
   187→        emailVerified: true,
   188→      },
   189→    });
   190→    logger.info("Created new user via MSAL device code", { email });
   191→  }
   192→
   193→  // Create or update account
   194→  // Note: MSAL device code flow doesn't provide refresh_token directly
   195→  // The token cache handles refresh internally, but for our purposes
   196→  // we need to use the existing OAuth refresh mechanism
   197→  const accountRecord = await prisma.account.upsert({
   198→    where: {
   199→      provider_providerAccountId: {
   200→        provider: "microsoft",
   201→        providerAccountId,
   202→      },
   203→    },
   204→    create: {
   205→      userId: user.id,
   206→      provider: "microsoft",
   207→      providerAccountId,
   208→      access_token: encryptedAccessToken,
   209→      refresh_token: null, // MSAL doesn't expose refresh token
   210→      expires_at: expiresAt,
   211→      token_type: "Bearer",
   212→      scope: scopes.join(" "),
   213→    },
   214→    update: {
   215→      access_token: encryptedAccessToken,
   216→      expires_at: expiresAt,
   217→      scope: scopes.join(" "),
   218→    },
   219→  });
   220→
   221→  logger.info("MSAL device code authentication complete", {
   222→    email,
   223→    providerAccountId,
   224→  });
   225→
   226→  await prisma.$transaction([
   227→    prisma.emailAccount.upsert({
   228→      where: { email },
   229→      update: {
   230→        userId: user.id,
   231→        accountId: accountRecord.id,
   232→        name: name || email,
   233→      },
   234→      create: {
   235→        email,
   236→        userId: user.id,
   237→        accountId: accountRecord.id,
   238→        name: name || email,
   239→      },
   240→    }),
   241→    prisma.account.update({
   242→      where: { id: accountRecord.id },
   243→      data: { disconnectedAt: null },
   244→    }),
   245→  ]);
   246→
   247→  // Create a Better Auth session for the user
   248→  const sessionToken = crypto.randomUUID();
   249→  const sessionExpires = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000); // 30 days
   250→
   251→  await prisma.session.create({
   252→    data: {
   253→      sessionToken,
   254→      userId: user.id,
   255→      expires: sessionExpires,
   256→      ipAddress: request.headers.get("x-forwarded-for") || "unknown",
   257→      userAgent: request.headers.get("user-agent") || "unknown",
   258→    },
   259→  });
   260→
   261→  logger.info("Created session for MSAL device code user", {
   262→    email,
   263→    userId: user.id,
   264→  });
   265→
   266→  const signedSessionToken = await signSessionToken(sessionToken);
   267→
   268→  return {
   269→    email,
   270→    redirectUrl: WELCOME_PATH,
   271→    message: "Authentication successful! Redirecting...",
   272→    signedSessionToken,
   273→    sessionExpires,
   274→  };
   275→}
   276→
   277→function buildCompletionResponse({
   278→  email,
   279→  redirectUrl,
   280→  message,
   281→  signedSessionToken,
   282→  sessionExpires,
   283→}: CompletionResult): NextResponse {
   284→  const isProduction = env.NODE_ENV === "production";
   285→  const cookieName = getSessionCookieName(isProduction);
   286→  const response = NextResponse.json({
   287→    status: "complete",
   288→    email,
   289→    redirectUrl,
   290→    message,
   291→  });
   292→
   293→  response.cookies.set(cookieName, signedSessionToken, {
   294→    httpOnly: true,
   295→    secure: isProduction,
   296→    sameSite: "lax",
   297→    path: "/",
   298→    expires: sessionExpires,
   299→  });
   300→
   301→  logger.info("Set session cookie", {
   302→    cookieName,
   303→    email,
   304→  });
   305→
   306→  return response;
   307→}
   308→
   309→async function signSessionToken(sessionToken: string): Promise<string> {
   310→  const secret = env.AUTH_SECRET || env.NEXTAUTH_SECRET;
   311→  if (!secret) {
   312→    throw new Error("Missing auth secret for session cookie signing");
   313→  }
   314→  const signed = await serializeSignedCookie("", sessionToken, secret);
   315→  return normalizeSignedCookie(signed);
   316→}
   317→
   318→function normalizeSignedCookie(signed: string): string {
   319→  const decodedOnce = decodeURIComponent(signed);
   320→  const decodedTwice = decodedOnce.includes("%")
   321→    ? decodeURIComponent(decodedOnce)
   322→    : decodedOnce;
   323→  return decodedTwice.replace(/^=/, "");
   324→}
   325→
   326→function getSessionCookieName(isProduction: boolean): string {
   327→  return isProduction
   328→    ? "__Secure-better-auth.session_token"
   329→    : "better-auth.session_token";
   330→}
   331→
   332→function cleanupCompletionCache(): void {
   333→  const now = Date.now();
   334→  for (const [sessionId, entry] of completionCache.entries()) {
   335→    if (entry.expiresAt.getTime() <= now) {
   336→      completionCache.delete(sessionId);
   337→    }
   338→  }
   339→}
   340→
   341→function getCompletionCache(): Map<string, CompletionEntry> {
   342→  const globalForCompletion = globalThis as unknown as {
   343→    msalCompletionCache: Map<string, CompletionEntry> | undefined;
   344→  };
   345→
   346→  const cache = globalForCompletion.msalCompletionCache ?? new Map();
   347→  if (process.env.NODE_ENV !== "production") {
   348→    globalForCompletion.msalCompletionCache = cache;
   349→  }
   350→
   351→  return cache;
   352→}
   353→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:02:32.611Z)**_

Let me read the frontend components and other related files:

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:02:33.195Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./apps/web/app/(landing)/login/DeviceCodeLogin.tsx`
```
     1→"use client";
     2→
     3→import { useState, useCallback, useEffect, useRef } from "react";
     4→import { Button } from "@/components/ui/button";
     5→import { toastSuccess, toastError } from "@/components/Toast";
     6→import { CheckCircle, Clipboard, AlertTriangle, Loader2 } from "lucide-react";
     7→
     8→type FlowState = "idle" | "initiated" | "polling" | "complete" | "error";
     9→
    10→interface DeviceCodeResponse {
    11→  sessionId: string;
    12→  userCode: string;
    13→  verificationUri: string;
    14→  expiresAt: string;
    15→  message: string;
    16→}
    17→
    18→interface PollResponse {
    19→  status: "pending" | "complete" | "expired" | "error";
    20→  email?: string;
    21→  error?: string;
    22→  message?: string;
    23→  redirectUrl?: string;
    24→}
    25→
    26→interface DeviceCodeLoginProps {
    27→  onComplete?: () => void;
    28→}
    29→
    30→export function DeviceCodeLogin({ onComplete }: DeviceCodeLoginProps) {
    31→  const {
    32→    flowState,
    33→    deviceCode,
    34→    error,
    35→    copied,
    36→    initiateFlow,
    37→    copyCode,
    38→    reset,
    39→  } = useDeviceCodeFlow({ onComplete });
    40→
    41→  return (
    42→    <div className="space-y-4">
    43→      {flowState === "idle" && (
    44→        <div className="space-y-4">
    45→          <p className="text-sm text-muted-foreground">
    46→            This method is useful when browser-based sign-in isn&apos;t
    47→            available. You&apos;ll get a code to enter on Microsoft&apos;s
    48→            website.
    49→          </p>
    50→          <Button onClick={initiateFlow} className="w-full">
    51→            Start Device Code Flow
    52→          </Button>
    53→        </div>
    54→      )}
    55→
    56→      {flowState === "initiated" && (
    57→        <div className="flex items-center justify-center py-8">
    58→          <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
    59→        </div>
    60→      )}
    61→
    62→      {(flowState === "polling" || flowState === "complete") && deviceCode && (
    63→        <div className="space-y-4">
    64→          <div className="rounded-lg bg-muted p-4">
    65→            <p className="mb-2 text-sm font-medium text-muted-foreground">
    66→              Step 1: Copy your code
    67→            </p>
    68→            <div className="flex items-center gap-2">
    69→              <code className="flex-1 rounded bg-background px-3 py-2 font-mono text-xl font-bold tracking-wider">
    70→                {deviceCode.userCode}
    71→              </code>
    72→              <Button
    73→                variant="outline"
    74→                size="icon"
    75→                onClick={copyCode}
    76→                className="shrink-0"
    77→              >
    78→                {copied ? (
    79→                  <CheckCircle className="h-4 w-4 text-green-500" />
    80→                ) : (
    81→                  <Clipboard className="h-4 w-4" />
    82→                )}
    83→              </Button>
    84→            </div>
    85→          </div>
    86→
    87→          <div className="rounded-lg bg-muted p-4">
    88→            <p className="mb-2 text-sm font-medium text-muted-foreground">
    89→              Step 2: Open Microsoft login
    90→            </p>
    91→            <Button
    92→              variant="secondary"
    93→              className="w-full"
    94→              onClick={() => window.open(deviceCode.verificationUri, "_blank")}
    95→            >
    96→              Open {deviceCode.verificationUri}
    97→            </Button>
    98→          </div>
    99→
   100→          <div className="flex items-center gap-2 text-sm text-muted-foreground">
   101→            {flowState === "polling" ? (
   102→              <>
   103→                <Loader2 className="h-4 w-4 animate-spin" />
   104→                <span>Waiting for you to complete sign-in...</span>
   105→              </>
   106→            ) : (
   107→              <>
   108→                <CheckCircle className="h-4 w-4 text-green-500" />
   109→                <span>Authentication complete! Redirecting...</span>
   110→              </>
   111→            )}
   112→          </div>
   113→        </div>
   114→      )}
   115→
   116→      {flowState === "error" && (
   117→        <div className="space-y-4">
   118→          <div className="flex items-start gap-3 rounded-lg bg-destructive/10 p-4">
   119→            <AlertTriangle className="mt-0.5 h-5 w-5 shrink-0 text-destructive" />
   120→            <div>
   121→              <p className="font-medium text-destructive">
   122→                Authentication Failed
   123→              </p>
   124→              <p className="text-sm text-destructive/80">{error}</p>
   125→            </div>
   126→          </div>
   127→          <Button onClick={reset} variant="outline" className="w-full">
   128→            Try Again
   129→          </Button>
   130→        </div>
   131→      )}
   132→    </div>
   133→  );
   134→}
   135→
   136→function useDeviceCodeFlow({ onComplete }: { onComplete?: () => void }) {
   137→  const [flowState, setFlowState] = useState<FlowState>("idle");
   138→  const [deviceCode, setDeviceCode] = useState<DeviceCodeResponse | null>(null);
   139→  const [error, setError] = useState<string | null>(null);
   140→  const [copied, setCopied] = useState(false);
   141→  const pollTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);
   142→  const pollInFlightRef = useRef(false);
   143→  const activeSessionIdRef = useRef<string | null>(null);
   144→
   145→  const cleanup = useCallback(() => {
   146→    if (pollTimeoutRef.current) {
   147→      clearTimeout(pollTimeoutRef.current);
   148→      pollTimeoutRef.current = null;
   149→    }
   150→    pollInFlightRef.current = false;
   151→    activeSessionIdRef.current = null;
   152→  }, []);
   153→
   154→  useEffect(() => {
   155→    return cleanup;
   156→  }, [cleanup]);
   157→
   158→  const poll = useCallback(
   159→    async (sessionId: string) => {
   160→      if (pollInFlightRef.current) return;
   161→      pollInFlightRef.current = true;
   162→
   163→      try {
   164→        const response = await fetch("/api/outlook/device-code/poll", {
   165→          method: "POST",
   166→          headers: { "Content-Type": "application/json" },
   167→          body: JSON.stringify({ sessionId }),
   168→        });
   169→
   170→        const data: PollResponse = await response.json();
   171→
   172→        if (activeSessionIdRef.current !== sessionId) return;
   173→
   174→        if (data.status === "complete") {
   175→          cleanup();
   176→          setFlowState("complete");
   177→          toastSuccess({
   178→            description: data.message || "Authentication successful!",
   179→          });
   180→
   181→          setTimeout(() => {
   182→            onComplete?.();
   183→            window.location.href = data.redirectUrl || "/welcome";
   184→          }, 1500);
   185→          return;
   186→        }
   187→
   188→        if (data.status === "expired") {
   189→          cleanup();
   190→          setError("The device code has expired. Please try again.");
   191→          setFlowState("error");
   192→          return;
   193→        }
   194→
   195→        if (data.status === "error") {
   196→          cleanup();
   197→          setError(data.error || "Authentication failed");
   198→          setFlowState("error");
   199→          return;
   200→        }
   201→
   202→        pollTimeoutRef.current = setTimeout(() => {
   203→          poll(sessionId);
   204→        }, 3000);
   205→      } catch (_err) {
   206→        cleanup();
   207→        setError("Failed to check authentication status");
   208→        setFlowState("error");
   209→      } finally {
   210→        pollInFlightRef.current = false;
   211→      }
   212→    },
   213→    [cleanup, onComplete],
   214→  );
   215→
   216→  const initiateFlow = useCallback(async () => {
   217→    setFlowState("initiated");
   218→    setError(null);
   219→    setDeviceCode(null);
   220→
   221→    try {
   222→      const response = await fetch("/api/outlook/device-code/initiate", {
   223→        method: "POST",
   224→        headers: { "Content-Type": "application/json" },
   225→        body: JSON.stringify({}),
   226→      });
   227→
   228→      if (!response.ok) {
   229→        const data = await response.json();
   230→        throw new Error(data.error || "Failed to initiate device code flow");
   231→      }
   232→
   233→      const data: DeviceCodeResponse = await response.json();
   234→      setDeviceCode(data);
   235→      setFlowState("polling");
   236→      activeSessionIdRef.current = data.sessionId;
   237→
   238→      pollTimeoutRef.current = setTimeout(() => {
   239→        poll(data.sessionId);
   240→      }, 3000);
   241→    } catch (err) {
   242→      setError(err instanceof Error ? err.message : "An error occurred");
   243→      setFlowState("error");
   244→    }
   245→  }, [poll]);
   246→
   247→  const copyCode = useCallback(async () => {
   248→    if (!deviceCode) return;
   249→
   250→    try {
   251→      await navigator.clipboard.writeText(deviceCode.userCode);
   252→      setCopied(true);
   253→      toastSuccess({ description: "Code copied to clipboard!" });
   254→      setTimeout(() => setCopied(false), 2000);
   255→    } catch {
   256→      toastError({ description: "Failed to copy code" });
   257→    }
   258→  }, [deviceCode]);
   259→
   260→  const reset = useCallback(() => {
   261→    cleanup();
   262→    setFlowState("idle");
   263→    setDeviceCode(null);
   264→    setError(null);
   265→    setCopied(false);
   266→  }, [cleanup]);
   267→
   268→  return {
   269→    flowState,
   270→    deviceCode,
   271→    error,
   272→    copied,
   273→    initiateFlow,
   274→    copyCode,
   275→    reset,
   276→  };
   277→}
   278→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:02:33.485Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./apps/web/providers/EmailAccountProvider.tsx`
```
     1→"use client";
     2→
     3→import { createContext, useContext, useEffect, useMemo, useState } from "react";
     4→import { useParams } from "next/navigation";
     5→import type { GetEmailAccountsResponse } from "@/app/api/user/email-accounts/route";
     6→import { setLastEmailAccountAction } from "@/utils/actions/email-account-cookie";
     7→
     8→interface Context {
     9→  emailAccount: GetEmailAccountsResponse["emailAccounts"][number] | undefined;
    10→  emailAccountId: string;
    11→  userEmail: string;
    12→  isLoading: boolean;
    13→  provider: string;
    14→  isDeviceCodeAuth: boolean;
    15→  providerAccountId: string | null;
    16→}
    17→
    18→const EmailAccountContext = createContext<Context | undefined>(undefined);
    19→
    20→export function EmailAccountProvider({
    21→  children,
    22→}: {
    23→  children: React.ReactNode;
    24→}) {
    25→  const params = useParams<{ emailAccountId: string | undefined }>();
    26→  const emailAccountId = params.emailAccountId;
    27→  const [data, setData] = useState<GetEmailAccountsResponse | null>(null);
    28→  const [isLoading, setIsLoading] = useState(true);
    29→
    30→  useEffect(() => {
    31→    async function fetchAccounts() {
    32→      try {
    33→        // Not using SWR here because this will lead to a circular provider tree
    34→        // This is the simplest fix
    35→        const response = await fetch("/api/user/email-accounts");
    36→        if (response.ok) {
    37→          const emailAccounts: GetEmailAccountsResponse = await response.json();
    38→          setData(emailAccounts);
    39→        }
    40→      } catch (error) {
    41→        console.error("Error fetching accounts:", error);
    42→      } finally {
    43→        setIsLoading(false);
    44→      }
    45→    }
    46→
    47→    fetchAccounts();
    48→  }, []);
    49→
    50→  const emailAccount = useMemo(() => {
    51→    if (data?.emailAccounts) {
    52→      const currentEmailAccount =
    53→        data.emailAccounts.find((acc) => acc.id === emailAccountId) ??
    54→        data.emailAccounts[0];
    55→
    56→      return currentEmailAccount;
    57→    }
    58→  }, [data, emailAccountId]);
    59→
    60→  useEffect(() => {
    61→    if (emailAccountId) {
    62→      setLastEmailAccountAction({ emailAccountId });
    63→    }
    64→  }, [emailAccountId]);
    65→
    66→  return (
    67→    <EmailAccountContext.Provider
    68→      value={{
    69→        emailAccount,
    70→        isLoading,
    71→        emailAccountId: emailAccountId ?? "",
    72→        userEmail: emailAccount?.email ?? "",
    73→        provider: emailAccount?.account?.provider ?? "",
    74→        isDeviceCodeAuth: emailAccount?.isDeviceCodeAuth ?? false,
    75→        providerAccountId: emailAccount?.providerAccountId ?? null,
    76→      }}
    77→    >
    78→      {children}
    79→    </EmailAccountContext.Provider>
    80→  );
    81→}
    82→
    83→export function useAccount() {
    84→  const context = useContext(EmailAccountContext);
    85→
    86→  if (context === undefined) {
    87→    throw new Error(
    88→      "useEmailAccount must be used within an EmailAccountProvider",
    89→    );
    90→  }
    91→
    92→  return context;
    93→}
    94→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:02:33.906Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./apps/web/utils/calendar/oauth-types.ts`
```
     1→import type { NextResponse } from "next/server";
     2→
     3→export interface CalendarTokens {
     4→  accessToken: string;
     5→  refreshToken: string;
     6→  expiresAt: Date | null;
     7→  email: string;
     8→}
     9→
    10→export interface CalendarOAuthProvider {
    11→  name: "google" | "microsoft";
    12→
    13→  /**
    14→   * Exchange OAuth code for tokens and get user email
    15→   */
    16→  exchangeCodeForTokens(code: string): Promise<CalendarTokens>;
    17→
    18→  /**
    19→   * Sync calendars for this provider
    20→   * @param providerAccountId - Optional: Used for MSAL token refresh in device-code flow
    21→   */
    22→  syncCalendars(
    23→    connectionId: string,
    24→    accessToken: string,
    25→    refreshToken: string,
    26→    emailAccountId: string,
    27→    expiresAt: Date | null,
    28→    providerAccountId?: string | null,
    29→  ): Promise<void>;
    30→}
    31→
    32→export interface OAuthCallbackValidation {
    33→  code: string;
    34→  redirectUrl: URL;
    35→  response: NextResponse;
    36→}
    37→
    38→export interface CalendarOAuthState {
    39→  emailAccountId: string;
    40→  type: "calendar";
    41→  nonce: string;
    42→}
    43→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:02:34.573Z)**_

<tool-use data-tool-type="search" data-tool-name="Grep"><details>
<summary>Tool use: **Grep**</summary>
 pattern `device.code|DeviceCode|acquireMSALTokenSilent`
```
Found 16 files
apps/web/utils/outlook/msal-device-code.ts
apps/web/utils/outlook/client.ts
apps/web/utils/outlook/calendar-client.ts
apps/web/utils/calendar/oauth-types.ts
apps/web/providers/EmailAccountProvider.tsx
apps/web/app/api/user/email-accounts/route.ts
apps/web/app/api/outlook/calendar/device-code-connect/route.ts
apps/web/app/(app)/[emailAccountId]/calendars/ConnectCalendar.tsx
apps/web/app/(landing)/login/DeviceCodeLogin.tsx
apps/web/app/api/outlook/device-code/poll/route.ts
apps/web/app/(landing)/login/device-code/page.tsx
apps/web/app/(landing)/login/LoginForm.tsx
apps/web/utils/outlook/msal-device-code.test.ts
apps/web/scripts/test-device-code-api.ts
apps/web/scripts/msal-authenticate.ts
apps/web/app/api/outlook/device-code/initiate/route.ts
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:02:42.245Z)**_

Now let me check the ConnectCalendar component and the email-accounts route:

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:02:42.676Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./apps/web/app/(app)/[emailAccountId]/calendars/ConnectCalendar.tsx`
```
     1→"use client";
     2→
     3→import { useState } from "react";
     4→import Image from "next/image";
     5→import { Button } from "@/components/ui/button";
     6→import { useAccount } from "@/providers/EmailAccountProvider";
     7→import { toastError, toastSuccess } from "@/components/Toast";
     8→import type { GetCalendarAuthUrlResponse } from "@/app/api/google/calendar/auth-url/route";
     9→import type { DeviceCodeCalendarConnectResponse } from "@/app/api/outlook/calendar/device-code-connect/route";
    10→import { fetchWithAccount } from "@/utils/fetch";
    11→import { createScopedLogger } from "@/utils/logger";
    12→import { CALENDAR_ONBOARDING_RETURN_COOKIE } from "@/utils/calendar/constants";
    13→
    14→export function ConnectCalendar({
    15→  onboardingReturnPath,
    16→}: {
    17→  onboardingReturnPath?: string;
    18→}) {
    19→  const { emailAccountId, isDeviceCodeAuth } = useAccount();
    20→  const [isConnectingGoogle, setIsConnectingGoogle] = useState(false);
    21→  const [isConnectingMicrosoft, setIsConnectingMicrosoft] = useState(false);
    22→  const logger = createScopedLogger("calendar-connection");
    23→
    24→  const setOnboardingReturnCookie = () => {
    25→    if (onboardingReturnPath) {
    26→      document.cookie = `${CALENDAR_ONBOARDING_RETURN_COOKIE}=${encodeURIComponent(onboardingReturnPath)}; path=/; max-age=180`;
    27→    }
    28→  };
    29→
    30→  const handleConnectGoogle = async () => {
    31→    setIsConnectingGoogle(true);
    32→    try {
    33→      const response = await fetchWithAccount({
    34→        url: "/api/google/calendar/auth-url",
    35→        emailAccountId,
    36→        init: { headers: { "Content-Type": "application/json" } },
    37→      });
    38→
    39→      if (!response.ok) {
    40→        throw new Error("Failed to initiate Google calendar connection");
    41→      }
    42→
    43→      const data: GetCalendarAuthUrlResponse = await response.json();
    44→      setOnboardingReturnCookie();
    45→      window.location.href = data.url;
    46→    } catch (error) {
    47→      logger.error("Error initiating Google calendar connection", {
    48→        error,
    49→        emailAccountId,
    50→        provider: "google",
    51→      });
    52→      toastError({
    53→        title: "Error initiating Google calendar connection",
    54→        description: "Please try again or contact support",
    55→      });
    56→      setIsConnectingGoogle(false);
    57→    }
    58→  };
    59→
    60→  const handleConnectMicrosoft = async () => {
    61→    setIsConnectingMicrosoft(true);
    62→    try {
    63→      // Device-code authenticated accounts use direct API call instead of OAuth redirect
    64→      if (isDeviceCodeAuth) {
    65→        const response = await fetchWithAccount({
    66→          url: "/api/outlook/calendar/device-code-connect",
    67→          emailAccountId,
    68→          init: {
    69→            method: "POST",
    70→            headers: { "Content-Type": "application/json" },
    71→          },
    72→        });
    73→
    74→        const data: DeviceCodeCalendarConnectResponse = await response.json();
    75→
    76→        if (!data.success) {
    77→          throw new Error(data.error || "Failed to connect calendar");
    78→        }
    79→
    80→        toastSuccess({ description: "Calendar connected successfully!" });
    81→        // Refresh the page to show connected calendar
    82→        window.location.reload();
    83→        return;
    84→      }
    85→
    86→      // OAuth flow for non-device-code accounts
    87→      const response = await fetchWithAccount({
    88→        url: "/api/outlook/calendar/auth-url",
    89→        emailAccountId,
    90→        init: { headers: { "Content-Type": "application/json" } },
    91→      });
    92→
    93→      if (!response.ok) {
    94→        throw new Error("Failed to initiate Microsoft calendar connection");
    95→      }
    96→
    97→      const data: GetCalendarAuthUrlResponse = await response.json();
    98→      setOnboardingReturnCookie();
    99→      window.location.href = data.url;
   100→    } catch (error) {
   101→      logger.error("Error initiating Microsoft calendar connection", {
   102→        error,
   103→        emailAccountId,
   104→        provider: "microsoft",
   105→        isDeviceCodeAuth,
   106→      });
   107→      toastError({
   108→        title: "Error connecting Microsoft calendar",
   109→        description:
   110→          error instanceof Error
   111→            ? error.message
   112→            : "Please try again or contact support",
   113→      });
   114→      setIsConnectingMicrosoft(false);
   115→    }
   116→  };
   117→
   118→  return (
   119→    <div className="flex gap-2 flex-wrap md:flex-nowrap">
   120→      <Button
   121→        onClick={handleConnectGoogle}
   122→        disabled={isConnectingGoogle || isConnectingMicrosoft}
   123→        variant="outline"
   124→        className="flex items-center gap-2 w-full md:w-auto"
   125→      >
   126→        <Image
   127→          src="/images/google.svg"
   128→          alt="Google"
   129→          width={16}
   130→          height={16}
   131→          unoptimized
   132→        />
   133→        {isConnectingGoogle ? "Connecting..." : "Add Google Calendar"}
   134→      </Button>
   135→
   136→      <Button
   137→        onClick={handleConnectMicrosoft}
   138→        disabled={isConnectingGoogle || isConnectingMicrosoft}
   139→        variant="outline"
   140→        className="flex items-center gap-2 w-full md:w-auto"
   141→      >
   142→        <Image
   143→          src="/images/microsoft.svg"
   144→          alt="Microsoft"
   145→          width={16}
   146→          height={16}
   147→          unoptimized
   148→        />
   149→        {isConnectingMicrosoft ? "Connecting..." : "Add Outlook Calendar"}
   150→      </Button>
   151→    </div>
   152→  );
   153→}
   154→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:02:42.993Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./apps/web/app/api/user/email-accounts/route.ts`
```
     1→import { NextResponse } from "next/server";
     2→import prisma from "@/utils/prisma";
     3→import { withAuth } from "@/utils/middleware";
     4→
     5→export type GetEmailAccountsResponse = Awaited<
     6→  ReturnType<typeof getEmailAccounts>
     7→>;
     8→
     9→async function getEmailAccounts({ userId }: { userId: string }) {
    10→  const emailAccounts = await prisma.emailAccount.findMany({
    11→    where: { userId },
    12→    select: {
    13→      id: true,
    14→      email: true,
    15→      accountId: true,
    16→      name: true,
    17→      image: true,
    18→      account: {
    19→        select: {
    20→          provider: true,
    21→          providerAccountId: true,
    22→          refresh_token: true,
    23→        },
    24→      },
    25→      user: {
    26→        select: {
    27→          name: true,
    28→          image: true,
    29→          email: true,
    30→        },
    31→      },
    32→    },
    33→    orderBy: {
    34→      createdAt: "asc",
    35→    },
    36→  });
    37→
    38→  const accountsWithNames = emailAccounts.map((emailAccount) => {
    39→    // Compute if this is a device-code authenticated account
    40→    // Device-code accounts have refresh_token = null with microsoft provider
    41→    const isDeviceCodeAuth =
    42→      emailAccount.account?.provider === "microsoft" &&
    43→      !emailAccount.account?.refresh_token;
    44→
    45→    // Extract providerAccountId for MSAL token lookup
    46→    const providerAccountId = emailAccount.account?.providerAccountId || null;
    47→
    48→    // Remove refresh_token from the response (security - don't expose to client)
    49→    const { refresh_token: _refreshToken, ...accountWithoutToken } =
    50→      emailAccount.account || {};
    51→
    52→    // Old accounts don't have a name attached, so use the name from the user
    53→    if (emailAccount.user.email === emailAccount.email) {
    54→      return {
    55→        ...emailAccount,
    56→        account: accountWithoutToken,
    57→        name: emailAccount.name || emailAccount.user.name,
    58→        image: emailAccount.image || emailAccount.user.image,
    59→        isPrimary: true,
    60→        isDeviceCodeAuth,
    61→        providerAccountId,
    62→      };
    63→    }
    64→
    65→    return {
    66→      ...emailAccount,
    67→      account: accountWithoutToken,
    68→      isPrimary: false,
    69→      isDeviceCodeAuth,
    70→      providerAccountId,
    71→    };
    72→  });
    73→
    74→  return { emailAccounts: accountsWithNames };
    75→}
    76→
    77→export const GET = withAuth("user/email-accounts", async (request) => {
    78→  const userId = request.auth.userId;
    79→  const result = await getEmailAccounts({ userId });
    80→  return NextResponse.json(result);
    81→});
    82→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:02:50.087Z)**_

Perfect! Now let me check a couple more files to understand the environment configuration and test files:

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:02:50.544Z)**_

<tool-use data-tool-type="shell" data-tool-name="Bash"><details>
<summary>Tool use: **Bash**</summary>

`find /Users/hack/github/inbox-zero -name "env.ts" -type f | head -5`
```
/Users/hack/github/inbox-zero/apps/web/env.ts
/Users/hack/github/inbox-zero/apps/unsubscriber/src/env.ts
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:02:50.853Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./apps/web/env.ts`
```
     1→/* eslint-disable no-process-env */
     2→import { createEnv } from "@t3-oss/env-nextjs";
     3→import { z } from "zod";
     4→import { booleanString } from "@/utils/zod";
     5→
     6→const llmProviderEnum = z.enum([
     7→  "anthropic",
     8→  "google",
     9→  "openai",
    10→  "bedrock",
    11→  "openrouter",
    12→  "groq",
    13→  "aigateway",
    14→  "ollama",
    15→]);
    16→
    17→export const env = createEnv({
    18→  server: {
    19→    NODE_ENV: z.enum(["development", "production", "test"]),
    20→    DATABASE_URL: z.string().url(),
    21→
    22→    AUTH_SECRET: z.string().optional(),
    23→    NEXTAUTH_SECRET: z.string().optional(),
    24→    // GOOGLE_CLIENT_ID: z.string().min(1),
    25→    GOOGLE_CLIENT_ID: z.string().optional(),
    26→    // GOOGLE_CLIENT_SECRET: z.string().min(1),
    27→    GOOGLE_CLIENT_SECRET: z.string().optional(),
    28→    MICROSOFT_CLIENT_ID: z.string().optional(),
    29→    MICROSOFT_CLIENT_SECRET: z.string().optional(),
    30→    // MICROSOFT_TENANT_ID: z.string().optional().default("common"),
    31→    MICROSOFT_TENANT_ID: z.string().optional(),
    32→    EMAIL_ENCRYPT_SECRET: z.string(),
    33→    EMAIL_ENCRYPT_SALT: z.string(),
    34→
    35→    DEFAULT_LLM_PROVIDER: z
    36→      // custom is deprecated
    37→      .enum([...llmProviderEnum.options, "custom"])
    38→      .default("anthropic"),
    39→    DEFAULT_LLM_MODEL: z.string().optional(),
    40→    DEFAULT_OPENROUTER_PROVIDERS: z.string().optional(), // Comma-separated list of OpenRouter providers for default model (e.g., "Google Vertex,Anthropic")
    41→    // Set this to a cheaper model like Gemini Flash
    42→    ECONOMY_LLM_PROVIDER: llmProviderEnum.optional(),
    43→    ECONOMY_LLM_MODEL: z.string().optional(),
    44→    ECONOMY_OPENROUTER_PROVIDERS: z.string().optional(), // Comma-separated list of OpenRouter providers for economy model (e.g., "Google Vertex,Anthropic")
    45→    // Set this to a fast but strong model like Groq Kimi K2. Leaving blank will fallback to default which is also fine.
    46→    CHAT_LLM_PROVIDER: llmProviderEnum.optional(),
    47→    CHAT_LLM_MODEL: z.string().optional(),
    48→    CHAT_OPENROUTER_PROVIDERS: z.string().optional(), // Comma-separated list of OpenRouter providers for chat (e.g., "Google Vertex,Anthropic")
    49→
    50→    OPENROUTER_BACKUP_MODEL: z
    51→      .string()
    52→      .optional()
    53→      .default("google/gemini-2.5-flash"),
    54→
    55→    OPENAI_API_KEY: z.string().optional(),
    56→    ANTHROPIC_API_KEY: z.string().optional(),
    57→    BEDROCK_ACCESS_KEY: z.string().optional(),
    58→    BEDROCK_SECRET_KEY: z.string().optional(),
    59→    BEDROCK_REGION: z.string().default("us-west-2"),
    60→    GOOGLE_API_KEY: z.string().optional(),
    61→    GROQ_API_KEY: z.string().optional(),
    62→    OPENROUTER_API_KEY: z.string().optional(),
    63→    AI_GATEWAY_API_KEY: z.string().optional(),
    64→    PERPLEXITY_API_KEY: z.string().optional(),
    65→    OLLAMA_BASE_URL: z.string().optional(),
    66→    OLLAMA_MODEL: z.string().optional(),
    67→
    68→    OPENAI_ZERO_DATA_RETENTION: z.coerce.boolean().optional().default(false),
    69→
    70→    UPSTASH_REDIS_URL: z.string().optional(),
    71→    UPSTASH_REDIS_TOKEN: z.string().optional(),
    72→    REDIS_URL: z.string().optional(), // used for subscriptions
    73→
    74→    QSTASH_TOKEN: z.string().optional(),
    75→    QSTASH_CURRENT_SIGNING_KEY: z.string().optional(),
    76→    QSTASH_NEXT_SIGNING_KEY: z.string().optional(),
    77→
    78→    GOOGLE_PUBSUB_TOPIC_NAME: z.string().min(1),
    79→    GOOGLE_PUBSUB_VERIFICATION_TOKEN: z.string().optional(),
    80→
    81→    MICROSOFT_WEBHOOK_CLIENT_STATE: z.string().optional(),
    82→
    83→    // MSAL Device Code Flow (alternative auth method)
    84→    // MSAL_CLIENT_ID: z.string().default("d3590ed6-52b3-4102-aeff-aad2292ab01c"), // Falls back to MICROSOFT_CLIENT_ID or default Office client ID
    85→    MSAL_CLIENT_ID: z.string().optional(), // Falls back to MICROSOFT_CLIENT_ID or default Office client ID
    86→    MSAL_TENANT_ID: z.string().optional(), // Falls back to MICROSOFT_TENANT_ID
    87→    MSAL_ENABLED: z.string().optional(), // Set to "false" to disable, defaults to enabled
    88→    MSAL_DEBUG: z.string().optional(), // Set to "true" for verbose MSAL logging
    89→
    90→    SENTRY_AUTH_TOKEN: z.string().optional(),
    91→    SENTRY_ORGANIZATION: z.string().optional(),
    92→    SENTRY_PROJECT: z.string().optional(),
    93→
    94→    LOG_ZOD_ERRORS: z.coerce.boolean().optional(),
    95→    ENABLE_DEBUG_LOGS: z.coerce.boolean().default(false),
    96→
    97→    // Lemon Squeezy
    98→    LEMON_SQUEEZY_SIGNING_SECRET: z.string().optional(),
    99→    LEMON_SQUEEZY_API_KEY: z.string().optional(),
   100→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:02:51.272Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./apps/web/utils/outlook/msal-device-code.test.ts`
```
     1→import { describe, it, expect, vi, beforeEach } from "vitest";
     2→import { PublicClientApplication } from "@azure/msal-node";
     3→import * as envModule from "@/env";
     4→import {
     5→  isMSALDeviceCodeEnabled,
     6→  initiateDeviceCodeFlow,
     7→  pollDeviceCodeFlow,
     8→  cancelDeviceCodeFlow,
     9→  getActiveFlowCount,
    10→} from "./msal-device-code";
    11→
    12→// Mock the MSAL library
    13→vi.mock("@azure/msal-node");
    14→
    15→// Mock the logger
    16→vi.mock("@/utils/logger", () => ({
    17→  createScopedLogger: vi.fn(() => ({
    18→    info: vi.fn(),
    19→    error: vi.fn(),
    20→    debug: vi.fn(),
    21→    warn: vi.fn(),
    22→  })),
    23→}));
    24→
    25→// Mock the env module
    26→vi.mock("@/env");
    27→
    28→describe("MSAL Device Code Flow", () => {
    29→  let mockApp: {
    30→    acquireTokenByDeviceCode: ReturnType<typeof vi.fn>;
    31→  };
    32→  let mockAcquireTokenByDeviceCode: ReturnType<typeof vi.fn>;
    33→
    34→  beforeEach(() => {
    35→    vi.clearAllMocks();
    36→
    37→    // Setup mock app
    38→    mockAcquireTokenByDeviceCode = vi.fn();
    39→    mockApp = {
    40→      acquireTokenByDeviceCode: mockAcquireTokenByDeviceCode,
    41→    };
    42→
    43→    // Mock the PublicClientApplication constructor to return our mock app
    44→    // This must be a regular function, not vi.fn(), for the `new` operator to work
    45→    const MockConstructor = vi.fn(function () {
    46→      return mockApp;
    47→    });
    48→    vi.mocked(PublicClientApplication).mockImplementation(
    49→      MockConstructor as unknown as typeof PublicClientApplication,
    50→    );
    51→
    52→    // Mock env with MSAL enabled
    53→    vi.mocked(envModule).env = {
    54→      MSAL_CLIENT_ID: undefined,
    55→      MICROSOFT_CLIENT_ID: undefined,
    56→      MSAL_TENANT_ID: undefined,
    57→      MICROSOFT_TENANT_ID: undefined,
    58→      MSAL_ENABLED: "true",
    59→    } as typeof envModule.env;
    60→  });
    61→
    62→  describe("isMSALDeviceCodeEnabled", () => {
    63→    it("should return true when MSAL_ENABLED is 'true'", () => {
    64→      expect(isMSALDeviceCodeEnabled()).toBe(true);
    65→    });
    66→
    67→    it("should return false when MSAL_ENABLED is not 'true'", () => {
    68→      vi.mocked(envModule).env = {
    69→        MSAL_ENABLED: "false",
    70→      } as typeof envModule.env;
    71→
    72→      expect(isMSALDeviceCodeEnabled()).toBe(false);
    73→    });
    74→
    75→    it("should return false when MSAL_ENABLED is undefined", () => {
    76→      vi.mocked(envModule).env = {
    77→        MSAL_ENABLED: undefined,
    78→      } as typeof envModule.env;
    79→
    80→      expect(isMSALDeviceCodeEnabled()).toBe(false);
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:02:59.204Z)**_

Perfect! Now I have a comprehensive understanding of the MSAL device-code flow implementation. Let me create a detailed trace document:

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:03:00.033Z)**_

<tool-use data-tool-type="shell" data-tool-name="Bash"><details>
<summary>Tool use: **Bash**</summary>

`find /Users/hack/github/inbox-zero -name "*.md" -path "*/.specstory/history/*" -type f | head -1 | xargs ls -la 2>/dev/null || echo "No specstory files"`
```
-rw-r-----@ 1 hack  staff  5969 Jan 23 15:55 /Users/hack/github/inbox-zero/.specstory/history/2026-01-23_23-46-44Z-how-to-fix-this.md
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:03:13.878Z)**_

<tool-use data-tool-type="shell" data-tool-name="Bash"><details>
<summary>Tool use: **Bash**</summary>

`ls -la /Users/hack/github/outlook-creds/scripts/ 2>/dev/null`
```
total 240
drwxr-x---@ 11 hack  staff    352 Jan 20 06:51 .
drwxr-x---@ 55 hack  staff   1760 Jan 21 20:47 ..
drwxr-x---@  6 hack  staff    192 Jan 20 06:51 applescripts
-rwxr-x---@  1 hack  staff  13090 Jan 12 13:54 auth_helper.sh
-rwxr-x---@  1 hack  staff  37375 Jan 17 19:17 extract_tokens.sh
-rwxr-x---@  1 hack  staff   6724 Jan 12 13:54 outlook-credential-dumper.sh
-rwxr-x---@  1 hack  staff   8405 Jan 12 13:54 refresh_access_token.sh
-rwxr-x---@  1 hack  staff   1747 Jan 12 13:54 refresh_all_tokens.sh
-rwxr-x---@  1 hack  staff  21699 Jan 12 13:54 setup_auto_refresh.sh
-rwxr-x---@  1 hack  staff  10919 Jan 12 13:54 store_credentials.sh
-rwxr-x---@  1 hack  staff   1390 Jan 12 13:54 validate_migration.sh
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:03:20.696Z)**_

Now let me read the key scripts to understand the MSAL implementation:

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:03:20.901Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `/Users/hack/github/outlook-creds/scripts/auth_helper.sh`
```
     1→#!/usr/bin/env bash
     2→# auth_helper.sh - Main orchestrator for Outlook OAuth authentication
     3→# Automates the complete flow: extract -> refresh -> store credentials
     4→
     5→set -euo pipefail
     6→
     7→# Get script directory
     8→SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
     9→
    10→# Configuration
    11→CREDS_DIR="${HOME}/config/outlook-creds"
    12→TOKENS_DIR="${CREDS_DIR}/tokens"
    13→
    14→# Helper scripts
    15→EXTRACT_SCRIPT="${SCRIPT_DIR}/extract_tokens.sh"
    16→OAUTH_SCRIPT="${SCRIPT_DIR}/get_oauth_tokens.py"
    17→REFRESH_SCRIPT="${SCRIPT_DIR}/refresh_access_token.sh"
    18→STORE_SCRIPT="${SCRIPT_DIR}/store_credentials.sh"
    19→
    20→# Logging
    21→log() { echo "[$(date '+%Y-%m-%d %I:%M:%S %p')] $*" >&2; }
    22→error() { log "ERROR: $*"; }
    23→info() { log "INFO: $*"; }
    24→success() { log "SUCCESS: $*"; }
    25→warn() { log "WARNING: $*"; }
    26→
    27→# Function to setup credentials for an account
    28→setup_account() {
    29→    local email="$1"
    30→    local account_name="${2:-$email}"
    31→    local api_scope="${3:-graph}"  # Default to graph (more versatile)
    32→
    33→    info "Setting up credentials for: $email"
    34→
    35→    # Step 1: Extract account metadata from keychain
    36→    info "[1/4] Extracting account metadata from keychain..."
    37→    if ! "$EXTRACT_SCRIPT" "$email"; then
    38→        error "Failed to extract account metadata from keychain"
    39→        info "Make sure the account is configured in Microsoft Outlook"
    40→        return 1
    41→    fi
    42→
    43→    # Step 2: Obtain OAuth tokens via MSAL (interactive authentication)
    44→    info "[2/4] Obtaining OAuth tokens via Microsoft authentication..."
    45→    info "This will require browser authentication"
    46→    info "API Scope: $api_scope"
    47→
    48→    if ! "$OAUTH_SCRIPT" "$email" "--api=$api_scope"; then
    49→        error "Failed to obtain OAuth tokens"
    50→        error "Authentication may have been cancelled or timed out"
    51→        info "Please try running the setup again"
    52→        return 1
    53→    fi
    54→
    55→    # Step 3: Verify we got the refresh token
    56→    local refresh_token_file="${TOKENS_DIR}/${email}_refresh_only.txt"
    57→    if [[ ! -f "$refresh_token_file" ]]; then
    58→        error "Refresh token not found after authentication"
    59→        error "This should not happen - please report this issue"
    60→        return 1
    61→    fi
    62→
    63→    info "✓ OAuth tokens obtained successfully"
    64→
    65→    # Step 4: Store account metadata
    66→    info "[4/4] Storing account metadata..."
    67→    "$STORE_SCRIPT" store "$email" "$account_name" "Exchange" "$api_scope"
    68→
    69→    success "Account setup complete: $email"
    70→    success "Credentials stored in: $CREDS_DIR"
    71→
    72→    # Show token expiration info
    73→    local access_token_file="${TOKENS_DIR}/${email}_access_token.json"
    74→    if [[ -f "$access_token_file" ]]; then
    75→        local expires_at
    76→        expires_at=$(jq -r '.expires_at // "unknown"' "$access_token_file")
    77→        info "Access token expires at: $expires_at"
    78→        info "Refresh token will be used to obtain new access tokens automatically"
    79→    fi
    80→}
    81→
    82→# Function to refresh all stored accounts
    83→refresh_all_accounts() {
    84→    info "Refreshing tokens for all stored accounts..."
    85→
    86→    local metadata_dir="${CREDS_DIR}/metadata"
    87→    if [[ ! -d "$metadata_dir" ]]; then
    88→        error "No accounts found"
    89→        return 1
    90→    fi
    91→
    92→    local count=0
    93→    local success_count=0
    94→    local fail_count=0
    95→
    96→    for metadata_file in "$metadata_dir"/*_metadata.json; do
    97→        if [[ ! -f "$metadata_file" ]]; then
    98→            continue
    99→        fi
   100→
   101→        ((count++))
   102→
   103→        local email
   104→        email=$(jq -r '.email' "$metadata_file")
   105→
   106→        info "[$count] Refreshing: $email"
   107→
   108→        if "$REFRESH_SCRIPT" "$email" "" refresh >/dev/null 2>&1; then
   109→            ((success_count++))
   110→            success "  ✓ Refreshed successfully"
   111→        else
   112→            ((fail_count++))
   113→            error "  ✗ Failed to refresh"
   114→        fi
   115→    done
   116→
   117→    echo ""
   118→    info "Refresh complete: $success_count succeeded, $fail_count failed out of $count total"
   119→}
   120→
   121→# Function to get access token for API use
   122→get_token_for_api() {
   123→    local email="$1"
   124→    local scope="${2:-https://graph.microsoft.com/.default}"
   125→    local force_refresh="${3:-false}"
   126→    local api_type="${4:-graph}"  # graph or outlook
   127→
   128→    # Check if account exists
   129→    local metadata_file="${CREDS_DIR}/metadata/${email}_metadata.json"
   130→    if [[ ! -f "$metadata_file" ]]; then
   131→        error "Account not configured: $email"
   132→        info "Run: $0 setup $email"
   133→        return 1
   134→    fi
   135→
   136→    # Determine correct token file based on API type
   137→    local token_suffix=""
   138→    if [[ "$api_type" == "outlook" ]]; then
   139→        token_suffix="_outlook"
   140→        # Default to Outlook scope if not specified
   141→        if [[ "$scope" == "https://graph.microsoft.com/.default" ]]; then
   142→            scope="https://outlook.office365.com/.default"
   143→        fi
   144→    fi
   145→
   146→    # Get or refresh access token
   147→    if [[ "$force_refresh" == "true" ]]; then
   148→        "$REFRESH_SCRIPT" "$email" "$scope" refresh "$api_type"
   149→    else
   150→        "$REFRESH_SCRIPT" "$email" "$scope" get "$api_type"
   151→    fi
   152→}
   153→
   154→# Function to test authentication with API call
   155→test_auth() {
   156→    local email="$1"
   157→
   158→    info "Testing authentication for: $email"
   159→
   160→    # Get access token
   161→    local access_token
   162→    # Explicitly request Graph scope for the test API call
   163→    if ! access_token=$(get_token_for_api "$email" "https://graph.microsoft.com/.default" 2>/dev/null); then
   164→        error "Could not get access token"
   165→        return 1
   166→    fi
   167→
   168→    # Test with a simple API call to Microsoft Graph API
   169→    info "Making test API call to Microsoft Graph API..."
   170→
   171→    local response
   172→    local http_code
   173→
   174→    response=$(curl -s -w "\n%{http_code}" \
   175→        -H "Authorization: Bearer $access_token" \
   176→        -H "Content-Type: application/json" \
   177→        "https://graph.microsoft.com/v1.0/me")
   178→
   179→    http_code=$(echo "$response" | tail -n1)
   180→    local body=$(echo "$response" | sed '$d')
   181→
   182→    if [[ "$http_code" == "200" ]]; then
   183→        success "Authentication successful!"
   184→
   185→        if echo "$body" | jq -e . &>/dev/null 2>&1; then
   186→            local display_name
   187→            local email_address
   188→            local user_id
   189→            local job_title
   190→            local office_location
   191→
   192→            display_name=$(echo "$body" | jq -r '.displayName // "N/A"')
   193→            email_address=$(echo "$body" | jq -r '.userPrincipalName // "N/A"')
   194→            user_id=$(echo "$body" | jq -r '.id // "N/A"')
   195→            job_title=$(echo "$body" | jq -r '.jobTitle // "N/A"')
   196→            office_location=$(echo "$body" | jq -r '.officeLocation // "N/A"')
   197→
   198→            echo ""
   199→            echo "User Information:"
   200→            echo "  Display Name: $display_name"
   201→            echo "  Email: $email_address"
   202→            echo "  User ID: $user_id"
   203→            echo "  Job Title: $job_title"
   204→            echo "  Office Location: $office_location"
   205→        fi
   206→    else
   207→        error "Authentication failed with HTTP $http_code"
   208→        if echo "$body" | jq -e . &>/dev/null 2>&1; then
   209→            local error_msg
   210→            error_msg=$(echo "$body" | jq -r '.error.message // .error // "Unknown error"')
   211→            error "Error: $error_msg"
   212→        else
   213→            error "Response: $body"
   214→        fi
   215→        return 1
   216→    fi
   217→}
   218→
   219→# Function to show account status
   220→show_status() {
   221→    local email="${1:-}"
   222→
   223→    if [[ -n "$email" ]]; then
   224→        # Show status for specific account
   225→        info "Status for: $email"
   226→
   227→        local metadata_file="${CREDS_DIR}/metadata/${email}_metadata.json"
   228→        if [[ ! -f "$metadata_file" ]]; then
   229→            error "Account not found: $email"
   230→            return 1
   231→        fi
   232→
   233→        # Show metadata
   234→        echo ""
   235→        echo "Account Details:"
   236→        jq . "$metadata_file"
   237→
   238→        # Show token status
   239→        echo ""
   240→        echo "Token Status:"
   241→        if "$REFRESH_SCRIPT" "$email" "" check 2>&1; then
   242→            success "Access token is valid"
   243→        else
   244→            warn "Access token needs refresh"
   245→        fi
   246→
   247→        # Show file locations
   248→        echo ""
   249→        echo "File Locations:"
   250→        echo "  Metadata: $metadata_file"
   251→        echo "  Access Token: ${TOKENS_DIR}/${email}_access_token.json"
   252→        echo "  Refresh Token: ${TOKENS_DIR}/${email}_refresh_only.txt"
   253→    else
   254→        # Show status for all accounts
   255→        "$STORE_SCRIPT" list
   256→    fi
   257→}
   258→
   259→# Function to interactive setup
   260→interactive_setup() {
   261→    echo "=== Outlook OAuth Credential Setup ==="
   262→    echo ""
   263→
   264→    # Get email
   265→    read -p "Enter email address: " email
   266→
   267→    if [[ -z "$email" ]]; then
   268→        error "Email address is required"
   269→        return 1
   270→    fi
   271→
   272→    # Get account name (optional)
   273→    read -p "Enter account name (default: $email): " account_name
   274→    account_name="${account_name:-$email}"
   275→
   276→    echo ""
   277→    setup_account "$email" "$account_name"
   278→
   279→    echo ""
   280→    echo "Would you like to test the authentication? (y/n)"
   281→    read -r test_response
   282→
   283→    if [[ "$test_response" == "y" || "$test_response" == "Y" ]]; then
   284→        echo ""
   285→        test_auth "$email"
   286→    fi
   287→}
   288→
   289→# Main execution
   290→main() {
   291→    local command="${1:-}"
   292→
   293→    case "$command" in
   294→        setup)
   295→            if [[ -z "${2:-}" ]]; then
   296→                interactive_setup
   297→            else
   298→                setup_account "${2}" "${3:-${2}}" "${4:-graph}"
   299→            fi
   300→            ;;
   301→
   302→        refresh)
   303→            if [[ -n "${2:-}" ]]; then
   304→                # Force refresh for specific account
   305→                get_token_for_api "${2}" "" "true"
   306→            else
   307→                refresh_all_accounts
   308→            fi
   309→            ;;
   310→
   311→        test)
   312→            test_auth "${2:-}"
   313→            ;;
   314→
   315→        status)
   316→            show_status "${2:-}"
   317→            ;;
   318→
   319→        list)
   320→            "$STORE_SCRIPT" list
   321→            ;;
   322→
   323→        get)
   324→            local email="${2:-}"
   325→            local arg3="${3:-}"
   326→            local scope=""
   327→            local api_type="graph"
   328→
   329→            # Parse --api flag (supports both --api=value and --api value)
   330→            if [[ "$arg3" == --api=* ]]; then
   331→                api_type="${arg3#*=}"
   332→            elif [[ "$arg3" == "--api" ]]; then
   333→                api_type="${4:-graph}"
   334→            fi
   335→
   336→            case "$api_type" in
   337→                outlook)
   338→                    scope="https://outlook.office365.com/.default"
   339→                    ;;
   340→                graph)
   341→                    scope="https://graph.microsoft.com/.default"
   342→                    ;;
   343→                both)
   344→                    # For 'both', default to graph but inform user they can specify
   345→                    scope="https://graph.microsoft.com/.default"
   346→                    ;;
   347→                *) 
   348→                    error "Invalid API type: $api_type. Use graph, outlook, or both."
   349→                    exit 1 
   350→                    ;;
   351→            esac
   352→
   353→            get_token_for_api "$email" "$scope" false "$api_type"
   354→            ;;
   355→
   356→        export)
   357→            "$STORE_SCRIPT" export "${2:-}"
   358→            ;;
   359→
   360→        import)
   361→            "$STORE_SCRIPT" import "${2:-}"
   362→            ;;
   363→
   364→        help|--help|-h)
   365→            cat <<EOF
   366→Outlook OAuth Authentication Helper
   367→
   368→Usage: $0 <command> [options]
   369→
   370→Commands:
   371→  setup [email] [name] [api_scope]
   372→                        - Setup credentials for an account (interactive if no email)
   373→                          api_scope: graph (default), outlook, or both
   374→                          When 'both' is specified, acquires tokens for both APIs
   375→                          in a single authentication flow
   376→  refresh [email]       - Refresh access token for account (or all if no email)
   377→  test <email>          - Test authentication with API call
   378→  status [email]        - Show account status (or all if no email)
   379→  list                  - List all configured accounts
   380→  get <email> [--api=type | --api type]
   381→                        - Get access token for account
   382→                          type: graph (default) or outlook
   383→                          Supports both --api=outlook and --api outlook formats
   384→  export [file]         - Export credentials to backup file
   385→  import <file>         - Import credentials from backup file
   386→  help                  - Show this help message
   387→
   388→Examples:
   389→  # Interactive setup
   390→  $0 setup
   391→
   392→  # Setup specific account (default: Graph API)
   393→  $0 setup user@example.com "My Work Account"
   394→
   395→  # Setup for Outlook API only
   396→  $0 setup user@example.com "My Work Account" outlook
   397→
   398→  # Setup for both Graph and Outlook APIs
   399→  $0 setup user@example.com "My Work Account" both
   400→
   401→  # Get access token (defaults to Graph)
   402→  $0 get user@example.com
   403→
   404→  # Get Outlook access token
   405→  $0 get user@example.com --api=outlook
   406→
   407→  # Test authentication
   408→  $0 test user@example.com
   409→
   410→  # Refresh all accounts
   411→  $0 refresh
   412→
   413→  # Export for backup
   414→  $0 export ~/outlook-creds-backup.tar.gz
   415→
   416→File Locations:
   417→  Config Dir:  $CREDS_DIR
   418→  Tokens:      $TOKENS_DIR
   419→  Helpers:     $SCRIPT_DIR
   420→
   421→For API usage, you can get tokens with:
   422→  curl -H "\$(helpers/auth_helper.sh get user@example.com | xargs -I {} echo "Authorization: Bearer {}")" ...
   423→
   424→Or use the store_credentials.sh helper:
   425→  \$(helpers/store_credentials.sh get user@example.com curl)
   426→EOF
   427→            ;;
   428→
   429→        *)
   430→            error "Unknown command: $command"
   431→            echo ""
   432→            echo "Run '$0 help' for usage information"
   433→            exit 1
   434→            ;;
   435→    esac
   436→}
   437→
   438→main "$@"
   439→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:03:21.111Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `/Users/hack/github/outlook-creds/scripts/extract_tokens.sh`
```
     1→#!/opt/homebrew/bin/bash
     2→# extract_tokens.sh - Extract OAuth refresh tokens from macOS Keychain
     3→# Based on Microsoft Office authentication mechanism analysis
     4→# Updated: 2026-01-04 - Corrected keychain structure based on actual findings
     5→# Requires: bash 4.0+ for associative arrays
     6→
     7→set -euo pipefail
     8→
     9→# Configuration
    10→CREDS_DIR="${HOME}/config/outlook-creds"
    11→TOKENS_DIR="${CREDS_DIR}/tokens"
    12→CACHE_DIR="${CREDS_DIR}/cache"
    13→
    14→# Logging
    15→log() { echo "[$(date '+%Y-%m-%d %I:%M:%S %p')] $*" >&2; }
    16→error() { log "ERROR: $*"; }
    17→info() { log "INFO: $*"; }
    18→debug() { log "DEBUG: $*"; }
    19→diagnostic() { log "DIAGNOSTIC: $*"; }
    20→
    21→# Create directories if they don't exist
    22→mkdir -p "$TOKENS_DIR" "$CACHE_DIR"
    23→
    24→# Known account mappings (email -> OneAuth account ID)
    25→declare -A ACCOUNT_IDS=(
    26→    ["broach@cresa.com"]="528d7916-5e28-441b-896b-1dc830ad54ff"
    27→    ["jproach@cresa.com"]="f727f309-b56c-4fec-90b8-e3255db74277"
    28→    ["broach@savills.us"]="5408a2f7-a0cc-43eb-a7f7-658838de8856"
    29→    ["jproach@savills.us"]="74b68385-32f1-4b3d-941a-a7e42b331dd5"
    30→    ["roach7@gmail.com"]="ba1295f5a3314636"
    31→)
    32→
    33→# Discover OneAuth account IDs by scanning keychain dump entries.
    34→discover_oneauth_account_ids() {
    35→    security dump-keychain 2>/dev/null | awk '
    36→        /^keychain:/ { if (svc == "OneAuthAccount" && acct != "") print acct; svc=""; acct=""; next }
    37→        /"svce"<blob>/ {
    38→            svc=$0
    39→            sub(/.*"svce"<blob>="/, "", svc)
    40→            sub(/".*/, "", svc)
    41→        }
    42→        /"acct"<blob>/ {
    43→            acct=$0
    44→            sub(/.*"acct"<blob>="/, "", acct)
    45→            sub(/".*/, "", acct)
    46→        }
    47→        END { if (svc == "OneAuthAccount" && acct != "") print acct }
    48→    ' | sort -u
    49→}
    50→
    51→# Extract login email from OneAuth metadata JSON.
    52→extract_email_from_oneauth_json() {
    53→    local json_file="$1"
    54→    local email=""
    55→
    56→    if [[ ! -f "$json_file" ]]; then
    57→        return 1
    58→    fi
    59→
    60→    if command -v jq >/dev/null 2>&1; then
    61→        email=$(jq -r '.login_name // .email // .username // ""' "$json_file" 2>/dev/null || true)
    62→    fi
    63→
    64→    if [[ -z "$email" ]]; then
    65→        email=$(grep -Eo '"login_name"\s*:\s*"[^"]+"' "$json_file" | head -1 | \
    66→            sed 's/.*"login_name"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/' || true)
    67→    fi
    68→
    69→    if [[ -z "$email" ]]; then
    70→        email=$(grep -Eo '"email"\s*:\s*"[^"]+"' "$json_file" | head -1 | \
    71→            sed 's/.*"email"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/' || true)
    72→    fi
    73→
    74→    if [[ -n "$email" ]]; then
    75→        printf "%s" "$email"
    76→        return 0
    77→    fi
    78→    return 1
    79→}
    80→
    81→# Discover OneAuth account ID for a given email by parsing keychain metadata.
    82→find_account_id_by_email() {
    83→    local email="$1"
    84→    local normalized_email
    85→    normalized_email=$(printf "%s" "$email" | tr '[:upper:]' '[:lower:]')
    86→
    87→    local account_id
    88→    while read -r account_id; do
    89→        [[ -z "$account_id" ]] && continue
    90→        local oneauth_file="${CACHE_DIR}/oneauth_${account_id}.dat"
    91→        local oneauth_json="${CACHE_DIR}/oneauth_${account_id}.json"
    92→
    93→        if extract_oneauth_account "$account_id" "$oneauth_file"; then
    94→            if parse_oneauth_metadata "$oneauth_file" "$oneauth_json"; then
    95→                local found_email
    96→                found_email=$(extract_email_from_oneauth_json "$oneauth_json" | tr '[:upper:]' '[:lower:]' || true)
    97→                if [[ -n "$found_email" ]] && [[ "$found_email" == "$normalized_email" ]]; then
    98→                    printf "%s" "$account_id"
    99→                    return 0
   100→                fi
   101→            fi
   102→        fi
   103→    done < <(discover_oneauth_account_ids)
   104→
   105→    return 1
   106→}
   107→
   108→# Resolve account ID for an email, using static mappings or keychain discovery.
   109→resolve_account_id() {
   110→    local email="$1"
   111→    local account_id="${ACCOUNT_IDS[$email]:-}"
   112→
   113→    if [[ -n "$account_id" ]]; then
   114→        printf "%s" "$account_id"
   115→        return 0
   116→    fi
   117→
   118→    info "Account not in static list, attempting keychain discovery: $email"
   119→    if account_id=$(find_account_id_by_email "$email"); then
   120→        ACCOUNT_IDS["$email"]="$account_id"
   121→        info "Discovered OneAuth account ID for $email: $account_id"
   122→        printf "%s" "$account_id"
   123→        return 0
   124→    fi
   125→
   126→    return 1
   127→}
   128→
   129→# Function to extract data from generic attribute (gena)
   130→extract_gena_data() {
   131→    local label="$1"
   132→    local output_file="$2"
   133→
   134→    info "Extracting gena attribute from: $label"
   135→
   136→    # Dump keychain and extract the gena blob for this entry
   137→    local gena_data
   138→    gena_data=$(security dump-keychain 2>/dev/null | \
   139→        grep -A 30 "\"$label\"" | \
   140→        grep "gena" | \
   141→        head -1 || true)
   142→
   143→    if [[ -n "$gena_data" ]]; then
   144→        echo "$gena_data" > "$output_file"
   145→        info "Extracted gena data to: $output_file"
   146→        return 0
   147→    fi
   148→    return 1
   149→}
   150→
   151→# Function to extract OneAuth account metadata
   152→extract_oneauth_account() {
   153→    local account_id="$1"
   154→    local output_file="$2"
   155→
   156→    info "Extracting OneAuth account: $account_id"
   157→    diagnostic "=== OneAuth Account Extraction Diagnostics ==="
   158→    diagnostic "Account ID: $account_id"
   159→    diagnostic "Output file: $output_file"
   160→    diagnostic "Query: security find-generic-password -s \"OneAuthAccount\" -a \"$account_id\" -g"
   161→
   162→    # Query keychain for OneAuthAccount entry
   163→    # Service: OneAuthAccount, Account: <account-id>
   164→    local metadata
   165→    local query_result
   166→    if metadata=$(security find-generic-password -s "OneAuthAccount" -a "$account_id" -g 2>&1); then
   167→        query_result="SUCCESS"
   168→        echo "$metadata" > "$output_file"
   169→
   170→        diagnostic "Query result: $query_result"
   171→        diagnostic "Metadata length: ${#metadata} bytes"
   172→        diagnostic "Output file created: $output_file"
   173→
   174→        # Check if gena attribute exists
   175→        if echo "$metadata" | grep -q "gena"; then
   176→            diagnostic "✓ Found 'gena' attribute in metadata"
   177→            local gena_preview=$(echo "$metadata" | grep "gena" | head -c 200)
   178→            diagnostic "gena preview: ${gena_preview}..."
   179→        else
   180→            diagnostic "✗ NO 'gena' attribute found in metadata"
   181→            diagnostic "Available attributes:"
   182→            echo "$metadata" | grep "^    \"" | sed 's/^/DIAGNOSTIC: /' >&2
   183→        fi
   184→
   185→        info "Extracted OneAuth metadata to: $output_file"
   186→        return 0
   187→    else
   188→        query_result="FAILED"
   189→        diagnostic "Query result: $query_result"
   190→        diagnostic "Exit code: $?"
   191→        diagnostic "Error output: $metadata"
   192→
   193→        # Try to find what accounts exist
   194→        diagnostic "Attempting to list all OneAuthAccount entries..."
   195→        local all_accounts
   196→        if all_accounts=$(security dump-keychain 2>&1 | grep -B 5 "OneAuthAccount" | head -50); then
   197→            diagnostic "Found OneAuthAccount entries in keychain:"
   198→            echo "$all_accounts" | sed 's/^/DIAGNOSTIC: /' >&2
   199→        else
   200→            diagnostic "No OneAuthAccount entries found in keychain dump"
   201→        fi
   202→
   203→        error "Could not find OneAuth entry for account: $account_id"
   204→        diagnostic "=== End OneAuth Diagnostics ==="
   205→        return 1
   206→    fi
   207→}
   208→
   209→# Function to extract Exchange credentials
   210→extract_exchange_entry() {
   211→    local email="$1"
   212→    local output_file="$2"
   213→
   214→    # Exchange entries use format: email@outlook.office365.com
   215→    local exchange_account="${email}@outlook.office365.com"
   216→
   217→    info "Extracting Exchange entry for: $exchange_account"
   218→    diagnostic "=== Exchange Entry Extraction Diagnostics ==="
   219→    diagnostic "Email: $email"
   220→    diagnostic "Exchange account: $exchange_account"
   221→    diagnostic "Output file: $output_file"
   222→    diagnostic "Query: security find-generic-password -l \"Exchange\" -a \"$exchange_account\" -g"
   223→
   224→    local exchange_data
   225→    local query_result
   226→    if exchange_data=$(security find-generic-password -l "Exchange" -a "$exchange_account" -g 2>&1); then
   227→        query_result="SUCCESS"
   228→        echo "$exchange_data" > "$output_file"
   229→
   230→        diagnostic "Query result: $query_result"
   231→        diagnostic "Data length: ${#exchange_data} bytes"
   232→        diagnostic "Output file created: $output_file"
   233→
   234→        # Check for password field
   235→        if echo "$exchange_data" | grep -q "password:"; then
   236→            diagnostic "✓ Found password field in Exchange entry"
   237→        else
   238→            diagnostic "✗ NO password field found"
   239→        fi
   240→
   241→        info "Extracted Exchange data to: $output_file"
   242→        diagnostic "=== End Exchange Diagnostics ==="
   243→        return 0
   244→    else
   245→        query_result="FAILED"
   246→        diagnostic "Query result: $query_result"
   247→        diagnostic "Exit code: $?"
   248→
   249→        # Try alternate queries
   250→        diagnostic "Attempting alternate Exchange queries..."
   251→
   252→        # Try without @outlook.office365.com suffix
   253→        diagnostic "Trying with email only: $email"
   254→        if security find-generic-password -l "Exchange" -a "$email" -g 2>&1 >/dev/null; then
   255→            diagnostic "✓ Found with email only (without @outlook.office365.com)"
   256→        else
   257→            diagnostic "✗ Not found with email only"
   258→        fi
   259→
   260→        # Try to find what Exchange entries exist
   261→        diagnostic "Searching for all Exchange entries in keychain..."
   262→        local all_exchange
   263→        if all_exchange=$(security dump-keychain 2>&1 | grep -B 5 "Exchange" | head -50); then
   264→            diagnostic "Found Exchange entries:"
   265→            echo "$all_exchange" | sed 's/^/DIAGNOSTIC: /' >&2
   266→        else
   267→            diagnostic "No Exchange entries found in keychain dump"
   268→        fi
   269→
   270→        error "Could not find Exchange entry for: $exchange_account"
   271→        diagnostic "=== End Exchange Diagnostics ==="
   272→        return 1
   273→    fi
   274→}
   275→
   276→# Function to extract Office Identity Settings (contains encrypted tokens)
   277→extract_office_identity_settings() {
   278→    local output_file="$1"
   279→
   280→    info "Extracting Microsoft Office Identities Settings..."
   281→    diagnostic "=== Office Identity Settings Extraction ==="
   282→    diagnostic "Query: security find-generic-password -l \"Microsoft Office Identities Settings 3\" -g"
   283→
   284→    local settings_data
   285→    if settings_data=$(security find-generic-password -l "Microsoft Office Identities Settings 3" -g 2>&1); then
   286→        echo "$settings_data" > "$output_file"
   287→
   288→        diagnostic "✓ Successfully extracted settings data (${#settings_data} bytes)"
   289→        diagnostic "Output file: $output_file"
   290→
   291→        # Check for password data (the encrypted blob)
   292→        if echo "$settings_data" | grep -q "password:"; then
   293→            diagnostic "✓ Found password field (encrypted identity data)"
   294→
   295→            # Try to extract the password hex blob
   296→            local password_hex
   297→            password_hex=$(echo "$settings_data" | grep "password:" | sed 's/password: 0x\([0-9A-Fa-f]*\).*/\1/' || true)
   298→
   299→            if [[ -n "$password_hex" ]]; then
   300→                diagnostic "✓ Extracted password hex (${#password_hex} hex chars = $((${#password_hex}/2)) bytes)"
   301→
   302→                # Save the hex blob to a separate file
   303→                local hex_file="${output_file}.hex"
   304→                echo "$password_hex" > "$hex_file"
   305→                diagnostic "✓ Saved hex to: $hex_file"
   306→
   307→                # Try to decode it (will be encrypted binary plist)
   308→                local decoded_file="${output_file}.bin"
   309→                if echo "$password_hex" | xxd -r -p > "$decoded_file" 2>/dev/null; then
   310→                    diagnostic "✓ Decoded hex to binary: $decoded_file"
   311→                    diagnostic "Binary file size: $(wc -c < "$decoded_file") bytes"
   312→
   313→                    # Check if it's a binary plist
   314→                    local file_type
   315→                    file_type=$(file "$decoded_file")
   316→                    diagnostic "File type: $file_type"
   317→
   318→                    # plutil can handle binary plists directly
   319→                    if true; then
   320→                        diagnostic "✓ Detected binary plist format"
   321→
   322→                        # Try to convert to XML plist
   323→                        local xml_file="${output_file}.plist"
   324→                        if plutil -convert xml1 -o "$xml_file" "$decoded_file" 2>&1; then
   325→                            diagnostic "✓ Converted to XML plist: $xml_file"
   326→                            diagnostic "Plist file size: $(wc -c < "$xml_file") bytes"
   327→
   328→                            # Preview the plist structure
   329→                            if command -v head >/dev/null 2>&1; then
   330→                                diagnostic "Plist preview (first 30 lines):"
   331→                                head -30 "$xml_file" | sed 's/^/DIAGNOSTIC:   /' >&2
   332→                            fi
   333→                        else
   334→                            diagnostic "✗ Failed to convert to XML (may be encrypted or corrupted)"
   335→                            diagnostic "plutil error: $?"
   336→                        fi
   337→                    else
   338→                        diagnostic "⚠ Not a plist format"
   339→                    fi
   340→                else
   341→                    diagnostic "✗ Failed to decode hex blob"
   342→                fi
   343→            else
   344→                diagnostic "✗ Could not extract password hex from output"
   345→            fi
   346→        else
   347→            diagnostic "✗ No password field found in settings data"
   348→        fi
   349→
   350→        info "Extracted Office Identity Settings to: $output_file"
   351→        diagnostic "=== End Office Identity Settings Extraction ==="
   352→        return 0
   353→    else
   354→        diagnostic "✗ Query failed"
   355→        error "Could not find Microsoft Office Identities Settings"
   356→        diagnostic "=== End Office Identity Settings Extraction ==="
   357→        return 1
   358→    fi
   359→}
   360→
   361→# Function to extract tokens from Office Identity Settings plist
   362→extract_tokens_from_plist() {
   363→    local plist_file="$1"
   364→    local output_json="$2"
   365→    local account_id="$3"
   366→
   367→    diagnostic "=== Token Extraction from Plist ==="
   368→    diagnostic "Input plist: $plist_file"
   369→    diagnostic "Output JSON: $output_json"
   370→    diagnostic "Account ID: $account_id"
   371→
   372→    if [[ ! -f "$plist_file" ]]; then
   373→        diagnostic "✗ Plist file not found"
   374→        return 1
   375→    fi
   376→
   377→    # Search for token-related keys in the plist
   378→    # Common keys: access_token, refresh_token, id_token, expires_on
   379→    local tokens_found=false
   380→
   381→    # Try to extract IdentityDocuments array
   382→    if plutil -extract IdentityDocuments xml1 -o - "$plist_file" 2>/dev/null | grep -q "dict"; then
   383→        diagnostic "✓ Found IdentityDocuments in plist"
   384→
   385→        # Try to extract specific account's identity document
   386→        # Format is typically: {account_id}_ADAL
   387→        local account_key="${account_id}_ADAL"
   388→        diagnostic "Searching for identity document key: $account_key"
   389→
   390→        # Try to extract that specific document
   391→        if plutil -extract "IdentityDocuments.$account_key" xml1 -o - "$plist_file" 2>/dev/null > "${output_json}.partial"; then
   392→            diagnostic "✓ Found identity document for account"
   393→
   394→            # Check if it contains token fields
   395→            if grep -q "access_token\|refresh_token\|token" "${output_json}.partial"; then
   396→                diagnostic "✓ Found token fields in identity document"
   397→                tokens_found=true
   398→
   399→                # Try to extract specific tokens
   400→                for token_type in "access_token" "refresh_token" "id_token"; do
   401→                    local token_value
   402→                    token_value=$(plutil -extract "IdentityDocuments.$account_key.$token_type" raw -o - "$plist_file" 2>/dev/null || true)
   403→
   404→                    if [[ -n "$token_value" ]]; then
   405→                        diagnostic "✓ Extracted $token_type (${#token_value} chars)"
   406→                        echo "$token_type: $token_value" >> "$output_json"
   407→                    fi
   408→                done
   409→            else
   410→                diagnostic "⚠ Identity document found but contains no token fields"
   411→                diagnostic "Document may be encrypted or use different structure"
   412→            fi
   413→        else
   414→            diagnostic "✗ Could not extract identity document for key: $account_key"
   415→        fi
   416→    else
   417→        diagnostic "⚠ No IdentityDocuments found in plist"
   418→    fi
   419→
   420→    # Alternative: search for any dict containing "token" or "refresh"
   421→    if [[ "$tokens_found" == "false" ]]; then
   422→        diagnostic "Attempting broad token search in plist..."
   423→
   424→        if grep -i "token\|refresh" "$plist_file" > "${output_json}.grep" 2>/dev/null; then
   425→            diagnostic "✓ Found token-related text in plist"
   426→            diagnostic "Preview:"
   427→            head -5 "${output_json}.grep" | sed 's/^/DIAGNOSTIC:   /' >&2
   428→        else
   429→            diagnostic "✗ No token-related text found in plist"
   430→        fi
   431→    fi
   432→
   433→    diagnostic "=== End Token Extraction ==="
   434→
   435→    if [[ "$tokens_found" == "true" ]] && [[ -f "$output_json" ]] && [[ -s "$output_json" ]]; then
   436→        info "Extracted tokens to: $output_json"
   437→        return 0
   438→    else
   439→        diagnostic "✗ No tokens extracted from plist"
   440→        return 1
   441→    fi
   442→}
   443→
   444→# Function to parse OneAuth gena blob for token info
   445→parse_oneauth_metadata() {
   446→    local metadata_file="$1"
   447→    local output_json="$2"
   448→
   449→    info "Parsing OneAuth metadata..."
   450→    diagnostic "=== OneAuth Metadata Parsing Diagnostics ==="
   451→    diagnostic "Input file: $metadata_file"
   452→    diagnostic "Output JSON: $output_json"
   453→
   454→    # Check if input file exists
   455→    if [[ ! -f "$metadata_file" ]]; then
   456→        diagnostic "✗ Input file does not exist: $metadata_file"
   457→        error "Cannot parse metadata: file not found"
   458→        diagnostic "=== End Parsing Diagnostics ==="
   459→        return 1
   460→    fi
   461→
   462→    diagnostic "✓ Input file exists ($(wc -c < "$metadata_file") bytes)"
   463→
   464→    # Show the gena line from the file
   465→    local gena_line
   466→    gena_line=$(grep "gena" "$metadata_file" || true)
   467→
   468→    if [[ -z "$gena_line" ]]; then
   469→        diagnostic "✗ NO 'gena' line found in metadata file"
   470→        diagnostic "File contents preview:"
   471→        head -20 "$metadata_file" | sed 's/^/DIAGNOSTIC: /' >&2
   472→        error "Cannot parse metadata: no 'gena' attribute found"
   473→        diagnostic "=== End Parsing Diagnostics ==="
   474→        return 1
   475→    fi
   476→
   477→    diagnostic "✓ Found 'gena' line in file"
   478→    diagnostic "gena line preview: ${gena_line:0:200}..."
   479→
   480→    # Extract the gena hex blob and decode it
   481→    # Format is: "gena"<blob>=0x[HEXDATA]  "[ASCII]"
   482→    # We need to extract just the hex part between 0x and the two spaces
   483→    local gena_hex
   484→    gena_hex=$(echo "$gena_line" | sed 's/.*=0x\([0-9A-Fa-f]*\)  .*/\1/' || true)
   485→
   486→    if [[ -z "$gena_hex" ]]; then
   487→        diagnostic "✗ Failed to extract hex data from gena line"
   488→        diagnostic "Expected format: 'gena'<blob>=0x[HEXDATA]"
   489→        diagnostic "Actual line: $gena_line"
   490→        error "Cannot parse metadata: failed to extract hex blob"
   491→        diagnostic "=== End Parsing Diagnostics ==="
   492→        return 1
   493→    fi
   494→
   495→    diagnostic "✓ Extracted hex blob (${#gena_hex} hex chars = $((${#gena_hex}/2)) bytes)"
   496→    diagnostic "Hex preview: ${gena_hex:0:100}..."
   497→
   498→    # Decode hex to text (the gena contains JSON)
   499→    if echo "$gena_hex" | xxd -r -p > "$output_json" 2>/dev/null; then
   500→        diagnostic "✓ Successfully decoded hex to file: $output_json"
   501→        diagnostic "Output file size: $(wc -c < "$output_json") bytes"
   502→
   503→        # Validate it's JSON
   504→        if command -v jq >/dev/null 2>&1; then
   505→            if jq -e . "$output_json" >/dev/null 2>&1; then
   506→                diagnostic "✓ Output is valid JSON"
   507→                diagnostic "JSON preview:"
   508→                jq -r 'keys | .[]' "$output_json" 2>/dev/null | head -10 | sed 's/^/DIAGNOSTIC:   - /' >&2
   509→            else
   510→                diagnostic "⚠ Output file exists but is not valid JSON"
   511→                diagnostic "First 200 chars:"
   512→                head -c 200 "$output_json" | sed 's/^/DIAGNOSTIC: /' >&2
   513→            fi
   514→        else
   515→            diagnostic "⚠ jq not available, cannot validate JSON"
   516→            diagnostic "First 200 chars:"
   517→            head -c 200 "$output_json" | sed 's/^/DIAGNOSTIC: /' >&2
   518→        fi
   519→
   520→        info "Decoded OneAuth metadata to: $output_json"
   521→        diagnostic "=== End Parsing Diagnostics ==="
   522→        return 0
   523→    else
   524→        diagnostic "✗ xxd decode failed"
   525→        diagnostic "Exit code: $?"
   526→        error "Failed to decode hex blob to JSON"
   527→        diagnostic "=== End Parsing Diagnostics ==="
   528→        return 1
   529→    fi
   530→}
   531→
   532→# Function to search for all Microsoft Office related keychain entries
   533→find_microsoft_entries() {
   534→    info "Searching for Microsoft Office keychain entries..."
   535→
   536→    # Search for common Microsoft Office keychain entries
   537→    local entries=(
   538→        "Microsoft Office Identities Settings 3"
   539→        "Microsoft Office Identities Cache 3"
   540→        "com.microsoft.OutlookCore.SecretV2"
   541→        "Microsoft Office Data"
   542→    )
   543→
   544→    local found_count=0
   545→
   546→    for entry in "${entries[@]}"; do
   547→        local output_file="${CACHE_DIR}/${entry//[^a-zA-Z0-9]/_}.dat"
   548→
   549→        if security find-generic-password -l "$entry" -g 2>&1 > "$output_file"; then
   550→            ((found_count++))
   551→            info "Found: $entry -> $output_file"
   552→        fi
   553→    done
   554→
   555→    # Also search for OneAuth accounts
   556→    info "Searching for OneAuth accounts..."
   557→    for email in "${!ACCOUNT_IDS[@]}"; do
   558→        local account_id="${ACCOUNT_IDS[$email]}"
   559→        local output_file="${CACHE_DIR}/oneauth_${account_id}.dat"
   560→
   561→        if extract_oneauth_account "$account_id" "$output_file"; then
   562→            ((found_count++))
   563→        fi
   564→    done
   565→
   566→    if [[ $found_count -eq 0 ]]; then
   567→        error "No Microsoft Office keychain entries found"
   568→        return 1
   569→    fi
   570→
   571→    info "Found $found_count Microsoft Office keychain entries"
   572→    return 0
   573→}
   574→
   575→# Function to extract all available data for an account
   576→extract_account_tokens() {
   577→    local email="$1"
   578→    local token_dir="${TOKENS_DIR}/${email//[@.]/_}"
   579→
   580→    mkdir -p "$token_dir"
   581→
   582→    info "Extracting all available data for: $email"
   583→    diagnostic "========================================"
   584→    diagnostic "=== EXTRACTION SUMMARY FOR: $email ==="
   585→    diagnostic "========================================"
   586→
   587→    # Resolve account ID from static list or keychain discovery
   588→    local account_id
   589→    if ! account_id=$(resolve_account_id "$email"); then
   590→        error "Unknown account: $email"
   591→        info "Known accounts: ${!ACCOUNT_IDS[*]}"
   592→        diagnostic "Extraction failed: account not in known accounts list or keychain discovery"
   593→        diagnostic "========================================"
   594→        return 1
   595→    fi
   596→
   597→    diagnostic "Account ID: $account_id"
   598→    diagnostic "Output directory: $token_dir"
   599→
   600→    # Track extraction status
   601→    local oneauth_status="FAILED"
   602→    local oneauth_parse_status="FAILED"
   603→    local exchange_status="FAILED"
   604→    local office_settings_status="FAILED"
   605→
   606→    # Extract OneAuth account metadata
   607→    local oneauth_file="${token_dir}/oneauth_metadata.txt"
   608→    if extract_oneauth_account "$account_id" "$oneauth_file"; then
   609→        oneauth_status="SUCCESS"
   610→
   611→        # Try to parse the JSON from gena blob
   612→        if parse_oneauth_metadata "$oneauth_file" "${token_dir}/account_info.json"; then
   613→            oneauth_parse_status="SUCCESS"
   614→
   615→            # Extract JWT token claims from account_info.json to tokens.json
   616→            diagnostic "Extracting JWT token claims from account_info.json..."
   617→            local account_info_file="${token_dir}/account_info.json"
   618→            local tokens_output="${token_dir}/tokens.json"
   619→
   620→            if [[ -f "$account_info_file" ]] && command -v jq >/dev/null 2>&1; then
   621→                # Extract additional_properties which contains JWT claims
   622→                local jwt_claims
   623→                jwt_claims=$(jq -r '.additional_properties' "$account_info_file" 2>/dev/null || echo "")
   624→
   625→                if [[ -n "$jwt_claims" ]] && [[ "$jwt_claims" != "null" ]]; then
   626→                    # Parse the nested JSON string
   627→                    local parsed_claims
   628→                    parsed_claims=$(echo "$jwt_claims" | jq -e '.' 2>/dev/null || echo "")
   629→
   630→                    if [[ -n "$parsed_claims" ]]; then
   631→                        # Check if it contains JWT token fields (exp, iat, aud, etc.)
   632→                        local has_exp has_iat has_aud
   633→                        has_exp=$(echo "$parsed_claims" | jq -e '.exp' >/dev/null 2>&1 && echo "yes" || echo "no")
   634→                        has_iat=$(echo "$parsed_claims" | jq -e '.iat' >/dev/null 2>&1 && echo "yes" || echo "no")
   635→                        has_aud=$(echo "$parsed_claims" | jq -e '.aud' >/dev/null 2>&1 && echo "yes" || echo "no")
   636→
   637→                        if [[ "$has_exp" == "yes" ]] && [[ "$has_iat" == "yes" ]] && [[ "$has_aud" == "yes" ]]; then
   638→                            # This is a valid JWT ID token - extract it
   639→                            diagnostic "✓ Found valid JWT ID token claims in additional_properties"
   640→
   641→                            # Create tokens.json with the JWT claims
   642→                            cat > "$tokens_output" <<TOKENJSON
   643→{
   644→  "token_type": "id_token",
   645→  "source": "oneauth_keychain_cache",
   646→  "extracted_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
   647→  "jwt_claims": $parsed_claims
   648→}
   649→TOKENJSON
   650→                            diagnostic "✓ Wrote JWT token claims to tokens.json"
   651→                        else
   652→                            diagnostic "⚠ additional_properties exists but doesn't contain valid JWT claims"
   653→                        fi
   654→                    else
   655→                        diagnostic "⚠ Could not parse additional_properties as JSON"
   656→                    fi
   657→                else
   658→                    diagnostic "⚠ No additional_properties found in account_info.json"
   659→                fi
   660→            else
   661→                if [[ ! -f "$account_info_file" ]]; then
   662→                    diagnostic "⚠ account_info.json not found"
   663→                else
   664→                    diagnostic "⚠ jq not available for JSON parsing"
   665→                fi
   666→            fi
   667→        else
   668→            oneauth_parse_status="FAILED"
   669→            diagnostic "⚠ OneAuth metadata extracted but parsing failed"
   670→        fi
   671→    else
   672→        oneauth_status="FAILED"
   673→        diagnostic "✗ OneAuth metadata extraction failed"
   674→    fi
   675→
   676→    # Extract Exchange entry
   677→    if extract_exchange_entry "$email" "${token_dir}/exchange_entry.txt"; then
   678→        exchange_status="SUCCESS"
   679→    else
   680→        exchange_status="FAILED"
   681→        diagnostic "✗ Exchange entry extraction failed"
   682→    fi
   683→
   684→    # Extract Office Identity Settings (contains encrypted tokens)
   685→    local office_settings_file="${token_dir}/office_identity_settings.txt"
   686→    if extract_office_identity_settings "$office_settings_file"; then
   687→        office_settings_status="SUCCESS"
   688→
   689→        # Try to extract tokens from the plist if it was successfully converted
   690→        local plist_file="${office_settings_file}.plist"
   691→        if [[ -f "$plist_file" ]]; then
   692→            diagnostic "Attempting to extract tokens from plist..."
   693→            extract_tokens_from_plist "$plist_file" "${token_dir}/tokens.json" "$account_id" || true
   694→        fi
   695→    else
   696→        office_settings_status="FAILED"
   697→        diagnostic "✗ Office Identity Settings extraction failed"
   698→    fi
   699→
   700→    # Also try the Office Identity Cache (may contain unencrypted tokens)
   701→    diagnostic "Attempting to extract Office Identity Cache 3..."
   702→    local cache_settings
   703→    if cache_settings=$(security find-generic-password -l "Microsoft Office Identities Cache 3" -g 2>&1); then
   704→        local cache_file="${token_dir}/office_identity_cache.txt"
   705→        echo "$cache_settings" > "$cache_file"
   706→        diagnostic "✓ Extracted Office Identity Cache to: $cache_file"
   707→
   708→        # Try to extract and convert the cache
   709→        local cache_hex
   710→        cache_hex=$(echo "$cache_settings" | grep "password:" | sed 's/password: 0x\([0-9A-Fa-f]*\).*/\1/' || true)
   711→
   712→        if [[ -n "$cache_hex" ]]; then
   713→            local cache_bin="${cache_file}.bin"
   714→            if echo "$cache_hex" | xxd -r -p > "$cache_bin" 2>/dev/null; then
   715→                diagnostic "✓ Decoded cache to binary: $cache_bin"
   716→
   717→                # Try to convert to plist
   718→                local cache_plist="${cache_file}.plist"
   719→                if plutil -convert xml1 -o "$cache_plist" "$cache_bin" 2>&1; then
   720→                    diagnostic "✓ Converted cache to XML plist: $cache_plist"
   721→
   722→                    # Try to extract tokens from cache
   723→                    extract_tokens_from_plist "$cache_plist" "${token_dir}/cache_tokens.json" "$account_id" || true
   724→                fi
   725→            fi
   726→        fi
   727→    else
   728→        diagnostic "⚠ Could not find Office Identity Cache 3"
   729→    fi
   730→
   731→    # Create comprehensive summary
   732→    diagnostic "========================================"
   733→    diagnostic "=== EXTRACTION RESULTS ==="
   734→    diagnostic "Email: $email"
   735→    diagnostic "Account ID: $account_id"
   736→    diagnostic ""
   737→    diagnostic "Extraction Status:"
   738→    diagnostic "  OneAuth Metadata:      $oneauth_status"
   739→    diagnostic "  OneAuth Parsing:       $oneauth_parse_status"
   740→    diagnostic "  Exchange Entry:        $exchange_status"
   741→    diagnostic "  Office Settings:       $office_settings_status"
   742→    diagnostic ""
   743→
   744→    # Check if tokens.json or cache_tokens.json was created
   745→    local tokens_file="${token_dir}/tokens.json"
   746→    local cache_tokens_file="${token_dir}/cache_tokens.json"
   747→    local tokens_extracted="NO"
   748→
   749→    # Check both possible token files
   750→    if [[ -f "$cache_tokens_file" ]] && [[ -s "$cache_tokens_file" ]]; then
   751→        tokens_file="$cache_tokens_file"
   752→        tokens_extracted="YES"
   753→        diagnostic "✓ SUCCESS: OAuth tokens extracted to cache_tokens.json"
   754→        diagnostic ""
   755→        diagnostic "TOKEN CONTENTS:"
   756→        cat "$tokens_file" | sed 's/^/DIAGNOSTIC:   /' >&2
   757→        diagnostic ""
   758→    elif [[ -f "$tokens_file" ]] && [[ -s "$tokens_file" ]]; then
   759→        tokens_extracted="YES"
   760→        diagnostic "✓ SUCCESS: OAuth tokens extracted to tokens.json"
   761→        diagnostic ""
   762→        diagnostic "TOKEN CONTENTS:"
   763→        cat "$tokens_file" | sed 's/^/DIAGNOSTIC:   /' >&2
   764→        diagnostic ""
   765→    else
   766→        diagnostic "✗ FAILURE: OAuth tokens NOT extracted"
   767→        diagnostic ""
   768→        diagnostic "Root Cause Analysis:"
   769→
   770→        if [[ "$office_settings_status" == "FAILED" ]]; then
   771→            diagnostic "  → Office Identity Settings keychain entry not found"
   772→            diagnostic "  → This entry contains the encrypted token cache"
   773→        elif [[ -f "${token_dir}/office_identity_settings.txt.bin" ]]; then
   774→            # Check if the binary was encrypted
   775→            if grep -q "Encrypted" "${token_dir}/office_identity_settings.txt"; then
   776→                diagnostic "  → Office Identity Settings found but data is ENCRYPTED"
   777→                diagnostic "  → Microsoft uses app-specific encryption (com.microsoft.OutlookCore.SecretV2)"
   778→                diagnostic "  → Decryption requires reverse engineering the Outlook encryption keys"
   779→                diagnostic ""
   780→                diagnostic "Alternative Approaches:"
   781→                diagnostic "  1. Use MSAL/ADAL token cache files (if accessible)"
   782→                diagnostic "  2. Intercept network traffic during OAuth flow"
   783→                diagnostic "  3. Hook into Outlook process memory"
   784→                diagnostic "  4. Use Microsoft Graph SDK with native authentication"
   785→            else
   786→                diagnostic "  → Office Identity Settings extracted but token parsing failed"
   787→                diagnostic "  → Review token extraction diagnostics above"
   788→            fi
   789→        fi
   790→    fi
   791→
   792→    diagnostic "========================================"
   793→
   794→    # Create summary JSON
   795→    local summary_file="${token_dir}/summary.json"
   796→    cat > "$summary_file" <<EOF
   797→{
   798→  "email": "$email",
   799→  "account_id": "$account_id",
   800→  "extracted_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
   801→  "extraction_status": {
   802→    "oneauth_metadata": "$oneauth_status",
   803→    "oneauth_parsing": "$oneauth_parse_status",
   804→    "exchange_entry": "$exchange_status",
   805→    "office_settings": "$office_settings_status",
   806→    "tokens_extracted": "$tokens_extracted"
   807→  },
   808→  "keychain_entries": {
   809→    "oneauth": "${token_dir}/oneauth_metadata.txt",
   810→    "exchange": "${token_dir}/exchange_entry.txt",
   811→    "account_info": "${token_dir}/account_info.json",
   812→    "office_settings": "${token_dir}/office_identity_settings.txt",
   813→    "tokens": "${tokens_file}"
   814→  },
   815→  "notes": "OAuth tokens are encrypted within Microsoft Office Identities Settings 3 entry"
   816→}
   817→EOF
   818→
   819→    info "Summary saved to: $summary_file"
   820→
   821→    # DO NOT generate mock tokens - task requires real tokens only
   822→    # Microsoft OAuth tokens are encrypted and cannot be extracted from keychain
   823→
   824→    # Print final conclusion
   825→    echo ""
   826→    echo "═══════════════════════════════════════════════════════════════"
   827→    echo "EXTRACTION COMPLETE"
   828→    echo "═══════════════════════════════════════════════════════════════"
   829→    echo ""
   830→
   831→    if [[ "$tokens_extracted" == "YES" ]]; then
   832→        echo "✓ OAuth tokens successfully extracted for: $email"
   833→        echo ""
   834→        echo "Token file: $tokens_file"
   835→        echo ""
   836→
   837→        # Check if it's a JWT token and display accordingly
   838→        if command -v jq >/dev/null 2>&1 && jq -e '.token_type == "id_token"' "$tokens_file" >/dev/null 2>&1; then
   839→            echo "TOKEN TYPE: JWT ID Token (from OneAuth cache)"
   840→            echo ""
   841→            echo "JWT CLAIMS:"
   842→            jq -r '.jwt_claims | to_entries | .[] | "  \(.key): \(.value)"' "$tokens_file" 2>/dev/null || cat "$tokens_file"
   843→        else
   844→            echo "TOKEN CONTENTS:"
   845→            cat "$tokens_file" | grep -v "^#" || true
   846→        fi
   847→
   848→        echo ""
   849→        echo "✓✓✓ TOKENS EXTRACTED SUCCESSFULLY ✓✓✓"
   850→        echo "<promise>TOKENS_EXTRACTED</promise>"
   851→    else
   852→        echo "⚠ OAuth tokens NOT extracted from keychain (encrypted by Microsoft)"
   853→        echo ""
   854→        echo "WHAT WAS EXTRACTED:"
   855→        echo "  ✓ Account metadata (ID, tenant, email, display name)"
   856→        echo "  ✓ OneAuth account information"
   857→        echo "  ✓ Exchange server configuration"
   858→        echo "  ✓ Office Identity Settings (encrypted)"
   859→    fi
   860→
   861→    echo ""
   862→    echo "All extracted data saved to: $token_dir"
   863→    echo "═══════════════════════════════════════════════════════════════"
   864→    echo ""
   865→
   866→    # Return success only if tokens were actually extracted
   867→    if [[ "$tokens_extracted" == "YES" ]]; then
   868→        info "✓ SUCCESS: OAuth tokens extracted successfully"
   869→        echo ""
   870→        echo "<promise>TOKENS_EXTRACTED</promise>"
   871→        echo ""
   872→        return 0
   873→    else
   874→        # Even though we can't extract tokens, we extracted all available data
   875→        info "Extraction complete: All available keychain data extracted"
   876→        return 1
   877→    fi
   878→}
   879→
   880→# Function to dump all keychain entries matching a pattern
   881→dump_microsoft_keychain() {
   882→    local pattern="${1:-microsoft}"
   883→    local output_file="${CACHE_DIR}/keychain_dump_${pattern}.txt"
   884→
   885→    info "Dumping all keychain entries matching: $pattern"
   886→
   887→    security dump-keychain 2>&1 | grep -i "$pattern" -A 30 -B 5 > "$output_file"
   888→
   889→    info "Dump saved to: $output_file"
   890→}
   891→
   892→# Print usage
   893→usage() {
   894→    cat <<EOF
   895→Usage: $0 [command] [options]
   896→
   897→Commands:
   898→  list                    List all known accounts and their keychain status
   899→  extract <email>         Extract all available data for an email
   900→  dump [pattern]          Dump keychain entries matching pattern (default: microsoft)
   901→  all                     Extract data for all known accounts
   902→
   903→Known accounts:
   904→EOF
   905→    for email in "${!ACCOUNT_IDS[@]}"; do
   906→        echo "  - $email"
   907→    done
   908→}
   909→
   910→# List all known accounts and check status
   911→list_accounts() {
   912→    info "Checking keychain status for known accounts..."
   913→    echo ""
   914→    printf "%-30s %-40s %s\n" "Email" "Account ID" "Status"
   915→    printf "%s\n" "--------------------------------------------------------------------------------"
   916→
   917→    for email in "${!ACCOUNT_IDS[@]}"; do
   918→        local account_id="${ACCOUNT_IDS[$email]}"
   919→        local status="NOT FOUND"
   920→
   921→        if security find-generic-password -s "OneAuthAccount" -a "$account_id" 2>/dev/null >/dev/null; then
   922→            status="FOUND"
   923→        fi
   924→
   925→        printf "%-30s %-40s %s\n" "$email" "$account_id" "$status"
   926→    done
   927→}
   928→
   929→# Main execution
   930→main() {
   931→    local cmd="${1:-}"
   932→    shift || true
   933→
   934→    case "$cmd" in
   935→        list)
   936→            list_accounts
   937→            ;;
   938→        extract)
   939→            local email="${1:-}"
   940→            if [[ -z "$email" ]]; then
   941→                error "Usage: $0 extract <email>"
   942→                usage
   943→                exit 1
   944→            fi
   945→            extract_account_tokens "$email"
   946→            ;;
   947→        dump)
   948→            local pattern="${1:-microsoft}"
   949→            dump_microsoft_keychain "$pattern"
   950→            ;;
   951→        all)
   952→            find_microsoft_entries
   953→            for email in "${!ACCOUNT_IDS[@]}"; do
   954→                extract_account_tokens "$email" || true
   955→            done
   956→            ;;
   957→        help|-h|--help)
   958→            usage
   959→            ;;
   960→        *)
   961→            if [[ -n "$cmd" && "$cmd" == *"@"* ]]; then
   962→                # Assume it's an email address
   963→                extract_account_tokens "$cmd"
   964→            else
   965→                usage
   966→            fi
   967→            ;;
   968→    esac
   969→}
   970→
   971→main "$@"
   972→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:03:21.345Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `/Users/hack/github/outlook-creds/scripts/refresh_access_token.sh`
```
     1→#!/usr/bin/env bash
     2→# refresh_access_token.sh - Use refresh token to obtain new access token via OAuth2
     3→# Microsoft OAuth2 v2.0 endpoint implementation
     4→
     5→set -euo pipefail
     6→
     7→# Configuration
     8→CREDS_DIR="${HOME}/config/outlook-creds"
     9→TOKENS_DIR="${CREDS_DIR}/tokens"
    10→
    11→# Microsoft OAuth2 Configuration
    12→# client_id for Microsoft Office (from analysis)
    13→CLIENT_ID="d3590ed6-52b3-4102-aeff-aad2292ab01c"
    14→TOKEN_ENDPOINT="https://login.microsoftonline.com/common/oauth2/v2.0/token"
    15→
    16→# Default scopes for Outlook/Office
    17→DEFAULT_SCOPES="https://outlook.office365.com/.default offline_access"
    18→
    19→# Logging
    20→log() { echo "[$(date '+%Y-%m-%d %I:%M:%S %p')] $*" >&2; }
    21→error() { log "ERROR: $*"; }
    22→info() { log "INFO: $*"; }
    23→success() { log "SUCCESS: $*"; }
    24→
    25→# Function to refresh access token using refresh token
    26→refresh_token() {
    27→    local refresh_token="$1"
    28→    local scopes="${2:-$DEFAULT_SCOPES}"
    29→    local email="${3:-unknown}"
    30→    local api_type="${4:-graph}"  # graph or outlook
    31→
    32→    local api_label="Graph"
    33→    local token_suffix=""
    34→    if [[ "$api_type" == "outlook" ]]; then
    35→        api_label="Outlook"
    36→        token_suffix="_outlook"
    37→    fi
    38→
    39→    info "Refreshing $api_label access token for: $email"
    40→    info "Using scopes: $scopes"
    41→
    42→    # Prepare the POST data
    43→    local post_data
    44→    post_data=$(cat <<EOF
    45→client_id=${CLIENT_ID}&grant_type=refresh_token&refresh_token=${refresh_token}&scope=${scopes// /%20}
    46→EOF
    47→)
    48→
    49→    # Make the OAuth2 request
    50→    local response
    51→    local http_code
    52→
    53→    response=$(curl -s -w "\n%{http_code}" \
    54→        -X POST \
    55→        -H "Content-Type: application/x-www-form-urlencoded" \
    56→        -H "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36" \
    57→        -H "Accept: application/json" \
    58→        --data "$post_data" \
    59→        "$TOKEN_ENDPOINT")
    60→
    61→    # Extract HTTP code and response body
    62→    http_code=$(echo "$response" | tail -n1)
    63→    local body=$(echo "$response" | sed '$d')
    64→
    65→    if [[ "$http_code" != "200" ]]; then
    66→        error "Token refresh failed with HTTP $http_code"
    67→        error "Response: $body"
    68→        return 1
    69→    fi
    70→
    71→    # Parse the response
    72→    if ! echo "$body" | jq -e . &>/dev/null; then
    73→        error "Invalid JSON response"
    74→        error "Response: $body"
    75→        return 1
    76→    fi
    77→
    78→    success "$api_label access token refreshed successfully"
    79→
    80→    # Extract token details
    81→    local access_token
    82→    local expires_in
    83→    local token_type
    84→    local new_refresh_token
    85→
    86→    access_token=$(echo "$body" | jq -r '.access_token // empty')
    87→    expires_in=$(echo "$body" | jq -r '.expires_in // empty')
    88→    token_type=$(echo "$body" | jq -r '.token_type // empty')
    89→    new_refresh_token=$(echo "$body" | jq -r '.refresh_token // empty')
    90→
    91→    if [[ -z "$access_token" ]]; then
    92→        error "No access_token in response"
    93→        return 1
    94→    fi
    95→
    96→    # Calculate expiration time
    97→    local expires_at
    98→    expires_at=$(date -u -v+${expires_in}S +%Y-%m-%dT%H:%M:%SZ 2>/dev/null || date -u -d "+${expires_in} seconds" +%Y-%m-%dT%H:%M:%SZ)
    99→
   100→    # Create structured token file (use suffix for outlook tokens)
   101→    local token_file="${TOKENS_DIR}/${email}${token_suffix}_access_token.json"
   102→    cat > "$token_file" <<EOF
   103→{
   104→  "email": "$email",
   105→  "access_token": "$access_token",
   106→  "token_type": "$token_type",
   107→  "expires_in": $expires_in,
   108→  "expires_at": "$expires_at",
   109→  "refreshed_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
   110→  "scopes": "$scopes",
   111→  "api_type": "$api_type"
   112→}
   113→EOF
   114→
   115→    # Save new refresh token if provided (shared between APIs)
   116→    if [[ -n "$new_refresh_token" && "$new_refresh_token" != "null" ]]; then
   117→        echo "$new_refresh_token" > "${TOKENS_DIR}/${email}_refresh_only.txt"
   118→        info "Updated refresh token saved"
   119→    fi
   120→
   121→    # Also save just the access token for easy use
   122→    echo "$access_token" > "${TOKENS_DIR}/${email}${token_suffix}_access_only.txt"
   123→
   124→    success "$api_label tokens saved to: $token_file"
   125→    info "$api_label access token expires at: $expires_at"
   126→
   127→    # Return the full response for further processing
   128→    echo "$body"
   129→}
   130→
   131→# Function to check if access token is still valid
   132→is_token_valid() {
   133→    local email="$1"
   134→    local required_scopes="${2:-}"
   135→    local api_type="${3:-graph}"
   136→    
   137→    local token_suffix=""
   138→    if [[ "$api_type" == "outlook" ]]; then
   139→        token_suffix="_outlook"
   140→    fi
   141→    
   142→    local token_file="${TOKENS_DIR}/${email}${token_suffix}_access_token.json"
   143→
   144→    if [[ ! -f "$token_file" ]]; then
   145→        return 1
   146→    fi
   147→
   148→    local expires_at
   149→    expires_at=$(jq -r '.expires_at' "$token_file")
   150→
   151→    if [[ -z "$expires_at" || "$expires_at" == "null" ]]; then
   152→        return 1
   153→    fi
   154→
   155→    # Check scopes if required
   156→    if [[ -n "$required_scopes" ]]; then
   157→        local stored_scopes
   158→        stored_scopes=$(jq -r '.scopes' "$token_file")
   159→        
   160→        # Simple string containment check
   161→        # This handles space-separated scopes well enough for .default cases
   162→        if [[ "$stored_scopes" != *"$required_scopes"* ]]; then
   163→            info "Token scopes '$stored_scopes' do not match required '$required_scopes'"
   164→            return 1
   165→        fi
   166→    fi
   167→
   168→    # Convert to epoch time and compare
   169→    local expires_epoch
   170→    local now_epoch
   171→
   172→    expires_epoch=$(date -jf "%Y-%m-%dT%H:%M:%SZ" "$expires_at" +%s 2>/dev/null || echo 0)
   173→    now_epoch=$(date +%s)
   174→
   175→    # Add 60 second buffer
   176→    if [[ $((expires_epoch - 60)) -gt $now_epoch ]]; then
   177→        local remaining=$((expires_epoch - now_epoch))
   178→        info "Token still valid for $remaining seconds"
   179→        return 0
   180→    fi
   181→
   182→    info "Token expired or will expire soon"
   183→    return 1
   184→}
   185→
   186→# Function to get access token (refresh if needed)
   187→get_access_token() {
   188→    local email="$1"
   189→    local scopes="${2:-$DEFAULT_SCOPES}"
   190→    local force_refresh="${3:-false}"
   191→    local api_type="${4:-graph}"
   192→    
   193→    local token_suffix=""
   194→    if [[ "$api_type" == "outlook" ]]; then
   195→        token_suffix="_outlook"
   196→    fi
   197→
   198→    # Check if we have a valid token
   199→    if [[ "$force_refresh" != "true" ]] && is_token_valid "$email" "$scopes" "$api_type"; then
   200→        info "Using existing valid $api_type access token"
   201→        cat "${TOKENS_DIR}/${email}${token_suffix}_access_only.txt"
   202→        return 0
   203→    fi
   204→
   205→    # Need to refresh - get refresh token
   206→    local refresh_token_file="${TOKENS_DIR}/${email}_refresh_only.txt"
   207→
   208→    if [[ ! -f "$refresh_token_file" ]]; then
   209→        error "No refresh token found for: $email"
   210→        error "Run extract_tokens.sh first to extract tokens from keychain"
   211→        return 1
   212→    fi
   213→
   214→    local refresh_token
   215→    refresh_token=$(cat "$refresh_token_file")
   216→
   217→    if [[ -z "$refresh_token" ]]; then
   218→        error "Refresh token is empty"
   219→        return 1
   220→    fi
   221→
   222→    # Refresh and get new access token
   223→    refresh_token "$refresh_token" "$scopes" "$email" "$api_type" > /dev/null
   224→    cat "${TOKENS_DIR}/${email}${token_suffix}_access_only.txt"
   225→}
   226→
   227→# Main execution
   228→main() {
   229→    local email="${1:-}"
   230→    local scopes="${2:-$DEFAULT_SCOPES}"
   231→    local command="${3:-get}"
   232→    local api_type="${4:-graph}"  # graph or outlook
   233→
   234→    if [[ -z "$email" ]]; then
   235→        echo "Usage: $0 <email> [scopes] [command] [api_type]"
   236→        echo ""
   237→        echo "Commands:"
   238→        echo "  get     - Get valid access token (refresh if needed) [default]"
   239→        echo "  refresh - Force refresh access token"
   240→        echo "  check   - Check if current token is valid"
   241→        echo ""
   242→        echo "API Types:"
   243→        echo "  graph   - Microsoft Graph API (default)"
   244→        echo "  outlook - Outlook/Exchange API"
   245→        echo ""
   246→        echo "Examples:"
   247→        echo "  $0 user@example.com"
   248→        echo "  $0 user@example.com 'https://graph.microsoft.com/.default'"
   249→        echo "  $0 user@example.com '' refresh"
   250→        echo "  $0 user@example.com 'https://outlook.office365.com/.default' get outlook"
   251→        exit 1
   252→    fi
   253→
   254→    case "$command" in
   255→        get)
   256→            get_access_token "$email" "$scopes" false "$api_type"
   257→            ;;
   258→        refresh)
   259→            get_access_token "$email" "$scopes" true "$api_type"
   260→            ;;
   261→        check)
   262→            if is_token_valid "$email" "$scopes" "$api_type"; then
   263→                success "Token is valid"
   264→                exit 0
   265→            else
   266→                error "Token is expired or invalid"
   267→                exit 1
   268→            fi
   269→            ;;
   270→        *)
   271→            error "Unknown command: $command"
   272→            exit 1
   273→            ;;
   274→    esac
   275→}
   276→
   277→main "$@"
   278→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:03:28.050Z)**_

Let me now look for any Python MSAL implementation and other configuration files:

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:03:28.540Z)**_

<tool-use data-tool-type="shell" data-tool-name="Bash"><details>
<summary>Tool use: **Bash**</summary>

`find /Users/hack/github/outlook-creds -type f \( -name "*.py" -o -name "*.json" -o -name "*.toml" -o -name "*.yaml" -o -name "*.yml" \) | grep -v __pycache__ | head -20`
```
/Users/hack/github/outlook-creds/openapi-schemas/clients.config.office.net.yaml
/Users/hack/github/outlook-creds/openapi-schemas/login.microsoftonline.com.yaml
/Users/hack/github/outlook-creds/openapi-schemas/zoom.us.yaml
/Users/hack/github/outlook-creds/openapi-schemas/addin.insights.static.microsoft.yaml
/Users/hack/github/outlook-creds/openapi-schemas/officeclient.microsoft.com.yaml
/Users/hack/github/outlook-creds/openapi-schemas/officeci.azurewebsites.net.yaml
/Users/hack/github/outlook-creds/openapi-schemas/res.cdn.office.net.yaml
/Users/hack/github/outlook-creds/openapi-schemas/outlook.office365.com.yaml
/Users/hack/github/outlook-creds/openapi-schemas/recent.svc.cloud.microsoft.yaml
/Users/hack/github/outlook-creds/openapi-schemas/odc.officeapps.live.com.yaml
/Users/hack/github/outlook-creds/openapi-schemas/nam02.safelinks.protection.outlook.com.yaml
/Users/hack/github/outlook-creds/openapi-schemas/loki.delve.office.com.yaml
/Users/hack/github/outlook-creds/openapi-schemas/mobile.events.data.microsoft.com.yaml
/Users/hack/github/outlook-creds/openapi-schemas/support.content.office.net.yaml
/Users/hack/github/outlook-creds/openapi-schemas/teams.microsoft.com.yaml
/Users/hack/github/outlook-creds/mkdocs.yml
/Users/hack/github/outlook-creds/pyrightconfig.json
/Users/hack/github/outlook-creds/.pre-commit-config.yaml
/Users/hack/github/outlook-creds/inspect_contact.py
/Users/hack/github/outlook-creds/pyproject.toml
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:03:37.537Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `/Users/hack/github/outlook-creds/pyproject.toml`
```
     1→[project]
     2→name = "outlook-creds"
     3→version = "0.1.0"
     4→description = "macOS toolkit for Microsoft Outlook OAuth credential management"
     5→readme = "README.md"
     6→requires-python = ">=3.13"
     7→license = "MIT"
     8→authors = [{ name = "itsbrex" }]
     9→keywords = ["keychain", "macos", "microsoft", "msal", "oauth", "outlook"]
    10→classifiers = [
    11→  "Development Status :: 4 - Beta",
    12→  "Environment :: Console",
    13→  "Environment :: MacOS X",
    14→  "Intended Audience :: Developers",
    15→  "License :: OSI Approved :: MIT License",
    16→  "Operating System :: MacOS",
    17→  "Programming Language :: Python :: 3.10",
    18→  "Programming Language :: Python :: 3.11",
    19→  "Programming Language :: Python :: 3.12",
    20→  "Programming Language :: Python :: 3.13",
    21→  "Topic :: Security :: Cryptography",
    22→  "Topic :: Utilities",
    23→]
    24→# Using bounded versions: >=X.Y.Z,<N allows minor/patch updates but blocks major versions
    25→# This permits security patches while preventing breaking changes
    26→dependencies = [
    27→  "click>=8.1.7,<9",
    28→  "dateparser>=1.1.8,<2",
    29→  "lxml>=6.0.0,<7",
    30→  "msal>=1.31.1,<3",
    31→  "pyyaml>=6.0,<7",
    32→  "questionary>=2.0.0,<3",
    33→  "requests>=2.31.0,<3",
    34→  "rich>=14.0.0,<15",
    35→]
    36→
    37→[project.optional-dependencies]
    38→dev = [
    39→  "pytest>=9.0.0,<10",
    40→  "pytest-cov>=7.0.0,<8",
    41→  "pytest-mock>=3.12.0,<4",
    42→  "requests-mock>=1.12.0,<2",
    43→  "mypy>=1.8.0,<2",
    44→  "ruff>=0.14.11,<1",
    45→  "bandit>=1.7.0,<2",
    46→  "vulture>=2.12,<3",
    47→  "types-requests>=2.32.0,<3",
    48→  "types-PyYAML>=6.0.0,<7",
    49→  "types-lxml>=2026.1.0,<2026.2.0",
    50→]
    51→docs = [
    52→  "mkdocs>=1.6.0,<2",
    53→  "mkdocs-material>=9.5.0,<11",
    54→  "mkdocstrings[python]>=1.0.0,<2",
    55→]
    56→
    57→[project.scripts]
    58→outlook = "outlook_creds.cli.main:cli"
    59→
    60→# Convenient shortcuts for common operations
    61→# Usage: uv run <command> [options]
    62→#
    63→# Email operations
    64→send-email = "outlook_creds.cli.email:send"
    65→list-emails = "outlook_creds.cli.email:list_emails"
    66→get-email = "outlook_creds.cli.email:get_email"
    67→search-emails = "outlook_creds.cli.email:search_emails"
    68→
    69→# Contact operations
    70→create-contact = "outlook_creds.cli.contact:create"
    71→list-contacts = "outlook_creds.cli.contact:list_contacts"
    72→get-contact = "outlook_creds.cli.contact:get_contact"
    73→search-contacts = "outlook_creds.cli.contact:search_contacts"
    74→merge-contacts = "outlook_creds.cli.contact:merge"
    75→dump-contact = "outlook_creds.cli.contact:dump"
    76→upload-contact-photo = "outlook_creds.cli.contact:upload_photo"
    77→
    78→# Calendar operations
    79→create-event = "outlook_creds.cli.calendar:create"
    80→list-events = "outlook_creds.cli.calendar:list"
    81→get-event = "outlook_creds.cli.calendar:get_event"
    82→update-event = "outlook_creds.cli.calendar:update_event"
    83→delete-event = "outlook_creds.cli.calendar:delete_event"
    84→calendar-view = "outlook_creds.cli.calendar:view"
    85→find-meeting-times = "outlook_creds.cli.calendar:find_times"
    86→get-schedule = "outlook_creds.cli.calendar:schedule"
    87→get-reminders = "outlook_creds.cli.calendar:reminders"
    88→respond-event = "outlook_creds.cli.calendar:respond"
    89→cancel-event = "outlook_creds.cli.calendar:cancel"
    90→forward-event = "outlook_creds.cli.calendar:forward"
    91→snooze-reminder = "outlook_creds.cli.calendar:snooze"
    92→dismiss-reminder = "outlook_creds.cli.calendar:dismiss"
    93→list-calendars = "outlook_creds.cli.calendar:calendars"
    94→create-calendar = "outlook_creds.cli.calendar:create_calendar"
    95→list-calendar-groups = "outlook_creds.cli.calendar:groups"
    96→
    97→# Folder operations
    98→list-folders = "outlook_creds.cli.folders:list_folders"
    99→create-folder = "outlook_creds.cli.folders:create_folder"
   100→delete-folder = "outlook_creds.cli.folders:delete_folder"
   101→move-folder = "outlook_creds.cli.folders:move_folder"
   102→resolve-folder = "outlook_creds.cli.folders:resolve_folder"
   103→
   104→# Category operations
   105→list-categories = "outlook_creds.cli.categories:list_categories"
   106→create-category = "outlook_creds.cli.categories:create_category_cmd"
   107→delete-category = "outlook_creds.cli.categories:delete_category_cmd"
   108→update-category = "outlook_creds.cli.categories:update_category_cmd"
   109→show-category-colors = "outlook_creds.cli.categories:show_colors"
   110→
   111→# Rule operations
   112→list-rules = "outlook_creds.cli.rules:list"
   113→get-rule = "outlook_creds.cli.rules:get"
   114→create-rule = "outlook_creds.cli.rules:create"
   115→update-rule = "outlook_creds.cli.rules:update"
   116→delete-rule = "outlook_creds.cli.rules:delete"
   117→toggle-rule = "outlook_creds.cli.rules:toggle"
   118→export-rules = "outlook_creds.cli.rules:export"
   119→import-rules = "outlook_creds.cli.rules:import_rules"
   120→
   121→# Task operations
   122→create-task = "outlook_creds.cli.tasks:create"
   123→list-tasks = "outlook_creds.cli.tasks:list_tasks"
   124→get-task = "outlook_creds.cli.tasks:get_task"
   125→create-task-from-email = "outlook_creds.cli.tasks:from_email"
   126→
   127→# Cache operations
   128→refresh-cache = "outlook_creds.cli.cache:refresh"
   129→list-cache = "outlook_creds.cli.cache:list"
   130→cache-status = "outlook_creds.cli.cache:status"
   131→clear-cache = "outlook_creds.cli.cache:clear"
   132→
   133→# Auth operations
   134→auth-setup = "outlook_creds.cli.auth:setup_account"
   135→auth-get-token = "outlook_creds.cli.auth:get_tokens"
   136→auth-test = "outlook_creds.cli.auth:test_auth"
   137→auth-refresh = "outlook_creds.cli.auth:refresh_tokens"
   138→auth-list = "outlook_creds.cli.auth:list_accounts"
   139→
   140→# Auto-refresh operations
   141→auto-refresh-start = "outlook_creds.cli.auto_refresh:start"
   142→auto-refresh-stop = "outlook_creds.cli.auto_refresh:stop"
   143→auto-refresh-status = "outlook_creds.cli.auto_refresh:status"
   144→auto-refresh-test = "outlook_creds.cli.auto_refresh:test"
   145→auto-refresh-logs = "outlook_creds.cli.auto_refresh:logs"
   146→
   147→[dependency-groups]
   148→dev = [
   149→  "bandit>=1.7.0,<2",
   150→  "freezegun>=1.2.0,<2",
   151→  "mypy>=1.8.0,<2",
   152→  "poethepoet>=0.40.0",
   153→  "pytest>=9.0.0,<10",
   154→  "pytest-cov>=7.0.0,<8",
   155→  "pytest-mock>=3.12.0,<4",
   156→  "requests-mock>=1.12.0,<2",
   157→  "ruff>=0.14.11,<1",
   158→  "types-lxml>=2026.1.0,<2026.2.0",
   159→  "types-pyyaml>=6.0.12.20250915",
   160→  "types-requests>=2.32.4.20260107",
   161→  "vulture>=2.12,<3",
   162→]
   163→
   164→[build-system]
   165→requires = ["hatchling"]
   166→build-backend = "hatchling.build"
   167→
   168→[tool.hatch.build.targets.wheel]
   169→packages = ["src/outlook_creds"]
   170→
   171→[tool.bandit]
   172→exclude_dirs = ["tests"]
   173→# Skip known false positives for this CLI tool
   174→skips = ["B101", "B105", "B107", "B110", "B310", "B404", "B603"]
   175→
   176→[tool.coverage.run]
   177→source = ["src/outlook_creds"]
   178→branch = true
   179→
   180→[tool.coverage.report]
   181→exclude_lines = [
   182→  "pragma: no cover",
   183→  "if TYPE_CHECKING:",
   184→  "raise NotImplementedError",
   185→]
   186→
   187→[tool.mypy]
   188→python_version = "3.13"
   189→warn_return_any = false
   190→warn_unused_ignores = false
   191→disallow_untyped_defs = false
   192→ignore_missing_imports = true
   193→# Strict mode disabled - codebase uses dynamic JSON APIs
   194→strict = false
   195→check_untyped_defs = false
   196→# Exclude test files
   197→exclude = ["tests/"]
   198→
   199→[[tool.mypy.overrides]]
   200→module = ["requests", "requests.*", "yaml"]
   201→# Stub compatibility issues with Python 3.10
   202→ignore_missing_imports = true
   203→
   204→[[tool.mypy.overrides]]
   205→module = ["outlook_creds.cli.*", "outlook_creds.auth.cache"]
   206→# CLI modules use dynamic dict structures from APIs - skip type checking
   207→ignore_errors = true
   208→
   209→[[tool.mypy.overrides]]
   210→module = ["outlook_creds.api.helpers", "outlook_creds.auth.oauth", "outlook_creds.config"]
   211→# Stricter typing for core modules (but allow Any returns from JSON APIs)
   212→disallow_untyped_defs = true
   213→check_untyped_defs = true
   214→warn_return_any = false
   215→
   216→[tool.poe.tasks]
   217→lint = "ruff check src tests"
   218→format = "ruff format src tests helpers examples scripts"
   219→typecheck = "mypy src tests helpers examples scripts"
   220→security = "bandit -r src -c pyproject.toml"
   221→dead-code = "vulture src tests helpers examples scripts"
   222→test = "pytest"
   223→test-cov = "pytest --cov-report=html"
   224→test-unit = "pytest tests/unit -v"
   225→test-integration = "pytest tests/integration -v"
   226→docs = "mkdocs serve"
   227→docs-build = "mkdocs build"
   228→all = ["format", "lint", "typecheck", "security", "test"]
   229→
   230→[tool.pytest]
   231→testpaths = ["tests"]
   232→pythonpath = ["src", "helpers", "examples"]
   233→addopts = ["-ra", "-q", "--cov=outlook_creds", "--cov-report=term-missing"]
   234→markers = [
   235→  "macos_only: marks tests that require macOS (Keychain, etc.)",
   236→  "integration: marks integration tests",
   237→  "slow: marks tests as slow",
   238→]
   239→
   240→[tool.ruff]
   241→target-version = "py312"
   242→line-length = 100
   243→src = ["src", "tests"]
   244→
   245→[tool.ruff.format]
   246→quote-style = "double"
   247→indent-style = "space"
   248→
   249→[tool.ruff.lint]
   250→select = ["E", "W", "F", "I", "B", "C4", "UP", "S", "T20"]
   251→ignore = ["T201"]
   252→
   253→[tool.ruff.lint.per-file-ignores]
   254→"tests/*" = ["S101", "S105", "S106"]
   255→"scripts/*" = ["T201"]
   256→"src/outlook_creds/cli/*" = ["S101"]  # Allow assert for type guards in CLI
   257→
   258→[tool.vulture]
   259→min_confidence = 80
   260→paths = ["src", "examples", "helpers", "scripts"]
   261→exclude = ["tests/"]
   262→
   263→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:03:37.944Z)**_

<tool-use data-tool-type="shell" data-tool-name="Bash"><details>
<summary>Tool use: **Bash**</summary>

`find /Users/hack/github/outlook-creds -type f -name "get_oauth_tokens.py" -o -name "*msal*" -o -name "*auth*" | grep -v __pycache__`
```
/Users/hack/github/outlook-creds/tests/test_auth_helper.sh
/Users/hack/github/outlook-creds/tests/unit/test_oauth_tokens.py
/Users/hack/github/outlook-creds/tests/test_get_oauth_tokens.py
/Users/hack/github/outlook-creds/.specstory/history/2026-01-05_04-23-08Z-fix-helpers-auth-helper.md
/Users/hack/github/outlook-creds/docs/getting-started/authentication.md
/Users/hack/github/outlook-creds/.mypy_cache/3.10/requests/auth.meta.json
/Users/hack/github/outlook-creds/.mypy_cache/3.10/requests/auth.data.json
/Users/hack/github/outlook-creds/.mypy_cache/3.10/tornado/auth.meta.json
/Users/hack/github/outlook-creds/.mypy_cache/3.10/tornado/auth.data.json
/Users/hack/github/outlook-creds/.mypy_cache/3.10/outlook_creds/auth
/Users/hack/github/outlook-creds/.mypy_cache/3.10/outlook_creds/auth/oauth.meta.json
/Users/hack/github/outlook-creds/.mypy_cache/3.10/outlook_creds/auth/oauth.data.json
/Users/hack/github/outlook-creds/.mypy_cache/3.10/outlook_creds/cli/auth.meta.json
/Users/hack/github/outlook-creds/.mypy_cache/3.10/outlook_creds/cli/auth.data.json
/Users/hack/github/outlook-creds/.venv/bin/auth-refresh
/Users/hack/github/outlook-creds/.venv/bin/auth-setup
/Users/hack/github/outlook-creds/.venv/bin/auth-test
/Users/hack/github/outlook-creds/.venv/bin/auth-get-token
/Users/hack/github/outlook-creds/.venv/bin/auth-list
/Users/hack/github/outlook-creds/.venv/lib/python3.14/site-packages/requests-stubs/auth.pyi
/Users/hack/github/outlook-creds/.venv/lib/python3.14/site-packages/msal-1.34.0.dist-info
/Users/hack/github/outlook-creds/.venv/lib/python3.14/site-packages/requests/auth.py
/Users/hack/github/outlook-creds/.venv/lib/python3.14/site-packages/msal
/Users/hack/github/outlook-creds/.venv/lib/python3.14/site-packages/msal/oauth2cli
/Users/hack/github/outlook-creds/.venv/lib/python3.14/site-packages/msal/oauth2cli/oauth2.py
/Users/hack/github/outlook-creds/.venv/lib/python3.14/site-packages/msal/oauth2cli/authcode.py
/Users/hack/github/outlook-creds/.venv/lib/python3.14/site-packages/msal/auth_scheme.py
/Users/hack/github/outlook-creds/.venv/lib/python3.14/site-packages/msal/authority.py
/Users/hack/github/outlook-creds/.venv/lib/python3.14/site-packages/material/plugins/blog/author.py
/Users/hack/github/outlook-creds/.venv/lib/python3.14/site-packages/material/templates/.icons/simple/webauthn.svg
/Users/hack/github/outlook-creds/.venv/lib/python3.14/site-packages/material/templates/.icons/simple/authentik.svg
/Users/hack/github/outlook-creds/.venv/lib/python3.14/site-packages/material/templates/.icons/simple/auth0.svg
/Users/hack/github/outlook-creds/.venv/lib/python3.14/site-packages/material/templates/.icons/simple/googleauthenticator.svg
/Users/hack/github/outlook-creds/.venv/lib/python3.14/site-packages/material/templates/.icons/simple/authelia.svg
/Users/hack/github/outlook-creds/.venv/lib/python3.14/site-packages/material/templates/.icons/simple/betterauth.svg
/Users/hack/github/outlook-creds/.venv/lib/python3.14/site-packages/material/templates/.icons/simple/aegisauthenticator.svg
/Users/hack/github/outlook-creds/.venv/lib/python3.14/site-packages/material/templates/.icons/simple/fusionauth.svg
/Users/hack/github/outlook-creds/.venv/lib/python3.14/site-packages/material/templates/.icons/material/two-factor-authentication.svg
/Users/hack/github/outlook-creds/scripts/auth_helper.sh
/Users/hack/github/outlook-creds/helpers/auth_helper.sh
/Users/hack/github/outlook-creds/helpers/get_oauth_tokens.py
/Users/hack/github/outlook-creds/src/outlook_creds/auth
/Users/hack/github/outlook-creds/src/outlook_creds/auth/oauth.py
/Users/hack/github/outlook-creds/src/outlook_creds/cli/auth.py
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:03:51.578Z)**_

Now let me read the Python MSAL implementation:

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:03:51.959Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `/Users/hack/github/outlook-creds/src/outlook_creds/auth/oauth.py`
```
     1→"""OAuth Token Generator for Microsoft Outlook.
     2→
     3→Uses MSAL device code flow to obtain fresh OAuth tokens via interactive authentication.
     4→Dependencies managed in pyproject.toml.
     5→"""
     6→
     7→from __future__ import annotations
     8→
     9→import json
    10→import subprocess
    11→import urllib.error
    12→import urllib.parse
    13→import urllib.request
    14→from datetime import UTC, datetime, timedelta
    15→from pathlib import Path
    16→from typing import Any
    17→
    18→from msal import PublicClientApplication
    19→
    20→from outlook_creds.config import (
    21→    TOKEN_FILE_MODE,
    22→    TOKENS_DIR,
    23→    get_account_token_dir,
    24→    normalize_email,
    25→    secure_write_token,
    26→)
    27→
    28→
    29→def load_account_info(email: str) -> dict[str, Any] | None:
    30→    """Load extracted account information from keychain extraction.
    31→
    32→    Args:
    33→        email: Account email address
    34→
    35→    Returns:
    36→        Account info dictionary or None if not found
    37→    """
    38→    token_dir = get_account_token_dir(email)
    39→    account_file = token_dir / "account_info.json"
    40→
    41→    if not account_file.exists():
    42→        print(f"Error: Account info not found at {account_file}")
    43→        print(f"Run: ./helpers/extract_tokens.sh {email} first")
    44→        return None
    45→
    46→    with open(account_file) as f:
    47→        return json.load(f)
    48→
    49→
    50→def extract_token_params(
    51→    account_info: dict[str, Any],
    52→    api_scope: str = "graph",
    53→    explicit_scopes: list[str] | None = None,
    54→) -> dict[str, Any] | None:
    55→    """
    56→    Extract parameters needed for OAuth token request.
    57→
    58→    Args:
    59→        account_info: Account information from keychain
    60→        api_scope: Which API to request scopes for ('graph', 'outlook', or 'both')
    61→        explicit_scopes: List of explicit scopes to request (overrides api_scope if provided)
    62→
    63→    Returns:
    64→        Parameters dictionary or None on error
    65→    """
    66→    try:
    67→        additional_props = json.loads(account_info["additional_properties"])
    68→
    69→        # Use explicit scopes if provided
    70→        if explicit_scopes:
    71→            scopes = explicit_scopes
    72→        # Otherwise build scopes based on requested API
    73→        elif api_scope == "graph":
    74→            scopes = ["https://graph.microsoft.com/.default"]
    75→        elif api_scope == "outlook":
    76→            scopes = ["https://outlook.office365.com/.default"]
    77→        elif api_scope == "both":
    78→            # Cannot request multiple .default scopes for different resources in one request.
    79→            # We request Graph as primary, which gives us a Refresh Token.
    80→            # The Refresh Token can then be used to acquire tokens for Outlook/Exchange as needed.
    81→            scopes = ["https://graph.microsoft.com/.default"]
    82→        else:
    83→            scopes = ["https://graph.microsoft.com/.default"]  # Default to Graph
    84→
    85→        return {
    86→            "tenant_id": account_info["realm"],
    87→            "account_id": account_info["id"],
    88→            "authority": account_info["authority"],
    89→            "email": account_info["login_name"],
    90→            "client_id": additional_props.get("aud", "d3590ed6-52b3-4102-aeff-aad2292ab01c"),
    91→            "scopes": scopes,  # offline_access is automatic with .default
    92→        }
    93→    except Exception as e:
    94→        print(f"Error extracting parameters: {e}")
    95→        return None
    96→
    97→
    98→def authenticate_with_msal(params: dict[str, Any]) -> dict[str, Any]:
    99→    """
   100→    Authenticate user via MSAL device code flow.
   101→
   102→    Args:
   103→        params: dict with tenant_id, client_id, authority, email, scopes
   104→
   105→    Returns:
   106→        dict: OAuth token response with access_token, refresh_token, etc.
   107→
   108→    Raises:
   109→        Exception: If authentication fails
   110→    """
   111→    print(f"\nInitiating Microsoft authentication for: {params['email']}")
   112→    print(f"Authority: {params['authority']}")
   113→    print()
   114→
   115→    # Create MSAL app
   116→    app = PublicClientApplication(client_id=params["client_id"], authority=params["authority"])
   117→
   118→    # Check for cached tokens first
   119→    accounts = app.get_accounts(username=params["email"])
   120→    if accounts:
   121→        print("Found cached account, attempting silent authentication...")
   122→        result = app.acquire_token_silent(scopes=params["scopes"], account=accounts[0])
   123→        if result and "access_token" in result:
   124→            print("✓ Using cached authentication")
   125→            return result
   126→
   127→    # No cached token - initiate device code flow
   128→    print("No cached tokens found, initiating device code flow...")
   129→    flow = app.initiate_device_flow(scopes=params["scopes"])
   130→
   131→    if "user_code" not in flow:
   132→        raise Exception(f"Failed to create device flow: {flow.get('error_description')}")
   133→
   134→    # Display authentication instructions
   135→    print("\n" + "=" * 70)
   136→    print("  MICROSOFT AUTHENTICATION REQUIRED")
   137→    print("=" * 70)
   138→    print()
   139→    print(flow["message"])
   140→    print()
   141→    print("=" * 70)
   142→    print(f"Account: {params['email']}")
   143→    print(f"Scopes: {', '.join(params['scopes'])}")
   144→    print("=" * 70)
   145→
   146→    # Auto-copy code to clipboard and open browser (macOS)
   147→    user_code = flow.get("user_code", "")
   148→    verification_uri = flow.get("verification_uri", "")
   149→
   150→    if user_code:
   151→        try:
   152→            subprocess.run(  # noqa: S603, S607 - macOS pbcopy
   153→                ["/usr/bin/pbcopy"], input=user_code.encode(), check=True
   154→            )
   155→            print(f"\n✓ Code '{user_code}' copied to clipboard")
   156→        except Exception:  # noqa: S110 - intentional silent fail
   157→            pass
   158→
   159→    if verification_uri:
   160→        try:
   161→            subprocess.run(  # noqa: S603, S607 - macOS open
   162→                ["/usr/bin/open", verification_uri], check=True
   163→            )
   164→            print(f"✓ Opened {verification_uri} in browser")
   165→        except Exception:  # noqa: S110 - intentional silent fail
   166→            pass
   167→
   168→    print()
   169→
   170→    # Wait for user authentication
   171→    print("Waiting for authentication...")
   172→    result = app.acquire_token_by_device_flow(flow)
   173→
   174→    # Check for errors
   175→    if "error" in result:
   176→        error_desc = result.get("error_description", result.get("error"))
   177→        raise Exception(f"Authentication failed: {error_desc}")
   178→
   179→    if "access_token" not in result:
   180→        raise Exception("No access token in authentication response")
   181→
   182→    print("\n✓ Authentication successful!")
   183→
   184→    return result
   185→
   186→
   187→def acquire_outlook_token_via_refresh(
   188→    refresh_token: str,
   189→    params: dict[str, Any],
   190→) -> dict[str, Any] | None:
   191→    """
   192→    Use refresh token to acquire Outlook API access token.
   193→
   194→    This allows us to get tokens for both Graph and Outlook APIs
   195→    from a single interactive authentication.
   196→
   197→    Args:
   198→        refresh_token: Valid refresh token
   199→        params: OAuth parameters dict
   200→
   201→    Returns:
   202→        dict: Token response with access_token, refresh_token, etc.
   203→        None: If acquisition fails
   204→    """
   205→    print("\n[Both APIs] Acquiring Outlook API token using refresh token...")
   206→
   207→    token_endpoint = f"https://login.microsoftonline.com/{params['tenant_id']}/oauth2/v2.0/token"
   208→    outlook_scope = "https://outlook.office365.com/.default offline_access"
   209→
   210→    data = urllib.parse.urlencode(
   211→        {
   212→            "client_id": params["client_id"],
   213→            "grant_type": "refresh_token",
   214→            "refresh_token": refresh_token,
   215→            "scope": outlook_scope,
   216→        }
   217→    ).encode("utf-8")
   218→
   219→    headers = {
   220→        "Content-Type": "application/x-www-form-urlencoded",
   221→        "Accept": "application/json",
   222→    }
   223→
   224→    try:
   225→        req = urllib.request.Request(token_endpoint, data=data, headers=headers)  # noqa: S310
   226→        with urllib.request.urlopen(req, timeout=30) as response:  # noqa: S310  # nosec B310
   227→            result = json.loads(response.read().decode("utf-8"))
   228→
   229→            if "access_token" in result:
   230→                print("✓ Outlook API token acquired successfully")
   231→                return result
   232→            else:
   233→                print("⚠ Outlook token response missing access_token")
   234→                return None
   235→
   236→    except urllib.error.HTTPError as e:
   237→        error_body = e.read().decode("utf-8")
   238→        print(f"⚠ Failed to acquire Outlook token (HTTP {e.code})")
   239→        try:
   240→            error_json = json.loads(error_body)
   241→            err_desc = error_json.get("error_description", error_json.get("error", "Unknown"))
   242→            print(f"  Error: {err_desc}")
   243→        except Exception:
   244→            print(f"  Response: {error_body[:200]}")
   245→        return None
   246→    except Exception as e:
   247→        print(f"⚠ Failed to acquire Outlook token: {e}")
   248→        return None
   249→
   250→
   251→def save_tokens(
   252→    params: dict[str, Any],
   253→    msal_result: dict[str, Any],
   254→    token_dir: Path,
   255→    api_type: str = "graph",
   256→) -> None:
   257→    """
   258→    Save tokens in format compatible with refresh_access_token.sh.
   259→
   260→    Creates:
   261→    - oauth_tokens.json - Full OAuth response in token_dir
   262→    - {email}_refresh_only.txt - Refresh token
   263→    - {email}_access_token.json - Structured access token data (Graph API)
   264→    - {email}_outlook_access_token.json - Structured access token data (Outlook API)
   265→    - {email}_access_only.txt - Raw access token
   266→
   267→    Args:
   268→        params: OAuth parameters dict
   269→        msal_result: Token response from MSAL or refresh
   270→        token_dir: Path to token directory
   271→        api_type: 'graph' or 'outlook' - determines file naming
   272→    """
   273→    email = params["email"]
   274→    normalized = normalize_email(email)
   275→
   276→    # Determine file suffix based on API type
   277→    token_suffix = "_outlook" if api_type == "outlook" else ""
   278→    api_label = "Outlook" if api_type == "outlook" else "Graph"
   279→
   280→    # Ensure parent directories exist
   281→    token_dir.mkdir(parents=True, exist_ok=True)
   282→    TOKENS_DIR.mkdir(parents=True, exist_ok=True)
   283→
   284→    # 1. Save full OAuth response to token_dir (only for primary/graph)
   285→    if api_type == "graph":
   286→        oauth_tokens = {
   287→            "access_token": msal_result["access_token"],
   288→            "refresh_token": msal_result.get("refresh_token", ""),
   289→            "token_type": msal_result.get("token_type", "Bearer"),
   290→            "expires_in": msal_result.get("expires_in", 3600),
   291→            "scope": msal_result.get("scope", " ".join(params.get("scopes", []))),
   292→            "account_id": params.get("account_id", ""),
   293→            "tenant_id": params["tenant_id"],
   294→            "email": email,
   295→            "obtained_via": "msal_device_code_flow",
   296→            "obtained_at": datetime.now(UTC).isoformat().replace("+00:00", "Z"),
   297→        }
   298→
   299→        oauth_file = token_dir / "oauth_tokens.json"
   300→        with open(oauth_file, "w") as f:
   301→            json.dump(oauth_tokens, f, indent=2)
   302→        oauth_file.chmod(TOKEN_FILE_MODE)
   303→
   304→    # 2. Save refresh token separately (only update from primary/graph response)
   305→    if api_type == "graph" and msal_result.get("refresh_token"):
   306→        refresh_file = TOKENS_DIR / f"{normalized}_refresh_only.txt"
   307→        secure_write_token(refresh_file, msal_result["refresh_token"])
   308→        print(f"✓ Refresh token saved to: {refresh_file}")
   309→    elif api_type == "graph":
   310→        print("⚠ Warning: No refresh token in response")
   311→        print("  This may limit token refresh capabilities")
   312→
   313→    # 3. Create structured access token JSON
   314→    expires_at = datetime.now(UTC) + timedelta(seconds=msal_result.get("expires_in", 3600))
   315→
   316→    access_token_data = {
   317→        "email": email,
   318→        "access_token": msal_result["access_token"],
   319→        "token_type": msal_result.get("token_type", "Bearer"),
   320→        "expires_in": msal_result.get("expires_in", 3600),
   321→        "expires_at": expires_at.strftime("%Y-%m-%dT%H:%M:%SZ"),
   322→        "refreshed_at": datetime.now(UTC).strftime("%Y-%m-%dT%H:%M:%SZ"),
   323→        "scopes": msal_result.get("scope", ""),
   324→        "api_type": api_type,
   325→    }
   326→
   327→    # Use different filename for Outlook vs Graph
   328→    access_file = TOKENS_DIR / f"{normalized}{token_suffix}_access_token.json"
   329→    with open(access_file, "w") as f:
   330→        json.dump(access_token_data, f, indent=2)
   331→    access_file.chmod(TOKEN_FILE_MODE)
   332→    print(f"✓ {api_label} access token saved to: {access_file}")
   333→
   334→    # 4. Save raw access token (different file for each API)
   335→    access_only_file = TOKENS_DIR / f"{normalized}{token_suffix}_access_only.txt"
   336→    secure_write_token(access_only_file, msal_result["access_token"])
   337→    print(f"✓ {api_label} access token (raw) saved to: {access_only_file}")
   338→
   339→    print(f"\n✓ {api_label} tokens saved successfully")
   340→    print(f"  Token directory: {token_dir}")
   341→    print(f"  Expires at: {expires_at.strftime('%Y-%m-%d %I:%M:%S %p UTC')}")
   342→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:03:52.062Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `/Users/hack/github/outlook-creds/src/outlook_creds/cli/auth.py`
```
     1→"""Authentication CLI subcommands.
     2→
     3→These commands are used by shell scripts for token management.
     4→"""
     5→
     6→import subprocess
     7→
     8→import click
     9→from rich.console import Console
    10→
    11→from outlook_creds.config import HELPERS_DIR
    12→
    13→console = Console()
    14→
    15→
    16→@click.group()
    17→def auth() -> None:
    18→    """Authentication commands for OAuth token management."""
    19→    pass
    20→
    21→
    22→@auth.command("get-tokens")
    23→@click.argument("email")
    24→@click.option(
    25→    "--api",
    26→    "api_scope",
    27→    default="graph",
    28→    type=click.Choice(["graph", "outlook", "both"]),
    29→    help="API scope: graph (default), outlook, or both",
    30→)
    31→@click.option("--scopes", default=None, help="Explicit comma-separated scopes (overrides --api)")
    32→def get_tokens(email: str, api_scope: str, scopes: str | None) -> None:
    33→    """Authenticate and get OAuth tokens via device code flow.
    34→
    35→    This command is called by helpers/auth_helper.sh during setup.
    36→    It performs MSAL device code authentication and stores tokens.
    37→    """
    38→    from outlook_creds.auth.oauth import (
    39→        acquire_outlook_token_via_refresh,
    40→        authenticate_with_msal,
    41→        extract_token_params,
    42→        load_account_info,
    43→        save_tokens,
    44→    )
    45→    from outlook_creds.config import get_account_token_dir
    46→
    47→    # Parse explicit scopes if provided
    48→    explicit_scopes = None
    49→    if scopes:
    50→        explicit_scopes = [s.strip() for s in scopes.split(",") if s.strip()]
    51→        if not explicit_scopes:
    52→            raise click.ClickException("--scopes cannot be empty")
    53→
    54→    # Load account info extracted by extract_tokens.sh
    55→    console.print(f"Loading account information for {email}...")
    56→    account_info = load_account_info(email)
    57→    if not account_info:
    58→        raise click.ClickException(
    59→            f"Account info not found for {email}. Run extract_tokens.sh first."
    60→        )
    61→
    62→    console.print("✓ Account information loaded")
    63→    console.print(f"  Account ID: {account_info['id']}")
    64→    console.print(f"  Tenant ID: {account_info['realm']}")
    65→    console.print(f"  Display Name: {account_info['display_name']}")
    66→    if explicit_scopes:
    67→        console.print(f"  Explicit Scopes: {', '.join(explicit_scopes)}")
    68→    else:
    69→        console.print(f"  API Scope: {api_scope}")
    70→
    71→    # Extract parameters
    72→    params = extract_token_params(account_info, api_scope, explicit_scopes)
    73→    if not params:
    74→        raise click.ClickException("Failed to extract token parameters")
    75→
    76→    # Authenticate
    77→    try:
    78→        console.print("Authenticating with Microsoft...")
    79→        tokens = authenticate_with_msal(params)
    80→    except Exception as e:
    81→        console.print(f"\n[red]Error during authentication: {e}[/red]")
    82→        console.print("\nTroubleshooting:")
    83→        console.print("  1. Make sure you completed the authentication in the browser")
    84→        console.print("  2. Check your internet connection")
    85→        console.print("  3. Verify the account is valid and has access to the tenant")
    86→        console.print("  4. Try running the script again")
    87→        raise click.ClickException(str(e)) from None
    88→
    89→    # Save tokens
    90→    token_dir = get_account_token_dir(email)
    91→
    92→    # Save Graph API tokens (primary)
    93→    save_tokens(params, tokens, token_dir, api_type="graph")
    94→
    95→    # If 'both' was requested, also acquire Outlook API token
    96→    outlook_success = False
    97→    if api_scope == "both" and tokens.get("refresh_token"):
    98→        outlook_result = acquire_outlook_token_via_refresh(tokens["refresh_token"], params)
    99→        if outlook_result:
   100→            # Save Outlook tokens with 'outlook' suffix
   101→            save_tokens(params, outlook_result, token_dir, api_type="outlook")
   102→            outlook_success = True
   103→        else:
   104→            console.print("\n[yellow]⚠ Outlook API token acquisition failed[/yellow]")
   105→            console.print("  Graph API token is still valid and can be used")
   106→
   107→    # Success message
   108→    console.print()
   109→    console.print("=" * 70)
   110→    if api_scope == "both":
   111→        if outlook_success:
   112→            console.print("  SETUP COMPLETE - BOTH APIs CONFIGURED")
   113→        else:
   114→            console.print("  SETUP COMPLETE - GRAPH API ONLY (Outlook failed)")
   115→    else:
   116→        console.print("  SETUP COMPLETE")
   117→    console.print("=" * 70)
   118→    console.print("\nYou can now use the tokens for API calls:")
   119→    console.print(f"  ./helpers/auth_helper.sh get {email}           # Graph API (default)")
   120→    if api_scope == "both" and outlook_success:
   121→        console.print(f"  ./helpers/auth_helper.sh get {email} --api=outlook  # Outlook API")
   122→
   123→
   124→@auth.command("test")
   125→@click.argument("email")
   126→@click.option(
   127→    "--api",
   128→    "api_type",
   129→    default="graph",
   130→    type=click.Choice(["graph", "outlook"]),
   131→    help="API to test",
   132→)
   133→def test_auth(email: str, api_type: str) -> None:
   134→    """Test authentication by making a simple API call."""
   135→    from outlook_creds.api.helpers import get_access_token, graph_request
   136→    from outlook_creds.config import GRAPH_BASE_URL
   137→
   138→    try:
   139→        console.print(f"Getting access token for {email}...")
   140→        token = get_access_token(email, api_type=api_type)
   141→        console.print("✓ Access token retrieved")
   142→
   143→        console.print("Testing API call...")
   144→        response = graph_request(token, "GET", f"{GRAPH_BASE_URL}/me")
   145→
   146→        # Check for rate limiting with user feedback
   147→        if response.status_code == 429:
   148→            console.print("[yellow]⚠ Rate limited by Microsoft API. Retries exhausted.[/yellow]")
   149→            console.print("  Try again in a few seconds.")
   150→            raise click.ClickException("Rate limited (429). Please wait and try again.")
   151→
   152→        response.raise_for_status()
   153→        user_data = response.json()
   154→
   155→        console.print("[green]✓ Authentication successful![/green]")
   156→        console.print(f"  Display Name: {user_data.get('displayName', 'N/A')}")
   157→        console.print(
   158→            f"  Email: {user_data.get('mail', user_data.get('userPrincipalName', 'N/A'))}"
   159→        )
   160→    except click.ClickException:
   161→        raise
   162→    except Exception as e:
   163→        console.print(f"[red]✗ Authentication test failed: {e}[/red]")
   164→        raise click.ClickException(str(e)) from None
   165→
   166→
   167→@auth.command("refresh")
   168→@click.argument("email", required=False)
   169→@click.option(
   170→    "--api",
   171→    "api_type",
   172→    default="graph",
   173→    type=click.Choice(["graph", "outlook", "both"]),
   174→    help="API to refresh tokens for (default: graph)",
   175→)
   176→@click.option("--force", is_flag=True, help="Force refresh even if token is valid")
   177→@click.option("--use-shell", is_flag=True, help="Use shell scripts instead of Python")
   178→def refresh_tokens(
   179→    email: str | None,
   180→    api_type: str,
   181→    force: bool,
   182→    use_shell: bool,
   183→) -> None:
   184→    """Refresh access tokens using stored refresh tokens.
   185→
   186→    If EMAIL is not provided, refreshes all configured accounts.
   187→    Uses Python-native refresh by default (no shell subprocess).
   188→
   189→    Examples:
   190→        outlook auth refresh user@example.com
   191→        outlook auth refresh --api=both
   192→        outlook auth refresh --force
   193→        outlook auth refresh --use-shell
   194→    """
   195→    if use_shell:
   196→        # Delegate to shell script (existing behavior)
   197→        _refresh_via_shell(email)
   198→        return
   199→
   200→    from outlook_creds.auth.token_manager import (
   201→        AuthenticationRequiredError,
   202→        TokenRefreshError,
   203→        get_token_manager,
   204→    )
   205→
   206→    accounts = [email] if email else _list_configured_accounts()
   207→
   208→    if not accounts:
   209→        console.print("[yellow]No configured accounts found.[/yellow]")
   210→        console.print("Run: outlook auth setup <email> to set up an account")
   211→        return
   212→
   213→    for account in accounts:
   214→        console.print(f"\n[bold]{account}[/bold]")
   215→        try:
   216→            manager = get_token_manager(account)
   217→
   218→            if api_type in ("graph", "both"):
   219→                try:
   220→                    if force:
   221→                        manager.force_refresh("graph")
   222→                        action = "Force refreshed"
   223→                    else:
   224→                        manager.get_valid_token("graph")
   225→                        action = "Refreshed" if not manager.is_token_valid("graph") else "Valid"
   226→                    expiry = manager.get_token_expiry("graph")
   227→                    expiry_str = expiry.strftime("%Y-%m-%d %H:%M:%S UTC") if expiry else "unknown"
   228→                    console.print(f"  [green]✓ Graph: {action}, expires {expiry_str}[/green]")
   229→                except TokenRefreshError as e:
   230→                    console.print(f"  [red]✗ Graph refresh failed: {e}[/red]")
   231→
   232→            if api_type in ("outlook", "both"):
   233→                try:
   234→                    if force:
   235→                        manager.force_refresh("outlook")
   236→                        action = "Force refreshed"
   237→                    else:
   238→                        manager.get_valid_token("outlook")
   239→                        action = "Refreshed" if not manager.is_token_valid("outlook") else "Valid"
   240→                    expiry = manager.get_token_expiry("outlook")
   241→                    expiry_str = expiry.strftime("%Y-%m-%d %H:%M:%S UTC") if expiry else "unknown"
   242→                    console.print(f"  [green]✓ Outlook: {action}, expires {expiry_str}[/green]")
   243→                except TokenRefreshError as e:
   244→                    console.print(f"  [red]✗ Outlook refresh failed: {e}[/red]")
   245→
   246→        except AuthenticationRequiredError:
   247→            console.print(f"  [red]✗ No refresh token. Run: outlook auth setup {account}[/red]")
   248→        except Exception as e:
   249→            console.print(f"  [red]✗ Error: {e}[/red]")
   250→
   251→
   252→def _list_configured_accounts() -> list[str]:
   253→    """List all accounts with stored refresh tokens."""
   254→    import json
   255→
   256→    from outlook_creds.config import TOKENS_DIR
   257→
   258→    if not TOKENS_DIR.exists():
   259→        return []
   260→
   261→    accounts = set()
   262→    for token_file in TOKENS_DIR.glob("*_access_token.json"):
   263→        # Skip outlook-specific token files
   264→        if "_outlook_" in token_file.name:
   265→            continue
   266→        try:
   267→            with open(token_file) as f:
   268→                data = json.load(f)
   269→            email = data.get("email", "")
   270→            if email:
   271→                accounts.add(email)
   272→        except Exception:
   273→            pass
   274→
   275→    return sorted(accounts)
   276→
   277→
   278→def _refresh_via_shell(email: str | None) -> None:
   279→    """Legacy shell-based refresh (for --use-shell flag)."""
   280→    console.print("[dim]Using shell scripts for refresh...[/dim]")
   281→
   282→    if email:
   283→        auth_helper = HELPERS_DIR / "auth_helper.sh"
   284→        if not auth_helper.exists():
   285→            raise click.ClickException(f"Auth helper script not found: {auth_helper}")
   286→        result = subprocess.run(
   287→            [str(auth_helper), "refresh", email],
   288→            capture_output=False,
   289→        )  # noqa: S603
   290→        if result.returncode != 0:
   291→            raise click.ClickException("Shell refresh failed")
   292→    else:
   293→        refresh_all = HELPERS_DIR / "refresh_all_tokens.sh"
   294→        if not refresh_all.exists():
   295→            raise click.ClickException(f"Refresh script not found: {refresh_all}")
   296→        result = subprocess.run([str(refresh_all)], capture_output=False)  # noqa: S603
   297→        if result.returncode != 0:
   298→            raise click.ClickException("Shell refresh failed")
   299→
   300→
   301→@auth.command("list")
   302→def list_accounts() -> None:
   303→    """List configured accounts."""
   304→    import json
   305→
   306→    from outlook_creds.config import TOKENS_DIR
   307→
   308→    if not TOKENS_DIR.exists():
   309→        console.print("[yellow]No tokens directory found.[/yellow]")
   310→        return
   311→
   312→    accounts = set()
   313→    for token_file in TOKENS_DIR.glob("*_access_token.json"):
   314→        try:
   315→            with open(token_file) as f:
   316→                data = json.load(f)
   317→            email = data.get("email", "")
   318→            if email:
   319→                accounts.add(email)
   320→        except Exception:  # noqa: S110 - skip malformed token files
   321→            pass
   322→
   323→    if not accounts:
   324→        console.print("[yellow]No configured accounts found.[/yellow]")
   325→        return
   326→
   327→    console.print("[bold]Configured accounts:[/bold]")
   328→    for account in sorted(accounts):
   329→        console.print(f"  • {account}")
   330→
   331→
   332→@auth.command("setup")
   333→@click.argument("email")
   334→@click.argument("name", required=False)
   335→@click.argument("scope", required=False, default="graph")
   336→@click.option("--interactive", "-i", is_flag=True, help="Interactive setup mode")
   337→def setup_account(
   338→    email: str,
   339→    name: str | None,
   340→    scope: str,
   341→    interactive: bool,
   342→) -> None:
   343→    """Set up authentication for an account.
   344→
   345→    Performs the full account setup flow:
   346→    1. Extract account metadata from macOS Keychain
   347→    2. Authenticate via MSAL device code flow (browser)
   348→    3. Store tokens securely
   349→
   350→    Arguments:
   351→        EMAIL: Account email address
   352→        NAME: Display name for the account (default: email)
   353→        SCOPE: API scope - graph, outlook, or both (default: graph)
   354→
   355→    Examples:
   356→        outlook auth setup user@example.com
   357→        outlook auth setup user@example.com "Work Account" both
   358→        outlook auth setup user@example.com --interactive
   359→    """
   360→    auth_helper = HELPERS_DIR / "auth_helper.sh"
   361→
   362→    if not auth_helper.exists():
   363→        raise click.ClickException(
   364→            f"Auth helper script not found: {auth_helper}\n"
   365→            "Ensure you're running from the project directory."
   366→        )
   367→
   368→    # Build command
   369→    cmd = [str(auth_helper), "setup", email]
   370→    if name:
   371→        cmd.append(name)
   372→    else:
   373→        cmd.append(email)  # Use email as display name
   374→    cmd.append(scope)
   375→
   376→    console.print(f"[bold]Setting up account: {email}[/bold]")
   377→    console.print(f"[dim]Display name: {name or email}[/dim]")
   378→    console.print(f"[dim]API scope: {scope}[/dim]")
   379→    console.print()
   380→
   381→    # Run the setup script
   382→    result = subprocess.run(cmd)  # noqa: S603 - trusted internal script
   383→
   384→    if result.returncode != 0:
   385→        raise click.ClickException("Account setup failed")
   386→
   387→
   388→@auth.command("export")
   389→@click.argument("file", required=False, type=click.Path())
   390→def export_credentials(file: str | None) -> None:
   391→    """Export credentials to a backup file.
   392→
   393→    Creates a tar.gz archive of all stored credentials and tokens.
   394→    Default location: ~/config/outlook-creds/backup_YYYYMMDD_HHMMSS.tar.gz
   395→
   396→    Examples:
   397→        outlook auth export
   398→        outlook auth export /path/to/backup.tar.gz
   399→    """
   400→    store_script = HELPERS_DIR / "store_credentials.sh"
   401→
   402→    if not store_script.exists():
   403→        raise click.ClickException(
   404→            f"Store credentials script not found: {store_script}\n"
   405→            "Ensure you're running from the project directory."
   406→        )
   407→
   408→    cmd = [str(store_script), "export"]
   409→    if file:
   410→        cmd.append(file)
   411→
   412→    console.print("[bold]Exporting credentials...[/bold]")
   413→    result = subprocess.run(cmd, capture_output=True, text=True)  # noqa: S603
   414→
   415→    if result.returncode == 0:
   416→        console.print("[green]✓ Credentials exported successfully[/green]")
   417→        if result.stdout:
   418→            console.print(result.stdout)
   419→    else:
   420→        console.print(f"[red]Export failed:[/red] {result.stderr or result.stdout}")
   421→        raise click.ClickException("Credential export failed")
   422→
   423→
   424→@auth.command("import")
   425→@click.argument("file", required=True, type=click.Path(exists=True))
   426→def import_credentials(file: str) -> None:
   427→    """Import credentials from a backup file.
   428→
   429→    Restores credentials and tokens from a tar.gz archive
   430→    created by 'outlook auth export'.
   431→
   432→    Examples:
   433→        outlook auth import ~/backup.tar.gz
   434→    """
   435→    store_script = HELPERS_DIR / "store_credentials.sh"
   436→
   437→    if not store_script.exists():
   438→        raise click.ClickException(
   439→            f"Store credentials script not found: {store_script}\n"
   440→            "Ensure you're running from the project directory."
   441→        )
   442→
   443→    cmd = [str(store_script), "import", file]
   444→
   445→    console.print(f"[bold]Importing credentials from: {file}[/bold]")
   446→    result = subprocess.run(cmd, capture_output=True, text=True)  # noqa: S603
   447→
   448→    if result.returncode == 0:
   449→        console.print("[green]✓ Credentials imported successfully[/green]")
   450→        if result.stdout:
   451→            console.print(result.stdout)
   452→    else:
   453→        console.print(f"[red]Import failed:[/red] {result.stderr or result.stdout}")
   454→        raise click.ClickException("Credential import failed")
   455→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:03:52.306Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `/Users/hack/github/outlook-creds/helpers/get_oauth_tokens.py`
```
     1→#!/usr/bin/env -S uv run --script
     2→# /// script
     3→# dependencies = [
     4→#   "msal>=1.31.1",
     5→#   "requests>=2.31.0",
     6→# ]
     7→# requires-python = ">=3.10"
     8→# ///
     9→"""
    10→OAuth Token Generator for Microsoft Outlook
    11→Uses MSAL device code flow to obtain fresh OAuth tokens via interactive authentication
    12→"""
    13→
    14→import json
    15→import subprocess
    16→import sys
    17→import urllib.parse
    18→import urllib.request
    19→from datetime import UTC, datetime, timedelta
    20→from pathlib import Path
    21→
    22→from msal import PublicClientApplication
    23→
    24→
    25→def load_account_info(email):
    26→    """Load extracted account information from keychain extraction"""
    27→    token_dir = (
    28→        Path.home()
    29→        / "config"
    30→        / "outlook-creds"
    31→        / "tokens"
    32→        / email.replace("@", "_").replace(".", "_")
    33→    )
    34→    account_file = token_dir / "account_info.json"
    35→
    36→    if not account_file.exists():
    37→        print(f"Error: Account info not found at {account_file}")
    38→        print(f"Run: ./helpers/extract_tokens.sh {email} first")
    39→        return None
    40→
    41→    with open(account_file) as f:
    42→        return json.load(f)
    43→
    44→
    45→def extract_token_params(account_info, api_scope="graph", explicit_scopes=None):
    46→    """
    47→    Extract parameters needed for OAuth token request
    48→
    49→    Args:
    50→        account_info: Account information from keychain
    51→        api_scope: Which API to request scopes for ('graph', 'outlook', or 'both')
    52→        explicit_scopes: List of explicit scopes to request (overrides api_scope if provided)
    53→    """
    54→    try:
    55→        additional_props = json.loads(account_info["additional_properties"])
    56→
    57→        # Use explicit scopes if provided
    58→        if explicit_scopes:
    59→            scopes = explicit_scopes
    60→        # Otherwise build scopes based on requested API
    61→        elif api_scope == "graph":
    62→            scopes = ["https://graph.microsoft.com/.default"]
    63→        elif api_scope == "outlook":
    64→            scopes = ["https://outlook.office365.com/.default"]
    65→        elif api_scope == "both":
    66→            # Cannot request multiple .default scopes for different resources in one request.
    67→            # We request Graph as primary, which gives us a Refresh Token.
    68→            # The Refresh Token can then be used to acquire tokens for Outlook/Exchange as needed.
    69→            scopes = ["https://graph.microsoft.com/.default"]
    70→        else:
    71→            scopes = ["https://graph.microsoft.com/.default"]  # Default to Graph
    72→
    73→        return {
    74→            "tenant_id": account_info["realm"],
    75→            "account_id": account_info["id"],
    76→            "authority": account_info["authority"],
    77→            "email": account_info["login_name"],
    78→            "client_id": additional_props.get("aud", "d3590ed6-52b3-4102-aeff-aad2292ab01c"),
    79→            "scopes": scopes,  # offline_access is automatic with .default
    80→        }
    81→    except Exception as e:
    82→        print(f"Error extracting parameters: {e}")
    83→        return None
    84→
    85→
    86→def authenticate_with_msal(params):
    87→    """
    88→    Authenticate user via MSAL device code flow
    89→
    90→    Args:
    91→        params: dict with tenant_id, client_id, authority, email, scopes
    92→
    93→    Returns:
    94→        dict: OAuth token response with access_token, refresh_token, etc.
    95→    """
    96→    print(f"\nInitiating Microsoft authentication for: {params['email']}")
    97→    print(f"Authority: {params['authority']}")
    98→    print()
    99→
   100→    # Create MSAL app
   101→    app = PublicClientApplication(client_id=params["client_id"], authority=params["authority"])
   102→
   103→    # Check for cached tokens first
   104→    accounts = app.get_accounts(username=params["email"])
   105→    if accounts:
   106→        print("Found cached account, attempting silent authentication...")
   107→        result = app.acquire_token_silent(scopes=params["scopes"], account=accounts[0])
   108→        if result and "access_token" in result:
   109→            print("✓ Using cached authentication")
   110→            return result
   111→
   112→    # No cached token - initiate device code flow
   113→    print("No cached tokens found, initiating device code flow...")
   114→    flow = app.initiate_device_flow(scopes=params["scopes"])
   115→
   116→    if "user_code" not in flow:
   117→        raise Exception(f"Failed to create device flow: {flow.get('error_description')}")
   118→
   119→    # Display authentication instructions
   120→    print("\n" + "=" * 70)
   121→    print("  MICROSOFT AUTHENTICATION REQUIRED")
   122→    print("=" * 70)
   123→    print()
   124→    print(flow["message"])
   125→    print()
   126→    print("=" * 70)
   127→    print(f"Account: {params['email']}")
   128→    print(f"Scopes: {', '.join(params['scopes'])}")
   129→    print("=" * 70)
   130→
   131→    # Auto-copy code to clipboard and open browser (macOS)
   132→    user_code = flow.get("user_code", "")
   133→    verification_uri = flow.get("verification_uri", "")
   134→
   135→    if user_code:
   136→        try:
   137→            subprocess.run(["pbcopy"], input=user_code.encode(), check=True)
   138→            print(f"\n✓ Code '{user_code}' copied to clipboard")
   139→        except Exception:
   140→            pass  # Silently fail if pbcopy not available
   141→
   142→    if verification_uri:
   143→        try:
   144→            subprocess.run(["open", verification_uri], check=True)
   145→            print(f"✓ Opened {verification_uri} in browser")
   146→        except Exception:
   147→            pass  # Silently fail if open not available
   148→
   149→    print()
   150→
   151→    # Wait for user authentication
   152→    print("Waiting for authentication...")
   153→    result = app.acquire_token_by_device_flow(flow)
   154→
   155→    # Check for errors
   156→    if "error" in result:
   157→        error_desc = result.get("error_description", result.get("error"))
   158→        raise Exception(f"Authentication failed: {error_desc}")
   159→
   160→    if "access_token" not in result:
   161→        raise Exception("No access token in authentication response")
   162→
   163→    print("\n✓ Authentication successful!")
   164→
   165→    return result
   166→
   167→
   168→def acquire_outlook_token_via_refresh(refresh_token, params):
   169→    """
   170→    Use refresh token to acquire Outlook API access token.
   171→
   172→    This allows us to get tokens for both Graph and Outlook APIs
   173→    from a single interactive authentication.
   174→
   175→    Returns:
   176→        dict: Token response with access_token, refresh_token, etc.
   177→        None: If acquisition fails
   178→    """
   179→    print("\n[Both APIs] Acquiring Outlook API token using refresh token...")
   180→
   181→    token_endpoint = f"https://login.microsoftonline.com/{params['tenant_id']}/oauth2/v2.0/token"
   182→    outlook_scope = "https://outlook.office365.com/.default offline_access"
   183→
   184→    data = urllib.parse.urlencode(
   185→        {
   186→            "client_id": params["client_id"],
   187→            "grant_type": "refresh_token",
   188→            "refresh_token": refresh_token,
   189→            "scope": outlook_scope,
   190→        }
   191→    ).encode("utf-8")
   192→
   193→    headers = {
   194→        "Content-Type": "application/x-www-form-urlencoded",
   195→        "Accept": "application/json",
   196→    }
   197→
   198→    try:
   199→        req = urllib.request.Request(token_endpoint, data=data, headers=headers)
   200→        with urllib.request.urlopen(req, timeout=30) as response:
   201→            result = json.loads(response.read().decode("utf-8"))
   202→
   203→            if "access_token" in result:
   204→                print("✓ Outlook API token acquired successfully")
   205→                return result
   206→            else:
   207→                print("⚠ Outlook token response missing access_token")
   208→                return None
   209→
   210→    except urllib.error.HTTPError as e:
   211→        error_body = e.read().decode("utf-8")
   212→        print(f"⚠ Failed to acquire Outlook token (HTTP {e.code})")
   213→        try:
   214→            error_json = json.loads(error_body)
   215→            print(
   216→                f"  Error: {error_json.get('error_description', error_json.get('error', 'Unknown'))}"
   217→            )
   218→        except Exception:
   219→            print(f"  Response: {error_body[:200]}")
   220→        return None
   221→    except Exception as e:
   222→        print(f"⚠ Failed to acquire Outlook token: {e}")
   223→        return None
   224→
   225→
   226→def save_tokens(params, msal_result, token_dir, api_type="graph"):
   227→    """
   228→    Save tokens in format compatible with refresh_access_token.sh
   229→
   230→    Creates:
   231→    - oauth_tokens.json - Full OAuth response in token_dir
   232→    - {email}_refresh_only.txt - Refresh token
   233→    - {email}_access_token.json - Structured access token data (Graph API)
   234→    - {email}_outlook_access_token.json - Structured access token data (Outlook API, when api_type='outlook')
   235→    - {email}_access_only.txt - Raw access token
   236→
   237→    Args:
   238→        params: OAuth parameters dict
   239→        msal_result: Token response from MSAL or refresh
   240→        token_dir: Path to token directory
   241→        api_type: 'graph' or 'outlook' - determines file naming
   242→    """
   243→    email = params["email"]
   244→
   245→    # Determine file suffix based on API type
   246→    token_suffix = "_outlook" if api_type == "outlook" else ""
   247→    api_label = "Outlook" if api_type == "outlook" else "Graph"
   248→
   249→    # Ensure parent directories exist
   250→    token_dir.mkdir(parents=True, exist_ok=True)
   251→    tokens_parent = Path.home() / "config" / "outlook-creds" / "tokens"
   252→    tokens_parent.mkdir(parents=True, exist_ok=True)
   253→
   254→    # 1. Save full OAuth response to token_dir (only for primary/graph)
   255→    if api_type == "graph":
   256→        oauth_tokens = {
   257→            "access_token": msal_result["access_token"],
   258→            "refresh_token": msal_result.get("refresh_token", ""),
   259→            "token_type": msal_result.get("token_type", "Bearer"),
   260→            "expires_in": msal_result.get("expires_in", 3600),
   261→            "scope": msal_result.get("scope", " ".join(params.get("scopes", []))),
   262→            "account_id": params.get("account_id", ""),
   263→            "tenant_id": params["tenant_id"],
   264→            "email": email,
   265→            "obtained_via": "msal_device_code_flow",
   266→            "obtained_at": datetime.now(UTC).isoformat().replace("+00:00", "Z"),
   267→        }
   268→
   269→        oauth_file = token_dir / "oauth_tokens.json"
   270→        with open(oauth_file, "w") as f:
   271→            json.dump(oauth_tokens, f, indent=2)
   272→        oauth_file.chmod(0o600)
   273→
   274→    # 2. Save refresh token separately (only update from primary/graph response)
   275→    if api_type == "graph" and msal_result.get("refresh_token"):
   276→        refresh_file = tokens_parent / f"{email}_refresh_only.txt"
   277→        refresh_file.write_text(msal_result["refresh_token"])
   278→        refresh_file.chmod(0o600)
   279→        print(f"✓ Refresh token saved to: {refresh_file}")
   280→    elif api_type == "graph":
   281→        print("⚠ Warning: No refresh token in response")
   282→        print("  This may limit token refresh capabilities")
   283→
   284→    # 3. Create structured access token JSON
   285→    expires_at = datetime.now(UTC) + timedelta(seconds=msal_result.get("expires_in", 3600))
   286→
   287→    access_token_data = {
   288→        "email": email,
   289→        "access_token": msal_result["access_token"],
   290→        "token_type": msal_result.get("token_type", "Bearer"),
   291→        "expires_in": msal_result.get("expires_in", 3600),
   292→        "expires_at": expires_at.strftime("%Y-%m-%dT%H:%M:%SZ"),
   293→        "refreshed_at": datetime.now(UTC).strftime("%Y-%m-%dT%H:%M:%SZ"),
   294→        "scopes": msal_result.get("scope", ""),
   295→        "api_type": api_type,
   296→    }
   297→
   298→    # Use different filename for Outlook vs Graph
   299→    access_file = tokens_parent / f"{email}{token_suffix}_access_token.json"
   300→    with open(access_file, "w") as f:
   301→        json.dump(access_token_data, f, indent=2)
   302→    access_file.chmod(0o600)
   303→    print(f"✓ {api_label} access token saved to: {access_file}")
   304→
   305→    # 4. Save raw access token (different file for each API)
   306→    access_only_file = tokens_parent / f"{email}{token_suffix}_access_only.txt"
   307→    access_only_file.write_text(msal_result["access_token"])
   308→    access_only_file.chmod(0o600)
   309→    print(f"✓ {api_label} access token (raw) saved to: {access_only_file}")
   310→
   311→    print(f"\n✓ {api_label} tokens saved successfully")
   312→    print(f"  Token directory: {token_dir}")
   313→    print(f"  Expires at: {expires_at.strftime('%Y-%m-%d %I:%M:%S %p UTC')}")
   314→
   315→
   316→def main():
   317→    if len(sys.argv) < 2:
   318→        print(
   319→            "Usage: ./get_oauth_tokens.py <email> [--api=graph|outlook|both] [--scopes=scope1,scope2,...]"
   320→        )
   321→        print("Example: ./get_oauth_tokens.py broach@cresa.com")
   322→        print("         ./get_oauth_tokens.py broach@cresa.com --api=graph")
   323→        print("         ./get_oauth_tokens.py broach@cresa.com --api=outlook")
   324→        print("         ./get_oauth_tokens.py broach@cresa.com --api=both")
   325→        print(
   326→            "         ./get_oauth_tokens.py broach@cresa.com --scopes=https://graph.microsoft.com/Mail.ReadWrite,https://graph.microsoft.com/MailboxSettings.ReadWrite"
   327→        )
   328→        print("\nDefault: --api=graph (works with both Graph and Outlook APIs)")
   329→        print("Note: --scopes overrides --api if both are provided")
   330→        sys.exit(1)
   331→
   332→    email = sys.argv[1]
   333→
   334→    # Parse command line arguments
   335→    api_scope = "graph"  # Default to Graph (more versatile)
   336→    explicit_scopes = None
   337→
   338→    if len(sys.argv) > 2:
   339→        for arg in sys.argv[2:]:
   340→            if arg.startswith("--api="):
   341→                api_scope = arg.split("=")[1].lower()
   342→                if api_scope not in ["graph", "outlook", "both"]:
   343→                    print(
   344→                        f"Error: Invalid API scope '{api_scope}'. Use 'graph', 'outlook', or 'both'"
   345→                    )
   346→                    sys.exit(1)
   347→            elif arg.startswith("--scopes="):
   348→                scopes_str = arg.split("=", 1)[1]
   349→                explicit_scopes = [s.strip() for s in scopes_str.split(",") if s.strip()]
   350→                if not explicit_scopes:
   351→                    print("Error: --scopes cannot be empty")
   352→                    sys.exit(1)
   353→
   354→    print(f"Loading account information for {email}...")
   355→    account_info = load_account_info(email)
   356→
   357→    if not account_info:
   358→        sys.exit(1)
   359→
   360→    print("✓ Account information loaded")
   361→    print(f"  Account ID: {account_info['id']}")
   362→    print(f"  Tenant ID: {account_info['realm']}")
   363→    print(f"  Display Name: {account_info['display_name']}")
   364→    if explicit_scopes:
   365→        print(f"  Explicit Scopes: {', '.join(explicit_scopes)}")
   366→    else:
   367→        print(f"  API Scope: {api_scope}")
   368→    print()
   369→
   370→    params = extract_token_params(account_info, api_scope, explicit_scopes)
   371→    if not params:
   372→        sys.exit(1)
   373→
   374→    try:
   375→        print("Authenticating with Microsoft...")
   376→        tokens = authenticate_with_msal(params)
   377→    except Exception as e:
   378→        print(f"\nError during authentication: {e}")
   379→        print("\nTroubleshooting:")
   380→        print("  1. Make sure you completed the authentication in the browser")
   381→        print("  2. Check your internet connection")
   382→        print("  3. Verify the account is valid and has access to the tenant")
   383→        print("  4. Try running the script again")
   384→        sys.exit(1)
   385→
   386→    # Save tokens
   387→    token_dir = (
   388→        Path.home()
   389→        / "config"
   390→        / "outlook-creds"
   391→        / "tokens"
   392→        / email.replace("@", "_").replace(".", "_")
   393→    )
   394→
   395→    try:
   396→        # Save Graph API tokens (primary)
   397→        save_tokens(params, tokens, token_dir, api_type="graph")
   398→
   399→        # If 'both' was requested, also acquire Outlook API token
   400→        outlook_success = False
   401→        if api_scope == "both" and tokens.get("refresh_token"):
   402→            outlook_result = acquire_outlook_token_via_refresh(tokens["refresh_token"], params)
   403→            if outlook_result:
   404→                # Save Outlook tokens with 'outlook' suffix
   405→                save_tokens(params, outlook_result, token_dir, api_type="outlook")
   406→                outlook_success = True
   407→
   408→                # Update refresh token if a new one was provided
   409→                if outlook_result.get("refresh_token"):
   410→                    tokens_parent = Path.home() / "config" / "outlook-creds" / "tokens"
   411→                    refresh_file = tokens_parent / f"{email}_refresh_only.txt"
   412→                    refresh_file.write_text(outlook_result["refresh_token"])
   413→                    refresh_file.chmod(0o600)
   414→                    print("✓ Refresh token updated from Outlook response")
   415→            else:
   416→                print("\n⚠ Outlook API token acquisition failed")
   417→                print("  Graph API token is still valid and can be used")
   418→                print(
   419→                    "  You can retry Outlook setup later with: ./helpers/auth_helper.sh setup <email> <name> outlook"
   420→                )
   421→
   422→    except Exception as e:
   423→        print(f"\nError saving tokens: {e}")
   424→        sys.exit(1)
   425→
   426→    print()
   427→    print("=" * 70)
   428→    if api_scope == "both":
   429→        if outlook_success:
   430→            print("  SETUP COMPLETE - BOTH APIs CONFIGURED")
   431→        else:
   432→            print("  SETUP COMPLETE - GRAPH API ONLY (Outlook failed)")
   433→    else:
   434→        print("  SETUP COMPLETE")
   435→    print("=" * 70)
   436→    print("\nYou can now use the tokens for API calls:")
   437→    print(f"  ./helpers/auth_helper.sh get {email}           # Graph API (default)")
   438→    if api_scope == "both" and outlook_success:
   439→        print(f"  ./helpers/auth_helper.sh get {email} --api=outlook  # Outlook API")
   440→    print()
   441→
   442→    return 0
   443→
   444→
   445→if __name__ == "__main__":
   446→    sys.exit(main())
   447→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:04:03.937Z)**_

Now let me look at the store_credentials.sh and store_credentials.sh to understand token persistence:

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:04:04.145Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `/Users/hack/github/outlook-creds/scripts/store_credentials.sh`
```
     1→#!/usr/bin/env bash
     2→# store_credentials.sh - Manage credential storage and retrieval
     3→# Provides secure storage and easy access to Outlook credentials
     4→
     5→set -euo pipefail
     6→
     7→# Configuration
     8→CREDS_DIR="${HOME}/config/outlook-creds"
     9→TOKENS_DIR="${CREDS_DIR}/tokens"
    10→METADATA_DIR="${CREDS_DIR}/metadata"
    11→
    12→# Logging
    13→log() { echo "[$(date '+%Y-%m-%d %I:%M:%S %p')] $*" >&2; }
    14→error() { log "ERROR: $*"; }
    15→info() { log "INFO: $*"; }
    16→success() { log "SUCCESS: $*"; }
    17→
    18→# Create directories
    19→mkdir -p "$TOKENS_DIR" "$METADATA_DIR"
    20→
    21→# Function to store account metadata
    22→store_account_metadata() {
    23→    local email="$1"
    24→    local account_name="${2:-}"
    25→    local account_type="${3:-Exchange}"
    26→    local api_scope="${4:-graph}"  # graph, outlook, or both
    27→
    28→    local metadata_file="${METADATA_DIR}/${email}_metadata.json"
    29→
    30→    info "Storing metadata for: $email"
    31→
    32→    # Preserve created_at if file exists
    33→    local created_at
    34→    if [[ -f "$metadata_file" ]]; then
    35→        created_at=$(jq -r '.created_at // empty' "$metadata_file" 2>/dev/null)
    36→    fi
    37→    created_at="${created_at:-$(date -u +%Y-%m-%dT%H:%M:%SZ)}"
    38→
    39→    cat > "$metadata_file" <<EOF
    40→{
    41→  "email": "$email",
    42→  "account_name": "$account_name",
    43→  "account_type": "$account_type",
    44→  "api_scope": "$api_scope",
    45→  "created_at": "$created_at",
    46→  "updated_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
    47→}
    48→EOF
    49→
    50→    success "Metadata stored: $metadata_file"
    51→}
    52→
    53→# Function to list all stored accounts
    54→list_accounts() {
    55→    info "Listing all stored accounts..."
    56→
    57→    if [[ ! -d "$METADATA_DIR" ]]; then
    58→        error "No metadata directory found"
    59→        return 1
    60→    fi
    61→
    62→    local count=0
    63→    for metadata_file in "$METADATA_DIR"/*_metadata.json; do
    64→        if [[ ! -f "$metadata_file" ]]; then
    65→            continue
    66→        fi
    67→
    68→        ((count++)) || true
    69→
    70→        local email
    71→        local account_name
    72→        local account_type
    73→        local api_scope
    74→        local updated_at
    75→
    76→        email=$(jq -r '.email // "unknown"' "$metadata_file")
    77→        account_name=$(jq -r '.account_name // "N/A"' "$metadata_file")
    78→        account_type=$(jq -r '.account_type // "N/A"' "$metadata_file")
    79→        api_scope=$(jq -r '.api_scope // "graph"' "$metadata_file")
    80→        updated_at=$(jq -r '.updated_at // "N/A"' "$metadata_file")
    81→
    82→        # Convert UTC timestamp to local 12-hour format for display
    83→        local updated_display="$updated_at"
    84→        if [[ "$updated_at" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}Z$ ]]; then
    85→            local updated_epoch
    86→            updated_epoch=$(date -j -u -f "%Y-%m-%dT%H:%M:%SZ" "$updated_at" "+%s" 2>/dev/null)
    87→            if [[ -n "$updated_epoch" ]]; then
    88→                updated_display=$(date -j -f "%s" "$updated_epoch" "+%b %d %I:%M %p" 2>/dev/null || echo "$updated_at")
    89→            fi
    90→        fi
    91→
    92→        echo "[$count] $email"
    93→        echo "    Name: $account_name"
    94→        echo "    Type: $account_type"
    95→        echo "    API Scope: $api_scope"
    96→        echo "    Updated: $updated_display"
    97→
    98→        # Check token status
    99→        local token_file="${TOKENS_DIR}/${email}_access_token.json"
   100→        local outlook_token_file="${TOKENS_DIR}/${email}_outlook_access_token.json"
   101→        if [[ -f "$token_file" ]]; then
   102→            local expires_at expires_display
   103→            expires_at=$(jq -r '.expires_at // "unknown"' "$token_file")
   104→
   105→            # Convert UTC timestamp to local 12-hour format
   106→            expires_display="$expires_at"
   107→            if [[ "$expires_at" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}Z$ ]]; then
   108→                local expires_epoch
   109→                expires_epoch=$(date -j -u -f "%Y-%m-%dT%H:%M:%SZ" "$expires_at" "+%s" 2>/dev/null)
   110→                if [[ -n "$expires_epoch" ]]; then
   111→                    expires_display=$(date -j -f "%s" "$expires_epoch" "+%b %d %I:%M %p" 2>/dev/null || echo "$expires_at")
   112→                fi
   113→            fi
   114→
   115→            echo "    Graph Token: Valid until $expires_display"
   116→        else
   117→            echo "    Graph Token: Not found"
   118→        fi
   119→
   120→        # Check Outlook token if api_scope is 'both' or 'outlook'
   121→        if [[ "$api_scope" == "both" || "$api_scope" == "outlook" ]]; then
   122→            if [[ -f "$outlook_token_file" ]]; then
   123→                local outlook_expires_at outlook_expires_display
   124→                outlook_expires_at=$(jq -r '.expires_at // "unknown"' "$outlook_token_file")
   125→
   126→                # Convert UTC timestamp to local 12-hour format
   127→                outlook_expires_display="$outlook_expires_at"
   128→                if [[ "$outlook_expires_at" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}Z$ ]]; then
   129→                    local outlook_expires_epoch
   130→                    outlook_expires_epoch=$(date -j -u -f "%Y-%m-%dT%H:%M:%SZ" "$outlook_expires_at" "+%s" 2>/dev/null)
   131→                    if [[ -n "$outlook_expires_epoch" ]]; then
   132→                        outlook_expires_display=$(date -j -f "%s" "$outlook_expires_epoch" "+%b %d %I:%M %p" 2>/dev/null || echo "$outlook_expires_at")
   133→                    fi
   134→                fi
   135→
   136→                echo "    Outlook Token: Valid until $outlook_expires_display"
   137→            else
   138→                echo "    Outlook Token: Not found"
   139→            fi
   140→        fi
   141→
   142→        echo ""
   143→    done
   144→
   145→    if [[ $count -eq 0 ]]; then
   146→        info "No accounts found"
   147→        return 1
   148→    fi
   149→
   150→    info "Total accounts: $count"
   151→}
   152→
   153→# Function to get credentials for an account
   154→get_credentials() {
   155→    local email="$1"
   156→    local format="${2:-json}"
   157→
   158→    local access_token_file="${TOKENS_DIR}/${email}_access_token.json"
   159→    local refresh_token_file="${TOKENS_DIR}/${email}_refresh_only.txt"
   160→    local metadata_file="${METADATA_DIR}/${email}_metadata.json"
   161→
   162→    if [[ ! -f "$metadata_file" ]]; then
   163→        error "Account not found: $email"
   164→        return 1
   165→    fi
   166→
   167→    case "$format" in
   168→        json)
   169→            # Return full credential JSON
   170→            local access_token=""
   171→            local refresh_token=""
   172→            local expires_at=""
   173→            local token_type=""
   174→
   175→            if [[ -f "$access_token_file" ]]; then
   176→                access_token=$(jq -r '.access_token // ""' "$access_token_file")
   177→                expires_at=$(jq -r '.expires_at // ""' "$access_token_file")
   178→                token_type=$(jq -r '.token_type // "Bearer"' "$access_token_file")
   179→            fi
   180→
   181→            if [[ -f "$refresh_token_file" ]]; then
   182→                refresh_token=$(cat "$refresh_token_file")
   183→            fi
   184→
   185→            cat <<EOF
   186→{
   187→  "email": "$email",
   188→  "access_token": "$access_token",
   189→  "refresh_token": "$refresh_token",
   190→  "token_type": "$token_type",
   191→  "expires_at": "$expires_at"
   192→}
   193→EOF
   194→            ;;
   195→
   196→        access-token)
   197→            # Return just the access token
   198→            if [[ -f "${TOKENS_DIR}/${email}_access_only.txt" ]]; then
   199→                cat "${TOKENS_DIR}/${email}_access_only.txt"
   200→            else
   201→                error "Access token not found"
   202→                return 1
   203→            fi
   204→            ;;
   205→
   206→        refresh-token)
   207→            # Return just the refresh token
   208→            if [[ -f "$refresh_token_file" ]]; then
   209→                cat "$refresh_token_file"
   210→            else
   211→                error "Refresh token not found"
   212→                return 1
   213→            fi
   214→            ;;
   215→
   216→        header)
   217→            # Return as Authorization header
   218→            if [[ -f "${TOKENS_DIR}/${email}_access_only.txt" ]]; then
   219→                local token
   220→                token=$(cat "${TOKENS_DIR}/${email}_access_only.txt")
   221→                echo "Authorization: Bearer $token"
   222→            else
   223→                error "Access token not found"
   224→                return 1
   225→            fi
   226→            ;;
   227→
   228→        curl)
   229→            # Return as curl -H option
   230→            if [[ -f "${TOKENS_DIR}/${email}_access_only.txt" ]]; then
   231→                local token
   232→                token=$(cat "${TOKENS_DIR}/${email}_access_only.txt")
   233→                echo "-H 'Authorization: Bearer $token' -H 'X-User-Identity: $email'"
   234→            else
   235→                error "Access token not found"
   236→                return 1
   237→            fi
   238→            ;;
   239→
   240→        *)
   241→            error "Unknown format: $format"
   242→            return 1
   243→            ;;
   244→    esac
   245→}
   246→
   247→# Function to delete account credentials
   248→delete_account() {
   249→    local email="$1"
   250→    local confirm="${2:-no}"
   251→
   252→    if [[ "$confirm" != "yes" ]]; then
   253→        error "Please confirm deletion by passing 'yes' as second argument"
   254→        return 1
   255→    fi
   256→
   257→    info "Deleting credentials for: $email"
   258→
   259→    # Remove all files for this account
   260→    rm -f "${TOKENS_DIR}/${email}"_*
   261→    rm -f "${METADATA_DIR}/${email}_metadata.json"
   262→
   263→    success "Deleted credentials for: $email"
   264→}
   265→
   266→# Function to export all credentials (for backup)
   267→export_credentials() {
   268→    local output_file="${1:-${CREDS_DIR}/backup_$(date +%Y%m%d_%H%M%S).tar.gz}"
   269→
   270→    info "Exporting credentials to: $output_file"
   271→
   272→    tar -czf "$output_file" -C "$CREDS_DIR" tokens metadata
   273→
   274→    success "Credentials exported to: $output_file"
   275→    info "Keep this file secure - it contains sensitive authentication tokens"
   276→}
   277→
   278→# Function to import credentials (from backup)
   279→import_credentials() {
   280→    local backup_file="$1"
   281→
   282→    if [[ ! -f "$backup_file" ]]; then
   283→        error "Backup file not found: $backup_file"
   284→        return 1
   285→    fi
   286→
   287→    info "Importing credentials from: $backup_file"
   288→
   289→    tar -xzf "$backup_file" -C "$CREDS_DIR"
   290→
   291→    success "Credentials imported successfully"
   292→}
   293→
   294→# Main execution
   295→main() {
   296→    local command="${1:-}"
   297→
   298→    case "$command" in
   299→        store)
   300→            store_account_metadata "${2:-}" "${3:-}" "${4:-}" "${5:-graph}"
   301→            ;;
   302→        list)
   303→            list_accounts
   304→            ;;
   305→        get)
   306→            get_credentials "${2:-}" "${3:-json}"
   307→            ;;
   308→        delete)
   309→            delete_account "${2:-}" "${3:-no}"
   310→            ;;
   311→        export)
   312→            export_credentials "${2:-}"
   313→            ;;
   314→        import)
   315→            import_credentials "${2:-}"
   316→            ;;
   317→        *)
   318→            cat <<EOF
   319→Usage: $0 <command> [options]
   320→
   321→Commands:
   322→  store <email> [name] [type] [api_scope]  - Store account metadata
   323→                                             api_scope: graph (default), outlook, or both
   324→  list                                     - List all stored accounts
   325→  get <email> [format]         - Get credentials for account
   326→  delete <email> yes           - Delete account credentials
   327→  export [file]                - Export all credentials to backup
   328→  import <file>                - Import credentials from backup
   329→
   330→Get Formats:
   331→  json          - Full JSON object (default)
   332→  access-token  - Just the access token
   333→  refresh-token - Just the refresh token
   334→  header        - As Authorization header
   335→  curl          - As curl headers
   336→
   337→Examples:
   338→  $0 list
   339→  $0 get user@example.com
   340→  $0 get user@example.com access-token
   341→  $0 get user@example.com curl
   342→  $0 export ~/backup.tar.gz
   343→  $0 delete user@example.com yes
   344→EOF
   345→            ;;
   346→    esac
   347→}
   348→
   349→main "$@"
   350→
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:04:12.652Z)**_

Perfect! Now let me compile a comprehensive analysis report. Let me search for one more file to check the configuration module:

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:04:12.953Z)**_

<tool-use data-tool-type="shell" data-tool-name="Bash"><details>
<summary>Tool use: **Bash**</summary>

`find /Users/hack/github/outlook-creds/src -name "config.py" -o -name "__init__.py" | head -5`
```
/Users/hack/github/outlook-creds/src/outlook_creds/config.py
/Users/hack/github/outlook-creds/src/outlook_creds/auth/__init__.py
/Users/hack/github/outlook-creds/src/outlook_creds/__init__.py
/Users/hack/github/outlook-creds/src/outlook_creds/utils/__init__.py
/Users/hack/github/outlook-creds/src/outlook_creds/cli/__init__.py
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:04:20.483Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `/Users/hack/github/outlook-creds/src/outlook_creds/config.py`
```
     1→"""Centralized configuration for outlook-creds.
     2→
     3→All paths and configuration values are defined here to avoid
     4→hardcoded paths scattered throughout the codebase.
     5→"""
     6→
     7→import os
     8→import stat
     9→
    10→# tomllib is Python 3.11+; for 3.10 we fall back to regex parsing
    11→import tomllib  # Will use regex fallback
    12→from pathlib import Path
    13→from typing import Any
    14→
    15→# Expected project name - used to verify we found the right pyproject.toml
    16→_EXPECTED_PROJECT_NAME = "outlook-creds"
    17→
    18→
    19→def _extract_project_name(pyproject_path: Path) -> str:
    20→    """Extract project name from pyproject.toml.
    21→
    22→    Uses tomllib on Python 3.11+, falls back to regex on 3.10.
    23→    """
    24→    if tomllib is not None:
    25→        # Python 3.11+: use tomllib
    26→        try:
    27→            with open(pyproject_path, "rb") as f:
    28→                data = tomllib.load(f)
    29→            return data.get("project", {}).get("name", "")
    30→        except Exception:
    31→            return ""
    32→    else:
    33→        # Python 3.10: use regex fallback
    34→        import re
    35→
    36→        try:
    37→            content = pyproject_path.read_text()
    38→            # Match: name = "outlook-creds" or name = 'outlook-creds'
    39→            match = re.search(r'^name\s*=\s*["\']([^"\']+)["\']', content, re.MULTILINE)
    40→            return match.group(1) if match else ""
    41→        except Exception:
    42→            return ""
    43→
    44→
    45→def _find_project_root() -> Path:
    46→    """Find project root by searching for the correct pyproject.toml.
    47→
    48→    Walks up from the current file's location until a pyproject.toml with
    49→    the expected project name is found. This prevents issues in monorepos
    50→    where a parent directory might have a different pyproject.toml.
    51→
    52→    Returns:
    53→        Path to project root directory
    54→    """
    55→    current = Path(__file__).resolve().parent
    56→    for parent in [current] + list(current.parents):
    57→        pyproject = parent / "pyproject.toml"
    58→        if pyproject.exists():
    59→            project_name = _extract_project_name(pyproject)
    60→            if project_name == _EXPECTED_PROJECT_NAME:
    61→                return parent
    62→            # Found a pyproject.toml but wrong project, keep searching
    63→
    64→    # Fallback: assume standard src layout (3 levels up from config.py)
    65→    # This allows the package to work even without pyproject.toml (e.g., in tests)
    66→    fallback = Path(__file__).resolve().parent.parent.parent.parent
    67→    import warnings
    68→
    69→    warnings.warn(
    70→        f"Could not find pyproject.toml with project name '{_EXPECTED_PROJECT_NAME}'. "
    71→        f"Using fallback path: {fallback}",
    72→        RuntimeWarning,
    73→        stacklevel=2,
    74→    )
    75→    return fallback
    76→
    77→
    78→# Project root (found dynamically)
    79→PROJECT_ROOT = _find_project_root()
    80→
    81→# Allow override via environment variable for testing
    82→CONFIG_DIR = Path(
    83→    os.getenv("OUTLOOK_CREDS_CONFIG_DIR", str(Path.home() / "config" / "outlook-creds"))
    84→)
    85→
    86→# Token storage
    87→TOKENS_DIR = CONFIG_DIR / "tokens"
    88→
    89→# Cache storage
    90→CACHE_DIR = CONFIG_DIR / "cache"
    91→
    92→# User config storage
    93→USER_CONFIG_PATH = CONFIG_DIR / "config.json"
    94→
    95→# Logs (macOS standard location)
    96→LOGS_DIR = Path(
    97→    os.getenv("OUTLOOK_CREDS_LOGS_DIR", str(Path.home() / "Library" / "Logs" / "outlook-creds"))
    98→)
    99→
   100→# Inspection output (git-ignored) - relative to project root
```
</details></tool-use>

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:04:25.835Z)**_

Now let me generate the comprehensive trace document:

## MSAL Device-Code Flow Implementation Trace

I've thoroughly explored the inbox-zero codebase and created a detailed trace of the MSAL device-code flow implementation. Here's the complete architecture:

---

### **1. OVERVIEW & PURPOSE**

The MSAL device-code flow provides an **alternative authentication method** for Microsoft accounts, enabling users to authenticate without browser-based OAuth redirects. This is useful in CLI/headless environments or when standard OAuth is unavailable.

**Key Characteristics:**
- Uses Azure MSAL Node.js library (`@azure/msal-node`)
- Completely non-breaking: runs parallel to existing Better Auth OAuth
- In-memory token cache for background token refresh
- 15-minute expiration windows with cleanup
- Supports both email access and calendar synchronization

---

### **2. AUTHENTICATION FLOW TRACE**

#### **Phase 1: User Initiation (Frontend)**

**File:** `/Users/hack/github/inbox-zero/apps/web/app/(landing)/login/DeviceCodeLogin.tsx`

The flow starts when user clicks "Start Device Code Flow":

```typescript
// Lines 216-245: initiateFlow hook
const initiateFlow = useCallback(async () => {
  setFlowState("initiated");
  setError(null);
  setDeviceCode(null);

  const response = await fetch("/api/outlook/device-code/initiate", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({}),
  });

  const data: DeviceCodeResponse = await response.json();
  setDeviceCode(data);
  setFlowState("polling");
  activeSessionIdRef.current = data.sessionId;

  pollTimeoutRef.current = setTimeout(() => {
    poll(data.sessionId);
  }, 3000); // Start polling after 3 seconds
}, [poll]);
```

**UI Flow:**
1. User clicks "Start Device Code Flow"
2. Component displays loading spinner
3. Once initiated, displays verification code and URL
4. User copies code and opens verification URL in browser
5. Component polls for completion every 3 seconds

---

#### **Phase 2: Device Code Initiation (Backend)**

**File:** `/Users/hack/github/inbox-zero/apps/web/app/api/outlook/device-code/initiate/route.ts`

Endpoint: `POST /api/outlook/device-code/initiate`

```typescript
// Lines 11-40
export async function POST() {
  if (!isMSALDeviceCodeEnabled()) {
    return NextResponse.json(
      { error: "MSAL device code authentication is not enabled" },
      { status: 403 },
    );
  }

  try {
    const sessionId = nanoid(); // Generate unique session ID
    const result = await initiateDeviceCodeFlow(sessionId);

    return NextResponse.json({
      sessionId: result.sessionId,
      userCode: result.userCode,
      verificationUri: result.verificationUri,
      expiresAt: result.expiresAt.toISOString(),
      message: result.message,
    });
  } catch (error) {
    logger.error("Device code initiation failed", { error });
    return NextResponse.json(
      { error: `Failed to initiate device code flow: ${errorMessage}` },
      { status: 500 },
    );
  }
}
```

---

#### **Phase 3: MSAL Flow Initiation**

**File:** `/Users/hack/github/inbox-zero/apps/web/utils/outlook/msal-device-code.ts`

**Key Function:** `initiateDeviceCodeFlow()` (Lines 208-322)

```typescript
export async function initiateDeviceCodeFlow(
  sessionId: string,
): Promise<DeviceCodeInitResponse> {
  if (!isMSALDeviceCodeEnabled()) {
    throw new Error("MSAL device code flow is not enabled");
  }

  const app = getMSALApp(); // Get/create singleton MSAL app

  cleanupExpiredFlows();

  if (activeFlows.has(sessionId)) {
    throw new Error("Session already exists");
  }

  // Create promise that resolves when authentication completes
  let flowResolve: (result: AuthenticationResult | null) => void;
  let flowReject: (error: Error) => void;
  let capturedDeviceCode: DeviceCodeResponse | null = null;

  const flowPromise = new Promise<AuthenticationResult | null>(
    (resolve, reject) => {
      flowResolve = resolve;
      flowReject = reject;
    },
  );

  const deviceCodeRequest: DeviceCodeRequest = {
    scopes: ["https://graph.microsoft.com/.default"],
    deviceCodeCallback: (response: DeviceCodeResponse) => {
      capturedDeviceCode = response;

      // Calculate expiration time from expiresIn (seconds)
      const expiresAt = new Date(Date.now() + response.expiresIn * 1000);

      // Store flow info for polling
      activeFlows.set(sessionId, {
        deviceCode: response.deviceCode,
        userCode: response.userCode,
        verificationUri: response.verificationUri,
        expiresAt,
        message: response.message,
        promise: flowPromise,
        resolve: flowResolve!,
        reject: flowReject!,
      });

      logger.info("Device code flow initiated", {
        sessionId,
        userCode: response.userCode,
        expiresAt: expiresAt.toISOString(),
      });
    },
    timeout: 900, // 15 minutes
  };

  // Start the flow (non-blocking)
  const authPromise = app.acquireTokenByDeviceCode(deviceCodeRequest);

  // Wait for callback to be called
  await new Promise<void>((resolve, reject) => {
    const checkInterval = setInterval(() => {
      if (capturedDeviceCode) {
        clearInterval(checkInterval);
        resolve();
      }
    }, 100);

    // Timeout after 10 seconds
    setTimeout(() => {
      clearInterval(checkInterval);
      if (!capturedDeviceCode) {
        reject(new Error("Device code callback timeout"));
      }
    }, 10_000);
  });

  const flow = activeFlows.get(sessionId);
  const deviceCodeInfo = capturedDeviceCode as DeviceCodeResponse | null;
  if (!flow || !deviceCodeInfo) {
    throw new Error("Failed to initiate device code flow");
  }

  // Wire up the auth promise to resolve/reject the flow
  authPromise
    .then((result: AuthenticationResult | null) => {
      logger.info("Device code flow completed", { sessionId });
      flow.resolve(result);
    })
    .catch((error: Error) => {
      logger.error("Device code flow failed", {
        sessionId,
        error: error.message,
        name: error.name,
        stack: error.stack?.split("\n").slice(0, 5).join("\n"),
      });
      flow.reject(error);
    });

  return {
    sessionId,
    userCode: deviceCodeInfo.userCode,
    verificationUri: deviceCodeInfo.verificationUri,
    expiresAt: new Date(Date.now() + deviceCodeInfo.expiresIn * 1000),
    message: deviceCodeInfo.message,
  };
}
```

**MSAL App Singleton:** Lines 116-151

```typescript
function getMSALApp(): PublicClientApplication {
  if (!msalApp) {
    const clientId =
      env.MSAL_CLIENT_ID ||
      env.MICROSOFT_CLIENT_ID ||
      MICROSOFT_OFFICE_CLIENT_ID; // d3590ed6-52b3-4102-aeff-aad2292ab01c

    const tenantId = env.MSAL_TENANT_ID || env.MICROSOFT_TENANT_ID || "common";
    const debugEnabled = env.MSAL_DEBUG === "true";

    msalApp = new PublicClientApplication({
      auth: {
        clientId,
        authority: `https://login.microsoftonline.com/${tenantId}`,
      },
      system: {
        loggerOptions: {
          loggerCallback: (level: LogLevel, message: string, containsPii: boolean) => {
            if (containsPii) return; // Don't log PII
            if (debugEnabled || level === LogLevel.Error) {
              logger.info(`MSAL [${LogLevel[level]}]: ${message}`);
            }
          },
          piiLoggingEnabled: false,
          logLevel: debugEnabled ? LogLevel.Verbose : LogLevel.Error,
        },
        // Custom network module to handle Node.js 22+ undici issues
        networkClient: new CustomNetworkModule(),
      },
    });
  }
  return msalApp;
}
```

**Custom Network Module:** Lines 32-91
- Workaround for Node.js 22+ undici connection pool issues
- Fresh fetch calls with 30-second timeout
- Disables keep-alive to avoid connection pool reuse

---

#### **Phase 4: Polling for Completion (Frontend)**

**File:** `/Users/hack/github/inbox-zero/apps/web/app/(landing)/login/DeviceCodeLogin.tsx`

**Polling Hook:** Lines 158-214

```typescript
const poll = useCallback(
  async (sessionId: string) => {
    if (pollInFlightRef.current) return;
    pollInFlightRef.current = true;

    try {
      const response = await fetch("/api/outlook/device-code/poll", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ sessionId }),
      });

      const data: PollResponse = await response.json();

      if (activeSessionIdRef.current !== sessionId) return;

      if (data.status === "complete") {
        cleanup();
        setFlowState("complete");
        toastSuccess({ description: data.message });
        setTimeout(() => {
          onComplete?.();
          window.location.href = data.redirectUrl || "/welcome";
        }, 1500);
        return;
      }

      if (data.status === "expired") {
        cleanup();
        setError("The device code has expired. Please try again.");
        setFlowState("error");
        return;
      }

      if (data.status === "error") {
        cleanup();
        setError(data.error || "Authentication failed");
        setFlowState("error");
        return;
      }

      // Still pending - schedule next poll
      pollTimeoutRef.current = setTimeout(() => {
        poll(sessionId);
      }, 3000); // Poll every 3 seconds
    } catch (_err) {
      cleanup();
      setError("Failed to check authentication status");
      setFlowState("error");
    } finally {
      pollInFlightRef.current = false;
    }
  },
  [cleanup, onComplete],
);
```

---

#### **Phase 5: Server-Side Polling**

**File:** `/Users/hack/github/inbox-zero/apps/web/app/api/outlook/device-code/poll/route.ts`

Endpoint: `POST /api/outlook/device-code/poll`

**Polling Logic:** Lines 41-125

```typescript
export async function POST(request: NextRequest) {
  if (!isMSALDeviceCodeEnabled()) {
    return NextResponse.json(
      { error: "MSAL device code authentication is not enabled" },
      { status: 403 },
    );
  }

  try {
    const body = await request.json();
    const { sessionId } = pollRequestSchema.parse(body);

    logger.info("Poll request received", { sessionId });

    cleanupCompletionCache();
    const cachedCompletion = completionCache.get(sessionId);
    if (cachedCompletion) {
      return respondWithCompletionPromise({
        sessionId,
        entry: cachedCompletion,
      });
    }

    const pollResult = await pollDeviceCodeFlow(sessionId);

    logger.info("Poll result", { sessionId, status: pollResult.status });

    if (pollResult.status === "pending") {
      return NextResponse.json({ status: "pending" });
    }

    if (pollResult.status === "expired") {
      const completedEntry = completionCache.get(sessionId);
      if (completedEntry) {
        return respondWithCompletionPromise({
          sessionId,
          entry: completedEntry,
        });
      }
      logger.info("Flow expired or not found", { sessionId });
      return NextResponse.json({ status: "expired" });
    }

    if (pollResult.status === "error") {
      logger.error("Flow error", { sessionId, error: pollResult.error });
      return NextResponse.json({
        status: "error",
        error: pollResult.error,
      });
    }

    // Authentication complete - create/update account
    if (pollResult.status === "complete" && pollResult.result) {
      const completionPromise = completeDeviceCodeAuthentication({
        pollResult: pollResult.result,
        request,
      });

      completionCache.set(sessionId, {
        promise: completionPromise,
        expiresAt: new Date(Date.now() + COMPLETION_CACHE_TTL_MS),
      });

      return respondWithCompletionPromise({
        sessionId,
        entry: completionCache.get(sessionId)!,
      });
    }

    return NextResponse.json({ status: pollResult.status });
  } catch (error) {
    logger.error("Poll failed", { error });
    return NextResponse.json(
      { status: "error", error: "Poll failed" },
      { status: 500 },
    );
  }
}
```

**Poll Check Function:** Lines 338-406

```typescript
export async function pollDeviceCodeFlow(
  sessionId: string,
): Promise<PollResult> {
  logger.info("Poll called", {
    sessionId,
    activeFlowCount: activeFlows.size,
    hasFlow: activeFlows.has(sessionId),
  });

  const flow = activeFlows.get(sessionId);

  if (!flow) {
    logger.info("Flow not found in activeFlows", { sessionId });
    return { status: "expired" };
  }

  if (new Date() > flow.expiresAt) {
    logger.info("Flow expired", { sessionId, expiresAt: flow.expiresAt });
    activeFlows.delete(sessionId);
    return { status: "expired" };
  }

  // Non-blocking check - use Promise.race to avoid waiting
  const raceResult = await Promise.race([
    flow.promise
      .then((result) => ({ done: true as const, result, error: null }))
      .catch((error) => ({ done: true as const, result: null, error })),
    new Promise<{ done: false }>((resolve) =>
      setTimeout(() => resolve({ done: false }), 100),
    ),
  ]);

  if (!raceResult.done) {
    return { status: "pending" };
  }

  // Flow completed - clean up
  activeFlows.delete(sessionId);

  if (raceResult.error) {
    const errorMessage =
      raceResult.error instanceof Error
        ? raceResult.error.message
        : String(raceResult.error);

    if (errorMessage.includes("authorization_pending")) {
      return { status: "pending" };
    }

    logger.error("Device code flow error", { sessionId, error: errorMessage });
    return { status: "error", error: errorMessage };
  }

  if (!raceResult.result) {
    return { status: "error", error: "No authentication result" };
  }

  return {
    status: "complete",
    result: {
      accessToken: raceResult.result.accessToken,
      expiresAt: raceResult.result.expiresOn || new Date(Date.now() + 3_600_000),
      scopes: raceResult.result.scopes,
      account: raceResult.result.account,
    },
  };
}
```

---

#### **Phase 6: Account Creation & Session Setup**

**File:** `/Users/hack/github/inbox-zero/apps/web/app/api/outlook/device-code/poll/route.ts`

**Function:** `completeDeviceCodeAuthentication()` (Lines 148-275)

```typescript
async function completeDeviceCodeAuthentication({
  pollResult,
  request,
}: {
  pollResult: PollCompleteResult;
  request: NextRequest;
}): Promise<CompletionResult> {
  const { accessToken, expiresAt, scopes, account } = pollResult;

  if (!account) {
    throw new Error("No account info in token response");
  }

  // Get user profile from Microsoft Graph
  const client = createOutlookClient(accessToken, logger);
  const profile = await client.getUserProfile();

  const email = profile.mail?.toLowerCase() || profile.userPrincipalName?.toLowerCase();
  const name = profile.displayName;
  const providerAccountId = account.localAccountId;

  if (!email) {
    throw new Error("Could not determine user email");
  }

  // Encrypt tokens
  const encryptedAccessToken = encryptToken(accessToken);

  // Find or create user
  let user = await prisma.user.findUnique({
    where: { email },
  });

  if (!user) {
    user = await prisma.user.create({
      data: {
        email,
        name: name || email,
        emailVerified: true,
      },
    });
    logger.info("Created new user via MSAL device code", { email });
  }

  // Create or update account
  // Note: MSAL device code flow doesn't provide refresh_token
  const accountRecord = await prisma.account.upsert({
    where: {
      provider_providerAccountId: {
        provider: "microsoft",
        providerAccountId,
      },
    },
    create: {
      userId: user.id,
      provider: "microsoft",
      providerAccountId,
      access_token: encryptedAccessToken,
      refresh_token: null, // MSAL doesn't expose refresh token
      expires_at: expiresAt,
      token_type: "Bearer",
      scope: scopes.join(" "),
    },
    update: {
      access_token: encryptedAccessToken,
      expires_at: expiresAt,
      scope: scopes.join(" "),
    },
  });

  logger.info("MSAL device code authentication complete", {
    email,
    providerAccountId,
  });

  // Update email account and reconnect
  await prisma.$transaction([
    prisma.emailAccount.upsert({
      where: { email },
      update: {
        userId: user.id,
        accountId: accountRecord.id,
        name: name || email,
      },
      create: {
        email,
        userId: user.id,
        accountId: accountRecord.id,
        name: name || email,
      },
    }),
    prisma.account.update({
      where: { id: accountRecord.id },
      data: { disconnectedAt: null },
    }),
  ]);

  // Create Better Auth session
  const sessionToken = crypto.randomUUID();
  const sessionExpires = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000); // 30 days

  await prisma.session.create({
    data: {
      sessionToken,
      userId: user.id,
      expires: sessionExpires,
      ipAddress: request.headers.get("x-forwarded-for") || "unknown",
      userAgent: request.headers.get("user-agent") || "unknown",
    },
  });

  logger.info("Created session for MSAL device code user", {
    email,
    userId: user.id,
  });

  const signedSessionToken = await signSessionToken(sessionToken);

  return {
    email,
    redirectUrl: WELCOME_PATH,
    message: "Authentication successful! Redirecting...",
    signedSessionToken,
    sessionExpires,
  };
}
```

---

### **3. TOKEN STORAGE & RETRIEVAL**

#### **Storage Structure**

**File:** `/Users/hack/github/inbox-zero/apps/web/app/api/user/email-accounts/route.ts`

The `getEmailAccounts()` function identifies device-code authenticated accounts:

```typescript
// Lines 38-72
const accountsWithNames = emailAccounts.map((emailAccount) => {
  // Compute if this is a device-code authenticated account
  // Device-code accounts have refresh_token = null with microsoft provider
  const isDeviceCodeAuth =
    emailAccount.account?.provider === "microsoft" &&
    !emailAccount.account?.refresh_token;

  // Extract providerAccountId for MSAL token lookup
  const providerAccountId = emailAccount.account?.providerAccountId || null;

  // Remove refresh_token from the response (security - don't expose to client)
  const { refresh_token: _refreshToken, ...accountWithoutToken } =
    emailAccount.account || {};

  return {
    ...emailAccount,
    account: accountWithoutToken,
    isDeviceCodeAuth,
    providerAccountId,
  };
});
```

**Database Schema Implications:**
- `Account.provider`: "microsoft"
- `Account.providerAccountId`: MSAL's `account.localAccountId` (identifies account in MSAL cache)
- `Account.refresh_token`: `null` (device-code flow doesn't provide refresh tokens)
- `Account.access_token`: Encrypted access token (initial or cached)
- `Account.expires_at`: Token expiration time

#### **Token Refresh via MSAL Silent Acquisition**

**File:** `/Users/hack/github/inbox-zero/apps/web/utils/outlook/msal-device-code.ts`

**Function:** `acquireMSALTokenSilent()` (Lines 438-504)

```typescript
export async function acquireMSALTokenSilent(
  providerAccountId: string,
  scopes: string[] = MSAL_DEVICE_CODE_SCOPES,
): Promise<{
  accessToken: string;
  expiresAt: Date;
  account: AccountInfo;
} | null> {
  if (!isMSALDeviceCodeEnabled()) {
    logger.warn("MSAL device code flow is not enabled");
    return null;
  }

  const app = getMSALApp();
  const tokenCache = app.getTokenCache();

  try {
    // Get all accounts from MSAL cache
    const accounts = await tokenCache.getAllAccounts();

    if (accounts.length === 0) {
      logger.info("No accounts found in MSAL cache");
      return null;
    }

    // Find the account matching the providerAccountId
    const account = accounts.find(
      (acc: AccountInfo) => acc.localAccountId === providerAccountId,
    );

    if (!account) {
      logger.info("Account not found in MSAL cache", {
        providerAccountId,
        cachedAccountIds: accounts.map((a: AccountInfo) => a.localAccountId),
      });
      return null;
    }

    // Acquire token silently using cached credentials
    const result = await app.acquireTokenSilent({
      account,
      scopes,
    });

    if (!result) {
      logger.warn("acquireTokenSilent returned null", { providerAccountId });
      return null;
    }

    logger.info("Successfully acquired token silently", {
      providerAccountId,
      expiresOn: result.expiresOn?.toISOString(),
    });

    return {
      accessToken: result.accessToken,
      expiresAt: result.expiresOn || new Date(Date.now() + 3_600_000),
      account,
    };
  } catch (error) {
    logger.error("Failed to acquire token silently", {
      providerAccountId,
      error: error instanceof Error ? error.message : String(error),
    });
    return null;
  }
}
```

---

### **4. EMAIL CLIENT TOKEN REFRESH**

**File:** `/Users/hack/github/inbox-zero/apps/web/utils/outlook/client.ts`

**Function:** `getOutlookClientWithRefresh()` (Lines 88-259)

This function handles token refresh for email operations:

```typescript
export const getOutlookClientWithRefresh = async ({
  accessToken,
  refreshToken,
  expiresAt,
  emailAccountId,
  providerAccountId,
  logger,
}: {
  accessToken?: string | null;
  refreshToken: string | null;
  expiresAt: number | null;
  emailAccountId: string;
  providerAccountId?: string | null;
  logger: Logger;
}): Promise<OutlookClient> => {
  // Check if token is still valid
  const expiryDate = expiresAt ? expiresAt : null;
  const TOKEN_REFRESH_BUFFER_MS = 10 * 60 * 1000; // 10 minutes

  if (
    accessToken &&
    expiryDate &&
    expiryDate > Date.now() + TOKEN_REFRESH_BUFFER_MS
  ) {
    return createOutlookClient(accessToken, logger);
  }

  // For device-code accounts (no refresh token), use MSAL silent acquisition
  if (!refreshToken && providerAccountId) {
    logger.info("Using MSAL silent acquisition for email token refresh", {
      emailAccountId,
      providerAccountId,
    });

    const msalResult = await acquireMSALTokenSilent(providerAccountId);

    if (!msalResult) {
      throw new SafeError(
        "Authentication expired. Please log in again using device code flow.",
      );
    }

    // Update the account with the fresh token
    await prisma.account.updateMany({
      where: { providerAccountId },
      data: {
        access_token: encryptToken(msalResult.accessToken),
        expires_at: msalResult.expiresAt,
      },
    });

    logger.info("Updated account with MSAL token", {
      emailAccountId,
      providerAccountId,
    });

    return createOutlookClient(msalResult.accessToken, logger);
  }

  // Standard OAuth flow - requires refresh token
  if (!refreshToken) {
    logger.error("No refresh token", { emailAccountId });
    throw new SafeError("No refresh token");
  }

  // Refresh using OAuth (standard flow)
  // ... (lines 151-259 handle standard OAuth refresh)
};
```

---

### **5. CALENDAR INTEGRATION**

#### **Calendar Client Token Refresh**

**File:** `/Users/hack/github/inbox-zero/apps/web/utils/outlook/calendar-client.ts`

**Function:** `getCalendarClientWithRefresh()` (Lines 41-181)

Similar to email client, but for calendar operations:

```typescript
export const getCalendarClientWithRefresh = async ({
  accessToken,
  refreshToken,
  expiresAt,
  emailAccountId,
  providerAccountId,
  logger,
}: {
  accessToken?: string | null;
  refreshToken: string | null;
  expiresAt: number | null;
  emailAccountId: string;
  providerAccountId?: string | null;
  logger: Logger;
}): Promise<Client> => {
  // Check if token is still valid
  if (expiresAt && expiresAt > Date.now() && accessToken) {
    const authProvider = new CalendarAuthProvider(accessToken);
    return Client.initWithMiddleware({ authProvider });
  }

  // For device-code accounts (no refresh token), use MSAL silent acquisition
  if (!refreshToken && providerAccountId) {
    logger.info("Using MSAL silent acquisition for calendar token refresh", {
      emailAccountId,
      providerAccountId,
    });

    const msalResult = await acquireMSALTokenSilent(providerAccountId);

    if (!msalResult) {
      throw new SafeError(
        "Authentication expired. Please log in again using device code flow.",
      );
    }

    // Update the calendar connection with the fresh token
    const calendarConnection = await prisma.calendarConnection.findFirst({
      where: {
        emailAccountId,
        provider: "microsoft",
      },
      select: { id: true },
    });

    if (calendarConnection) {
      await prisma.calendarConnection.update({
        where: { id: calendarConnection.id },
        data: {
          accessToken: msalResult.accessToken,
          expiresAt: msalResult.expiresAt,
        },
      });
      logger.info("Updated calendar connection with MSAL token", {
        connectionId: calendarConnection.id,
      });
    }

    const authProvider = new CalendarAuthProvider(msalResult.accessToken);
    return Client.initWithMiddleware({ authProvider });
  }

  // Standard OAuth flow
  // ... (lines 103-181)
};
```

#### **Calendar Connection Endpoint**

**File:** `/Users/hack/github/inbox-zero/apps/web/app/api/outlook/calendar/device-code-connect/route.ts`

Endpoint: `POST /api/outlook/calendar/device-code-connect`

This endpoint connects calendars for device-code authenticated accounts (Lines 18-240):

```typescript
export const POST = withEmailAccount(
  "outlook/calendar/device-code-connect",
  async (request) => {
    const { emailAccountId } = request.auth;
    const logger = request.logger;

    // Step 1: Check if MSAL is enabled
    if (!isMSALDeviceCodeEnabled()) {
      return NextResponse.json(
        { success: false, error: "Device code flow is not enabled" },
        { status: 400 },
      );
    }

    // Step 2: Get email account with tokens
    const emailAccount = await prisma.emailAccount.findUnique({
      where: { id: emailAccountId },
      select: {
        id: true,
        email: true,
        account: {
          select: {
            provider: true,
            providerAccountId: true,
            refresh_token: true,
            access_token: true,
            expires_at: true,
          },
        },
      },
    });

    // Step 3: Verify it's a device-code account
    const isDeviceCodeAuth =
      emailAccount.account?.provider === "microsoft" &&
      !emailAccount.account?.refresh_token;

    if (!isDeviceCodeAuth) {
      return NextResponse.json(
        {
          success: false,
          error: "This endpoint is only for device-code authenticated accounts",
        },
        { status: 400 },
      );
    }

    const providerAccountId = emailAccount.account?.providerAccountId;

    // Step 4: Get access token (try stored first, then MSAL)
    let accessToken: string;
    let tokenExpiresAt: Date;

    const storedToken = emailAccount.account?.access_token;
    const storedExpiry = emailAccount.account?.expires_at;
    const tokenStillValid =
      storedToken &&
      storedExpiry &&
      storedExpiry.getTime() > Date.now() + 5 * 60 * 1000; // 5 min buffer

    if (tokenStillValid && storedToken) {
      // Use stored token if still valid
      const { decryptToken } = await import("@/utils/encryption");
      const decrypted = decryptToken(storedToken);
      if (!decrypted) {
        return NextResponse.json(
          { success: false, error: "Token decryption failed" },
          { status: 500 },
        );
      }
      accessToken = decrypted;
      tokenExpiresAt = storedExpiry!;
    } else {
      // Try MSAL for token refresh
      const msalResult = await acquireMSALTokenSilent(providerAccountId);

      if (!msalResult) {
        return NextResponse.json(
          {
            success: false,
            error: "Authentication expired. Please log in again using device code flow.",
          },
          { status: 401 },
        );
      }

      accessToken = msalResult.accessToken;
      tokenExpiresAt = msalResult.expiresAt;
    }

    // Step 5: Fetch user email from Graph API
    const profileResponse = await fetch(
      "https://graph.microsoft.com/v1.0/me",
      {
        headers: {
          Authorization: `Bearer ${accessToken}`,
        },
      },
    );

    const profile = await profileResponse.json();
    const microsoftEmail = profile.mail || profile.userPrincipalName;

    // Step 6: Check for existing connection
    const existingConnection = await checkExistingConnection(
      emailAccountId,
      "microsoft",
      microsoftEmail,
    );

    if (existingConnection) {
      return NextResponse.json({
        success: true,
        connectionId: existingConnection.id,
      });
    }

    // Step 7: Create CalendarConnection
    const connection = await createCalendarConnection({
      provider: "microsoft",
      email: microsoftEmail,
      emailAccountId,
      accessToken,
      refreshToken: "", // Empty string since device-code doesn't provide refresh tokens
      expiresAt: tokenExpiresAt,
    });

    // Step 8: Sync calendars
    const microsoftProvider = createMicrosoftCalendarProvider(logger);
    await microsoftProvider.syncCalendars(
      connection.id,
      accessToken,
      "", // No refresh token for device-code
      emailAccountId,
      tokenExpiresAt,
      providerAccountId, // Pass for MSAL token refresh
    );

    return NextResponse.json({
      success: true,
      connectionId: connection.id,
    });
  },
);
```

#### **Calendar Provider**

**File:** `/Users/hack/github/inbox-zero/apps/web/utils/calendar/providers/microsoft.ts`

```typescript
export function createMicrosoftCalendarProvider(
  logger: Logger,
): CalendarOAuthProvider {
  return {
    name: "microsoft",

    async syncCalendars(
      connectionId: string,
      accessToken: string,
      refreshToken: string,
      emailAccountId: string,
      expiresAt: Date | null,
      providerAccountId?: string | null,
    ): Promise<void> {
      // Get calendar client (handles token refresh if needed)
      const calendarClient = await getCalendarClientWithRefresh({
        accessToken,
        refreshToken,
        expiresAt: expiresAt?.getTime() ?? null,
        emailAccountId,
        providerAccountId,
        logger,
      });

      // Fetch calendars from Microsoft Graph
      const microsoftCalendars = await fetchMicrosoftCalendars(
        calendarClient,
        logger,
      );

      // Upsert calendars into database
      for (const microsoftCalendar of microsoftCalendars) {
        await prisma.calendar.upsert({
          where: {
            connectionId_calendarId: {
              connectionId,
              calendarId: microsoftCalendar.id,
            },
          },
          update: {
            name: microsoftCalendar.name || "Untitled Calendar",
            description: microsoftCalendar.description,
            timezone: null,
          },
          create: {
            connectionId,
            calendarId: microsoftCalendar.id,
            name: microsoftCalendar.name || "Untitled Calendar",
            description: microsoftCalendar.description,
            timezone: null,
            isEnabled: true,
          },
        });
      }

      await autoPopulateTimezone(emailAccountId, microsoftCalendars, logger);
    },
  };
}
```

#### **Calendar Connection UI**

**File:** `/Users/hack/github/inbox-zero/apps/web/app/(app)/[emailAccountId]/calendars/ConnectCalendar.tsx`

```typescript
const handleConnectMicrosoft = async () => {
  setIsConnectingMicrosoft(true);
  try {
    // Device-code authenticated accounts use direct API call instead of OAuth redirect
    if (isDeviceCodeAuth) {
      const response = await fetchWithAccount({
        url: "/api/outlook/calendar/device-code-connect",
        emailAccountId,
        init: {
          method: "POST",
          headers: { "Content-Type": "application/json" },
        },
      });

      const data: DeviceCodeCalendarConnectResponse = await response.json();

      if (!data.success) {
        throw new Error(data.error || "Failed to connect calendar");
      }

      toastSuccess({ description: "Calendar connected successfully!" });
      window.location.reload();
      return;
    }

    // OAuth flow for non-device-code accounts
    // ...
  } catch (error) {
    toastError({
      title: "Error connecting Microsoft calendar",
      description:
        error instanceof Error
          ? error.message
          : "Please try again or contact support",
    });
    setIsConnectingMicrosoft(false);
  }
};
```

---

### **6. SCOPES & PERMISSIONS**

**File:** `/Users/hack/github/inbox-zero/apps/web/utils/outlook/scopes.ts`

```typescript
export const SCOPES = [
  "openid",
  "profile",
  "email",
  "User.Read",
  "offline_access", // Required for refresh tokens
  "Mail.ReadWrite", // Read and write access to mailbox
  ...(env.NEXT_PUBLIC_EMAIL_SEND_ENABLED ? ["Mail.Send"] : []),
  "MailboxSettings.ReadWrite", // Read and write mailbox settings
] as const;

export const CALENDAR_SCOPES = [
  "openid",
  "profile",
  "email",
  "User.Read",
  "offline_access", // Required for refresh tokens
  "Calendars.Read", // Read user calendars
  "Calendars.ReadWrite", // Read and write user calendars
] as const;
```

**Device Code Flow Scope:**
```typescript
const MSAL_DEVICE_CODE_SCOPES = ["https://graph.microsoft.com/.default"];
```

The `.default` scope requests all pre-authorized permissions without requiring explicit consent.

---

### **7. ENVIRONMENT CONFIGURATION**

**File:** `/Users/hack/github/inbox-zero/apps/web/env.ts` (Lines 83-88)

```typescript
// MSAL Device Code Flow (alternative auth method)
MSAL_CLIENT_ID: z.string().optional(), // Falls back to MICROSOFT_CLIENT_ID or default Office client ID
MSAL_TENANT_ID: z.string().optional(), // Falls back to MICROSOFT_TENANT_ID
MSAL_ENABLED: z.string().optional(), // Set to "true" to enable
MSAL_DEBUG: z.string().optional(), // Set to "true" for verbose logging
```

**Default Values:**
- `MSAL_CLIENT_ID`: Falls back to `MICROSOFT_CLIENT_ID` or `d3590ed6-52b3-4102-aeff-aad2292ab01c` (Microsoft Office client ID)
- `MSAL_TENANT_ID`: Falls back to `MICROSOFT_TENANT_ID` or `"common"`
- `MSAL_ENABLED`: Defaults to disabled (`"false"`)
- `MSAL_DEBUG`: Defaults to disabled

---

### **8. CONTEXT & PROVIDER INTEGRATION**

**File:** `/Users/hack/github/inbox-zero/apps/web/providers/EmailAccountProvider.tsx`

The provider exposes device-code authentication status to components:

```typescript
interface Context {
  emailAccount: GetEmailAccountsResponse["emailAccounts"][number] | undefined;
  emailAccountId: string;
  userEmail: string;
  isLoading: boolean;
  provider: string;
  isDeviceCodeAuth: boolean; // Key flag
  providerAccountId: string | null; // For MSAL token lookup
}

// Usage in components
const { emailAccountId, isDeviceCodeAuth, providerAccountId } = useAccount();
```

---

### **9. KEY ARCHITECTURAL PATTERNS**

#### **A. In-Memory Flow Storage**

Lines 158-194 in `msal-device-code.ts`:

```typescript
interface ActiveFlow {
  deviceCode: string;
  userCode: string;
  verificationUri: string;
  expiresAt: Date;
  message: string;
  promise: Promise<AuthenticationResult | null>;
  resolve: (result: AuthenticationResult | null) => void;
  reject: (error: Error) => void;
}

const activeFlows = new Map<string, ActiveFlow>();

// Cleanup expired flows every 5 minutes
setInterval(cleanupExpiredFlows, 5 * 60 * 1000);
```

#### **B. Non-Blocking Polling**

Lines 361-368 in `msal-device-code.ts`:

```typescript
const raceResult = await Promise.race([
  flow.promise
    .then((result) => ({ done: true as const, result, error: null }))
    .catch((error) => ({ done: true as const, result: null, error })),
  new Promise<{ done: false }>((resolve) =>
    setTimeout(() => resolve({ done: false }), 100),
  ),
]);
```

This avoids blocking while waiting for MSAL to complete. Returns immediately if still pending.

#### **C. Token Refresh Precedence**

In both `client.ts` and `calendar-client.ts`:

1. Check if stored token is still valid (> 10-minute buffer)
2. If device-code (no refresh token) → Use MSAL silent acquisition
3. If standard OAuth → Use refresh token to get new tokens

#### **D. Security Layers**

1. **Token Encryption:** All access tokens stored in DB are encrypted
2. **No Refresh Token Exposure:** Device-code accounts never have refresh tokens in database
3. **No PII Logging:** MSAL logging disabled for PII
4. **Session Cookies:** Signed and secure HTTP-only cookies

---

### **10. FILE PATHS SUMMARY**

| Component | File Path | Purpose |
|-----------|-----------|---------|
| **MSAL Core** | `/apps/web/utils/outlook/msal-device-code.ts` | Device code flow implementation |
| **Device Code Routes** | `/apps/web/app/api/outlook/device-code/initiate/route.ts` | Initiate flow |
| | `/apps/web/app/api/outlook/device-code/poll/route.ts` | Poll for completion & create session |
| **Email Client** | `/apps/web/utils/outlook/client.ts` | Outlook client with MSAL token refresh |
| **Calendar Client** | `/apps/web/utils/outlook/calendar-client.ts` | Calendar operations with MSAL refresh |
| **Calendar Provider** | `/apps/web/utils/calendar/providers/microsoft.ts` | Microsoft calendar sync |
| **Calendar Connect** | `/apps/web/app/api/outlook/calendar/device-code-connect/route.ts` | Device-code calendar connection |
| **Frontend Login** | `/apps/web/app/(landing)/login/DeviceCodeLogin.tsx` | Device code UI & polling |
| **Calendar UI** | `/apps/web/app/(app)/[emailAccountId]/calendars/ConnectCalendar.tsx` | Calendar connection selector |
| **Email Accounts** | `/apps/web/app/api/user/email-accounts/route.ts` | Account list with device-code detection |
| **Provider Context** | `/apps/web/providers/EmailAccountProvider.tsx` | Account context with device-code flag |
| **Scopes** | `/apps/web/utils/outlook/scopes.ts` | Permission scopes |
| **Environment** | `/apps/web/env.ts` | Configuration variables |
| **Tests** | `/apps/web/utils/outlook/msal-device-code.test.ts` | Unit tests |

---

### **11. DATA FLOW DIAGRAM**

```
User Browser
    ↓
DeviceCodeLogin.tsx (initiateFlow)
    ↓
POST /api/outlook/device-code/initiate
    ↓
msal-device-code.ts:initiateDeviceCodeFlow()
    ├→ getMSALApp() [Singleton MSAL app]
    ├→ app.acquireTokenByDeviceCode()
    ├→ Store in activeFlows Map
    └→ Return { userCode, verificationUri, ... }
    ↓
Frontend displays code & verification URL
User opens verificationUri & signs in
    ↓
MSAL completes authorization
    ↓
Frontend polls every 3 seconds
    ↓
POST /api/outlook/device-code/poll
    ↓
msal-device-code.ts:pollDeviceCodeFlow()
    ├→ Check activeFlows for flow status
    └→ Return { status: "pending" | "complete" | "expired" | "error" }
    ↓
[When complete]
    ↓
poll/route.ts:completeDeviceCodeAuthentication()
    ├→ Get user profile from Graph API
    ├→ Create/update User in DB
    ├→ Create/update Account (refresh_token = null)
    ├→ Create/update EmailAccount
    ├→ Create Session
    └→ Set session cookie
    ↓
Frontend redirects to /welcome
    ↓
[User can now use app]
    ↓
When accessing email/calendar:
    ├→ client.ts:getOutlookClientWithRefresh()
    │  ├→ Check token valid?
    │  ├→ If expired & device-code:
    │  │  └→ acquireMSALTokenSilent(providerAccountId)
    │  │     ├→ Get MSAL app
    │  │     ├→ Get token cache
    │  │     ├→ Find account by localAccountId
    │  │     └→ acquireTokenSilent()
    │  └→ Return OutlookClient with access token
    │
    └→ calendar-client.ts:getCalendarClientWithRefresh()
       └→ Same pattern for calendar access
```

---

### **12. CRITICAL POINTS**

1. **No Refresh Token Storage:** Device-code accounts never have `refresh_token` in database; MSAL cache handles refresh internally
2. **providerAccountId Mapping:** MSAL's `account.localAccountId` is stored and used to find the account in MSAL's token cache
3. **Scopes:** Device code uses `.default` scope; email/calendar use specific scopes
4. **In-Memory Storage:** Active flows stored in Map with 5-minute cleanup interval
5. **Non-Breaking:** Runs parallel to existing OAuth; feature flagged with `MSAL_ENABLED`
6. **Custom Network Module:** Workaround for Node.js 22+ undici connection pool issues
7. **Token Encryption:** All stored tokens are encrypted using `encryptToken()`

---

This comprehensive trace shows how the MSAL device-code flow integrates seamlessly with the existing inbox-zero authentication system, providing an alternative path for Microsoft account authentication while maintaining backward compatibility with OAuth-based accounts.

_**Agent - sidechain (claude-haiku-4-5-20251001 2026-01-24T04:04:58.067Z)**_

Excellent! Now I have comprehensive information about the MSAL implementation. Let me provide a detailed analysis report:

## MSAL Device-Code Flow Reference Implementation - Complete Analysis

I've explored the outlook-creds repository and found a comprehensive MSAL implementation. Here's the complete authentication flow with detailed code excerpts:

### 1. DEVICE-CODE FLOW INITIATION

**File:** `/Users/hack/github/outlook-creds/src/outlook_creds/auth/oauth.py` (lines 98-184)

```python
def authenticate_with_msal(params: dict[str, Any]) -> dict[str, Any]:
    """Authenticate user via MSAL device code flow."""
    
    # Create MSAL public client application
    app = PublicClientApplication(
        client_id=params["client_id"],
        authority=params["authority"]
    )
    
    # Check for cached tokens first
    accounts = app.get_accounts(username=params["email"])
    if accounts:
        result = app.acquire_token_silent(scopes=params["scopes"], account=accounts[0])
        if result and "access_token" in result:
            return result
    
    # Initiate device code flow
    flow = app.initiate_device_flow(scopes=params["scopes"])
    
    # Display user code and verification URI
    print(flow["message"])  # "To sign in, use a web browser..."
    user_code = flow.get("user_code", "")
    verification_uri = flow.get("verification_uri", "")
    
    # Wait for user authentication
    result = app.acquire_token_by_device_flow(flow)
    return result
```

**Key Points:**
- MSAL's `initiate_device_flow()` creates the authentication context
- Returns `user_code`, `verification_uri`, and `message` for user display
- `acquire_token_by_device_flow()` polls Azure AD for completion
- Automatic silent authentication if cached account exists

### 2. SCOPE CONFIGURATION

**File:** `/Users/hack/github/outlook-creds/src/outlook_creds/auth/oauth.py` (lines 50-96)

```python
def extract_token_params(
    account_info: dict[str, Any],
    api_scope: str = "graph",
    explicit_scopes: list[str] | None = None,
) -> dict[str, Any] | None:
    """Extract parameters needed for OAuth token request."""
    
    additional_props = json.loads(account_info["additional_properties"])
    
    # Scope selection logic
    if explicit_scopes:
        scopes = explicit_scopes
    elif api_scope == "graph":
        scopes = ["https://graph.microsoft.com/.default"]
    elif api_scope == "outlook":
        scopes = ["https://outlook.office365.com/.default"]
    elif api_scope == "both":
        # Request Graph as primary - refresh token works for both
        scopes = ["https://graph.microsoft.com/.default"]
    
    return {
        "tenant_id": account_info["realm"],
        "account_id": account_info["id"],
        "authority": account_info["authority"],
        "email": account_info["login_name"],
        "client_id": additional_props.get("aud", "d3590ed6-52b3-4102-aeff-aad2292ab01c"),
        "scopes": scopes,
    }
```

**Default Scopes:**
- **Graph API (primary):** `https://graph.microsoft.com/.default`
- **Outlook API:** `https://outlook.office365.com/.default`
- **offline_access:** Automatic with `.default` scope
- **Authority:** `https://login.microsoftonline.com/{tenant_id}`

### 3. MICROSOFT CLIENT ID CONFIGURATION

**File:** `/Users/hack/github/outlook-creds/scripts/refresh_access_token.sh` (lines 11-14)

```bash
# Microsoft OAuth2 Configuration
# client_id for Microsoft Office (from analysis)
CLIENT_ID="d3590ed6-52b3-4102-aeff-aad2292ab01c"
TOKEN_ENDPOINT="https://login.microsoftonline.com/common/oauth2/v2.0/token"
```

**IMPORTANT:** This is the **official Microsoft Office client ID**, used by:
- Microsoft Outlook
- Microsoft 365 applications
- Azure AD native clients

It's a well-known public client ID that doesn't require a client secret.

### 4. TOKEN ACQUISITION & STORAGE FLOW

**Sequence:**
1. **Extract account info from keychain** → Account metadata with tenant ID
2. **Initiate device code flow** → User gets code + verification URI
3. **User authenticates in browser** → Azure AD validates credentials
4. **MSAL polls for completion** → Returns access + refresh tokens
5. **Save tokens to disk** → Structured JSON + raw text files

**Storage Structure** (lines 251-342 in oauth.py):

```python
def save_tokens(
    params: dict[str, Any],
    msal_result: dict[str, Any],
    token_dir: Path,
    api_type: str = "graph",
) -> None:
    """Save tokens in multiple formats for compatibility."""
    
    # 1. Full OAuth response (token_dir/oauth_tokens.json)
    oauth_tokens = {
        "access_token": msal_result["access_token"],
        "refresh_token": msal_result.get("refresh_token", ""),
        "token_type": msal_result.get("token_type", "Bearer"),
        "expires_in": msal_result.get("expires_in", 3600),
        "scope": msal_result.get("scope"),
        "tenant_id": params["tenant_id"],
        "obtained_via": "msal_device_code_flow",
        "obtained_at": datetime.now(UTC).isoformat(),
    }
    
    # 2. Refresh token separately (TOKENS_DIR/{email}_refresh_only.txt)
    if msal_result.get("refresh_token"):
        refresh_file = TOKENS_DIR / f"{normalized}_refresh_only.txt"
        secure_write_token(refresh_file, msal_result["refresh_token"])
    
    # 3. Structured access token (TOKENS_DIR/{email}_access_token.json)
    access_token_data = {
        "email": email,
        "access_token": msal_result["access_token"],
        "token_type": msal_result.get("token_type", "Bearer"),
        "expires_in": msal_result.get("expires_in", 3600),
        "expires_at": expires_at.strftime("%Y-%m-%dT%H:%M:%SZ"),
        "refreshed_at": datetime.now(UTC).strftime("%Y-%m-%dT%H:%M:%SZ"),
        "scopes": msal_result.get("scope", ""),
        "api_type": api_type,
    }
    
    # 4. Raw access token (TOKENS_DIR/{email}_access_only.txt)
    access_only_file = TOKENS_DIR / f"{normalized}{token_suffix}_access_only.txt"
    secure_write_token(access_only_file, msal_result["access_token"])
```

**File Permissions:** `0o600` (readable/writable by owner only)

### 5. TOKEN REFRESH MECHANISM

**File:** `/Users/hack/github/outlook-creds/scripts/refresh_access_token.sh` (lines 25-129)

```bash
refresh_token() {
    local refresh_token="$1"
    local scopes="${2:-$DEFAULT_SCOPES}"
    local email="${3:-unknown}"
    
    # Prepare OAuth2 refresh request
    local post_data
    post_data="client_id=${CLIENT_ID}&grant_type=refresh_token&refresh_token=${refresh_token}&scope=${scopes// /%20}"
    
    # Call Microsoft token endpoint
    response=$(curl -s -w "\n%{http_code}" \
        -X POST \
        -H "Content-Type: application/x-www-form-urlencoded" \
        --data "$post_data" \
        "$TOKEN_ENDPOINT")
    
    # Parse response
    access_token=$(echo "$body" | jq -r '.access_token // empty')
    expires_in=$(echo "$body" | jq -r '.expires_in // empty')
    new_refresh_token=$(echo "$body" | jq -r '.refresh_token // empty')
    
    # Calculate expiration time
    expires_at=$(date -u -v+${expires_in}S +%Y-%m-%dT%H:%M:%SZ)
    
    # Create structured token file
    cat > "$token_file" <<EOF
{
  "email": "$email",
  "access_token": "$access_token",
  "token_type": "$token_type",
  "expires_in": $expires_in,
  "expires_at": "$expires_at",
  "refreshed_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "scopes": "$scopes",
  "api_type": "$api_type"
}
EOF
}
```

**Refresh Token Validation** (lines 131-184):

```bash
is_token_valid() {
    local email="$1"
    local token_file="${TOKENS_DIR}/${email}_access_token.json"
    
    if [[ ! -f "$token_file" ]]; then
        return 1
    fi
    
    local expires_at
    expires_at=$(jq -r '.expires_at' "$token_file")
    
    # Convert to epoch and add 60-second buffer
    local expires_epoch=$(date -jf "%Y-%m-%dT%H:%M:%SZ" "$expires_at" +%s)
    local now_epoch=$(date +%s)
    
    # Refresh if expiring in < 60 seconds
    if [[ $((expires_epoch - 60)) -gt $now_epoch ]]; then
        return 0  # Valid
    fi
    
    return 1  # Expired
}
```

### 6. MULTI-API TOKEN ACQUISITION

**For Both Graph and Outlook APIs** (lines 187-249 in oauth.py):

```python
def acquire_outlook_token_via_refresh(
    refresh_token: str,
    params: dict[str, Any],
) -> dict[str, Any] | None:
    """Use refresh token to acquire Outlook API access token."""
    
    token_endpoint = f"https://login.microsoftonline.com/{params['tenant_id']}/oauth2/v2.0/token"
    outlook_scope = "https://outlook.office365.com/.default offline_access"
    
    data = urllib.parse.urlencode({
        "client_id": params["client_id"],
        "grant_type": "refresh_token",
        "refresh_token": refresh_token,
        "scope": outlook_scope,
    }).encode("utf-8")
    
    headers = {
        "Content-Type": "application/x-www-form-urlencoded",
        "Accept": "application/json",
    }
    
    req = urllib.request.Request(token_endpoint, data=data, headers=headers)
    with urllib.request.urlopen(req, timeout=30) as response:
        result = json.loads(response.read().decode("utf-8"))
        return result if "access_token" in result else None
```

**Key Pattern:** Single refresh token works for multiple APIs - request one scope in device flow, use refresh token for others.

### 7. COMPLETE AUTHENTICATION ORCHESTRATION

**File:** `/Users/hack/github/outlook-creds/scripts/auth_helper.sh` (lines 27-80)

```bash
setup_account() {
    local email="$1"
    local api_scope="${3:-graph}"
    
    info "[1/4] Extracting account metadata from keychain..."
    "$EXTRACT_SCRIPT" "$email"
    
    info "[2/4] Obtaining OAuth tokens via MSAL..."
    "$OAUTH_SCRIPT" "$email" "--api=$api_scope"
    
    # Step 3: Verify refresh token
    local refresh_token_file="${TOKENS_DIR}/${email}_refresh_only.txt"
    if [[ ! -f "$refresh_token_file" ]]; then
        error "Refresh token not found"
        return 1
    fi
    
    info "[4/4] Storing account metadata..."
    "$STORE_SCRIPT" store "$email" "$account_name" "Exchange" "$api_scope"
    
    info "Access token expires at: $(jq -r '.expires_at' "$access_token_file")"
}
```

### 8. TOKEN PERSISTENCE & MANAGEMENT

**Token Storage Structure:**

```
~/.config/outlook-creds/
├── tokens/
│   ├── user@example.com_refresh_only.txt      # Just refresh token
│   ├── user@example.com_access_token.json     # Structured access token
│   ├── user@example.com_access_only.txt       # Raw access token
│   ├── user@example.com_outlook_access_token.json  # Outlook scope variant
│   └── user@example.com_outlook_access_only.txt
└── metadata/
    └── user@example.com_metadata.json         # Account metadata
```

**Token Cache Validation** (`refresh_access_token.sh`):

```bash
get_access_token() {
    local email="$1"
    local force_refresh="${3:-false}"
    
    # Check if valid token exists
    if [[ "$force_refresh" != "true" ]] && is_token_valid "$email"; then
        cat "${TOKENS_DIR}/${email}_access_only.txt"
        return 0
    fi
    
    # Refresh if expired
    local refresh_token=$(cat "$refresh_token_file")
    refresh_token "$refresh_token" "$scopes" "$email"
}
```

### 9. GRAPH API USAGE AFTER AUTHENTICATION

**File:** `/Users/hack/github/outlook-creds/scripts/auth_helper.sh` (lines 154-217)

```bash
test_auth() {
    local email="$1"
    
    # Get access token
    access_token=$(get_token_for_api "$email" "https://graph.microsoft.com/.default")
    
    # Test with /me endpoint
    response=$(curl -s -w "\n%{http_code}" \
        -H "Authorization: Bearer $access_token" \
        -H "Content-Type: application/json" \
        "https://graph.microsoft.com/v1.0/me")
    
    http_code=$(echo "$response" | tail -n1)
    local body=$(echo "$response" | sed '$d')
    
    if [[ "$http_code" == "200" ]]; then
        display_name=$(echo "$body" | jq -r '.displayName')
        email_address=$(echo "$body" | jq -r '.userPrincipalName')
        user_id=$(echo "$body" | jq -r '.id')
        
        echo "Display Name: $display_name"
        echo "Email: $email_address"
        echo "User ID: $user_id"
    fi
}
```

### 10. CREDENTIAL RETRIEVAL FOR API USE

**File:** `/Users/hack/github/outlook-creds/scripts/store_credentials.sh` (lines 153-245)

```bash
get_credentials() {
    local email="$1"
    local format="${2:-json}"
    
    case "$format" in
        json)
            cat <<EOF
{
  "email": "$email",
  "access_token": "$(jq -r '.access_token' "$access_token_file")",
  "refresh_token": "$(cat "$refresh_token_file")",
  "token_type": "Bearer",
  "expires_at": "$(jq -r '.expires_at' "$access_token_file")"
}
EOF
            ;;
        access-token)
            cat "${TOKENS_DIR}/${email}_access_only.txt"
            ;;
        curl)
            local token=$(cat "${TOKENS_DIR}/${email}_access_only.txt")
            echo "-H 'Authorization: Bearer $token' -H 'X-User-Identity: $email'"
            ;;
    esac
}
```

### Summary: Complete Authentication Flow

```
1. KEYCHAIN EXTRACTION
   ├─ Extract OneAuth account metadata
   ├─ Parse account info (tenant ID, user ID, authority)
   └─ Save to: ~/config/outlook-creds/tokens/{email}/account_info.json

2. DEVICE CODE FLOW
   ├─ Create PublicClientApplication(client_id, authority)
   ├─ Call initiate_device_flow(scopes)
   ├─ Display user_code and verification_uri
   ├─ Poll with acquire_token_by_device_flow()
   └─ Return: {access_token, refresh_token, expires_in, ...}

3. TOKEN STORAGE
   ├─ oauth_tokens.json        → Full response
   ├─ {email}_refresh_only.txt → Refresh token only
   ├─ {email}_access_token.json → Structured token metadata
   └─ {email}_access_only.txt  → Raw token string

4. MULTI-API TOKENS
   ├─ Request Graph API (.default) in device flow
   ├─ Get universal refresh token
   └─ Use refresh token to acquire Outlook API tokens separately

5. TOKEN REFRESH
   ├─ Check is_token_valid() → expires_at vs now()
   ├─ If expired: POST refresh_token to token endpoint
   ├─ Parse new access_token + optional new refresh_token
   └─ Update local token files

6. API USAGE
   ├─ Retrieve access token from local file
   ├─ Make HTTP request with: Authorization: Bearer {token}
   └─ Handle 401 → refresh → retry
```

This reference implementation demonstrates production-ready MSAL device-code flow with comprehensive token caching, refresh logic, and multi-API support.

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:05:23.165Z)**_

<think><details><summary>Thought Process</summary>
I now have comprehensive information about both implementations. Let me analyze the gaps between the reference implementation in outlook-creds and the current inbox-zero implementation.

Key findings from both explorations:

**Reference Implementation (outlook-creds):**
1. Uses MSAL Python with PublicClientApplication
2. Stores refresh tokens persistently on disk
3. Uses `.default` scope for Graph API
4. Leverages keychain for account metadata
5. Has robust token refresh via shell scripts
6. Stores tokens in multiple formats (JSON, raw text)
7. Supports both Graph and Outlook APIs via single refresh token

**Current inbox-zero Implementation:**
1. Uses MSAL Node.js with PublicClientApplication
2. In-memory token cache only (activeFlows Map)
3. Uses `.default` scope for device code flow
4. **No persistent token storage** - relies on MSAL's in-memory cache
5. Token refresh via `acquireMSALTokenSilent()` - requires account to be in MSAL cache
6. Stores encrypted access_token in DB, but refresh_token is null
7. **CRITICAL GAP:** No refresh token storage means tokens expire and users must re-authenticate

Let me identify the specific gaps:

**Gap 1: No Refresh Token Persistence**
- Reference: Stores refresh_token to disk (`{email}_refresh_only.txt`)
- inbox-zero: Sets `refresh_token: null` in database, relies on MSAL in-memory cache
- Impact: MSAL in-memory cache clears on server restart; users lose access

**Gap 2: MSAL Cache Persistence**
- Reference: Has persistent token storage across process restarts
- inbox-zero: Uses default in-memory cache via `getMSALApp()` singleton
- Impact: Server restart = users must re-authenticate

**Gap 3: Token Refresh Strategy**
- Reference: Uses refresh_token directly with token endpoint


- inbox-zero: Uses `acquireTokenSilent()` which requires account in MSAL cache
- Impact: If account not in cache, silent acquisition fails

**Gap 4: Custom Network Module**
- inbox-zero: Has CustomNetworkModule for Node.js 22+ undici issues
- Reference: Not needed (Python)
- This is actually a strength in inbox-zero

**Gap 5: Error Recovery**
- Reference: Clear error handling with shell script wrappers
- inbox-zero: Has try/catch but recovery path requires re-authentication
- Impact: Users see "Authentication expired. Please log in again" frequently

The core issue is that inbox-zero discards the refresh token after initial authentication, forcing re-auth on every server restart or token expiration. I need to implement persistent refresh token storage and use it to silently reacquire access tokens without user intervention.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:05:23.191Z)**_

I now have a complete picture of both implementations. Let me write the audit findings and gap analysis to the plan file.

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:06:06.921Z)**_

<tool-use data-tool-type="write" data-tool-name="Write"><details>
<summary>Tool use: **Write**</summary>

```md
# MSAL Device-Code Flow Audit: Gap Analysis

## Executive Summary

The inbox-zero MSAL device-code implementation has a **critical architectural gap**: it lacks persistent token storage, making it unsuitable for production use. When the server restarts or the in-memory MSAL cache clears, users must re-authenticate.

---

## Reference Implementation (outlook-creds)

The reference implementation demonstrates production-ready patterns:

### Token Storage Architecture
\```
~/.config/outlook-creds/tokens/
├── {email}_refresh_only.txt        # Persistent refresh token
├── {email}_access_token.json       # Structured: {access_token, expires_at, scopes}
└── {email}_access_only.txt         # Raw access token for quick reads
\```

### Key Patterns
1. **Persistent refresh token storage** - survives process restarts
2. **Direct token endpoint refresh** - uses OAuth2 `/token` endpoint with `grant_type=refresh_token`
3. **Pre-check validation** - validates token expiry before API calls
4. **Multi-format storage** - JSON for metadata, raw text for quick access

### Token Refresh Flow (reference)
\```bash
# refresh_access_token.sh pattern
curl -X POST "https://login.microsoftonline.com/common/oauth2/v2.0/token" \
  -d "client_id=${CLIENT_ID}" \
  -d "grant_type=refresh_token" \
  -d "refresh_token=${refresh_token}" \
  -d "scope=https://graph.microsoft.com/.default"
\```

---

## Current inbox-zero Implementation

### Architecture Overview
| Component | File | Purpose |
|-----------|------|---------|
| MSAL Core | `utils/outlook/msal-device-code.ts` | Device code flow, silent acquisition |
| Poll Route | `api/outlook/device-code/poll/route.ts` | Session creation, account storage |
| Email Client | `utils/outlook/client.ts` | Token refresh for email operations |
| Calendar Client | `utils/outlook/calendar-client.ts` | Token refresh for calendar operations |

### Token Flow Trace
1. User initiates device-code flow → `initiateDeviceCodeFlow()`
2. MSAL returns `{access_token, refresh_token, account}`
3. **Account stored**: `refresh_token: null` in database (intentionally omitted)
4. **Access token stored**: Encrypted in `Account.access_token`
5. **MSAL cache**: Account info stored in-memory only
6. Token refresh via `acquireTokenSilent(providerAccountId)` - **requires account in cache**

---

## Critical Gaps Identified

### Gap 1: No Refresh Token Persistence ⚠️ CRITICAL

**Reference:**
\```python
# oauth.py - saves refresh token to persistent storage
if msal_result.get("refresh_token"):
    refresh_file = TOKENS_DIR / f"{email}_refresh_only.txt"
    secure_write_token(refresh_file, msal_result["refresh_token"])
\```

**inbox-zero:**
\```typescript
// poll/route.ts line ~95 - explicitly sets null
const accountRecord = await prisma.account.upsert({
  // ...
  create: {
    refresh_token: null, // MSAL doesn't expose refresh token
    // ...
  },
});
\```

**Impact:** MSAL **does** return a refresh token, but inbox-zero discards it. This is the root cause of token expiration issues.

### Gap 2: In-Memory MSAL Cache Only ⚠️ CRITICAL

**Reference:**
- Stores tokens to disk files
- Survives process restarts
- Can be shared across instances

**inbox-zero:**
\```typescript
// msal-device-code.ts - singleton in-memory only
let msalApp: PublicClientApplication | null = null;

function getMSALApp(): PublicClientApplication {
  if (!msalApp) {
    msalApp = new PublicClientApplication({
      // Uses default in-memory cache
    });
  }
  return msalApp;
}
\```

**Impact:** Server restart = MSAL cache cleared = `acquireTokenSilent()` fails = users must re-authenticate.

### Gap 3: Silent Acquisition Dependency ⚠️ HIGH

**Current refresh path:**
\```typescript
// client.ts - requires MSAL cache to have account
const msalResult = await acquireMSALTokenSilent(providerAccountId);
if (!msalResult) {
  throw new SafeError("Authentication expired. Please log in again...");
}
\```

**Reference approach:**
\```bash
# Uses stored refresh token directly - no cache dependency
curl -X POST "$TOKEN_ENDPOINT" -d "refresh_token=${stored_refresh_token}"
\```

**Impact:** inbox-zero has no fallback when MSAL cache misses.

### Gap 4: No Direct Token Endpoint Refresh ⚠️ HIGH

**Reference has:**
\```python
def acquire_outlook_token_via_refresh(refresh_token, params):
    token_endpoint = f"https://login.microsoftonline.com/{tenant_id}/oauth2/v2.0/token"
    data = {
        "client_id": params["client_id"],
        "grant_type": "refresh_token",
        "refresh_token": refresh_token,
        "scope": "https://graph.microsoft.com/.default",
    }
    # Direct HTTP call to token endpoint
\```

**inbox-zero lacks:** Any direct token endpoint refresh capability. Relies entirely on MSAL's `acquireTokenSilent()`.

### Gap 5: Token Expiry Pre-validation ⚠️ MEDIUM

**Reference:**
\```bash
is_token_valid() {
    local expires_at=$(jq -r '.expires_at' "$token_file")
    local expires_epoch=$(date -jf "%Y-%m-%dT%H:%M:%SZ" "$expires_at" +%s)
    [[ $((expires_epoch - 60)) -gt $(date +%s) ]]
}
\```

**inbox-zero:** Has partial validation but inconsistent buffer times (10 min vs 5 min in different files).

---

## What inbox-zero Does Well

1. **Custom Network Module** - Handles Node.js 22+ undici issues
2. **Non-blocking Polling** - Uses `Promise.race` for responsive polling
3. **Encrypted Token Storage** - Access tokens encrypted in database
4. **Session Integration** - Proper Better Auth session creation
5. **Feature Flagging** - Clean `MSAL_ENABLED` toggle
6. **Provider Context** - `isDeviceCodeAuth` flag for UI differentiation

---

## Recommended Fixes

### Fix 1: Store Refresh Token (CRITICAL)

\```typescript
// poll/route.ts - Store the refresh token from MSAL result
const accountRecord = await prisma.account.upsert({
  create: {
    // ...
    refresh_token: pollResult.result.account
      ? encryptToken(getRefreshTokenFromMSAL())
      : null,
  },
});
\```

**Challenge:** MSAL Node.js doesn't expose `refresh_token` in `AuthenticationResult`. Need to:
- Access token cache directly, OR
- Use custom cache plugin to intercept tokens

### Fix 2: Implement Persistent MSAL Cache

\```typescript
// Option A: Custom cache plugin
import { ICachePlugin } from "@azure/msal-node";

class PrismaCachePlugin implements ICachePlugin {
  async beforeCacheAccess(context) {
    const cache = await prisma.msalCache.findFirst({ where: { key: "default" } });
    if (cache) context.tokenCache.deserialize(cache.data);
  }

  async afterCacheAccess(context) {
    if (context.cacheHasChanged) {
      await prisma.msalCache.upsert({
        where: { key: "default" },
        update: { data: context.tokenCache.serialize() },
        create: { key: "default", data: context.tokenCache.serialize() },
      });
    }
  }
}
\```

### Fix 3: Direct Token Endpoint Fallback

\```typescript
// New function in msal-device-code.ts
async function refreshTokenDirectly(
  refreshToken: string,
  scopes: string[] = ["https://graph.microsoft.com/.default"]
): Promise<TokenResponse | null> {
  const clientId = env.MSAL_CLIENT_ID || MICROSOFT_OFFICE_CLIENT_ID;
  const tokenEndpoint = `https://login.microsoftonline.com/common/oauth2/v2.0/token`;

  const params = new URLSearchParams({
    client_id: clientId,
    grant_type: "refresh_token",
    refresh_token: refreshToken,
    scope: scopes.join(" "),
  });

  const response = await fetch(tokenEndpoint, {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body: params.toString(),
  });

  return response.json();
}
\```

### Fix 4: Unified Token Refresh Strategy

\```typescript
// client.ts - enhanced refresh logic
async function getTokenForDeviceCodeAccount(providerAccountId: string): Promise<string> {
  // 1. Try MSAL silent acquisition
  const msalResult = await acquireMSALTokenSilent(providerAccountId);
  if (msalResult) return msalResult.accessToken;

  // 2. Fallback: Direct token endpoint with stored refresh token
  const account = await prisma.account.findFirst({
    where: { providerAccountId },
    select: { refresh_token: true },
  });

  if (account?.refresh_token) {
    const decrypted = decryptToken(account.refresh_token);
    const result = await refreshTokenDirectly(decrypted);
    if (result?.access_token) {
      // Update stored tokens
      await updateAccountTokens(providerAccountId, result);
      return result.access_token;
    }
  }

  // 3. No options left - require re-authentication
  throw new SafeError("Authentication expired. Please log in again.");
}
\```

---

## Implementation Priority

| Priority | Fix | Effort | Impact |
|----------|-----|--------|--------|
| P0 | Store refresh token from MSAL | Medium | Enables all other fixes |
| P0 | Implement persistent MSAL cache | High | Survives restarts |
| P1 | Direct token endpoint fallback | Medium | Recovery when cache empty |
| P2 | Unified refresh strategy | Low | Better UX |
| P3 | Consistent expiry buffer times | Low | Edge case improvement |

---

## Files to Modify

1. **`utils/outlook/msal-device-code.ts`**
   - Add persistent cache plugin
   - Add direct token refresh function
   - Extract refresh token from MSAL cache

2. **`app/api/outlook/device-code/poll/route.ts`**
   - Store refresh token in database
   - Update account creation logic

3. **`utils/outlook/client.ts`**
   - Add fallback refresh path
   - Unified token acquisition

4. **`utils/outlook/calendar-client.ts`**
   - Same fallback refresh path

5. **New: `prisma/schema.prisma`** (if using DB cache)
   - Add MSALCache model for persistent storage

---

## Verification Steps

1. Authenticate via device-code flow
2. Verify refresh token stored in database (encrypted)
3. Restart server
4. Verify token refresh works without re-authentication
5. Wait for token expiry → verify automatic refresh
6. Clear MSAL cache manually → verify direct refresh fallback works

```
```
File created successfully at: /Users/hack/.claude/plans/cuddly-knitting-ember.md
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:06:20.733Z)**_

<think><details><summary>Thought Process</summary>
I've written a comprehensive gap analysis to the plan file. Now let me read a few key files from the inbox-zero implementation to validate my understanding and potentially add more detail to the plan.

Let me check:
1. The actual MSAL result structure to confirm whether refresh_token is available
2. How the account is being created in poll/route.ts

Actually, I should launch a Plan agent to design the implementation approach for fixing these gaps. Let me do that now.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:06:21.148Z)**_

Now let me launch a Plan agent to design the specific implementation approach for fixing these gaps.

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:06:29.687Z)**_

<tool-use data-tool-type="generic" data-tool-name="Task"><details>
<summary>Tool use: **Task**</summary>
Design MSAL token persistence fix
```
I understand - I'm in READ-ONLY mode and cannot write files. Let me provide the complete implementation plan directly in my response instead.

---

# MSAL Device-Code Token Persistence Implementation Plan

## Problem Statement

The inbox-zero MSAL device-code authentication flow discards refresh tokens and uses only an in-memory MSAL cache. This causes users to re-authenticate after:
- Server restarts
- Cache eviction
- Load balancer routing to a different instance
- Access token expiration (~1 hour) when MSAL cache is empty

**Current State (from `/Users/hack/github/inbox-zero/whats-next.md`):**
- Phase 1 (Complete): MSAL fallback in email client
- Phase 2 (Complete): `providerAccountId` passed through token chain
- Phase 3 (Not Started): **MSAL cache persistence - THIS PLAN**
- Phase 4 (Complete): Calendar device-code-connect uses stored token

---

## Solution Overview

Implement a database-backed MSAL token cache using the `ICachePlugin` interface, combined with a direct OAuth2 token endpoint refresh as fallback when MSAL cache is unavailable.

### Architecture Decision

| Option | Pros | Cons |
|--------|------|------|
| **A: MSAL ICachePlugin with Prisma (Recommended)** | Native MSAL integration, handles all token types, maintains MSAL's token lifecycle | More complex, requires understanding MSAL internals |
| **B: Direct OAuth2 token refresh fallback** | Simpler, bypasses MSAL complexity | Must extract refresh token from MSAL cache manually |

**Chosen Approach:** Hybrid - Implement ICachePlugin for primary persistence, with direct OAuth2 fallback for edge cases.

---

## Implementation Plan

### Phase 1: Database Schema Changes

**File:** `/Users/hack/github/inbox-zero/apps/web/prisma/schema.prisma`

Add two new fields to the `Account` model (around line 16-38):

```prisma
model Account {
  // ... existing fields ...
  
  // MSAL device-code flow cache persistence
  // Stores serialized MSAL token cache for accounts authenticated via device-code flow
  // This enables token refresh to survive server restarts
  msal_cache         String?       @db.Text
  msal_cache_updated DateTime?
}
```

**Rationale:**
- Adding to `Account` model keeps tokens with their owning account
- `@db.Text` handles the potentially large JSON blob (MSAL cache can be several KB)
- `msal_cache_updated` helps with debugging and cache invalidation
- No new table needed - simpler migration and query patterns

**Migration Command:**
```bash
npx prisma migrate dev --name add_msal_cache_to_account
```

---

### Phase 2: MSAL Cache Plugin Implementation

**New File:** `/Users/hack/github/inbox-zero/apps/web/utils/outlook/msal-cache-plugin.ts`

```typescript
/**
 * MSAL Token Cache Persistence Plugin
 * 
 * Implements ICachePlugin to persist MSAL's token cache to PostgreSQL.
 * This enables device-code authenticated accounts to refresh tokens
 * after server restarts.
 */

import type { ICachePlugin, TokenCacheContext } from "@azure/msal-node";
import prisma from "@/utils/prisma";
import { encryptToken, decryptToken } from "@/utils/encryption";
import { createScopedLogger } from "@/utils/logger";

const logger = createScopedLogger("msal-cache-plugin");

export function createPrismaCachePlugin(providerAccountId: string): ICachePlugin {
  return {
    async beforeCacheAccess(cacheContext: TokenCacheContext): Promise<void> {
      try {
        const account = await prisma.account.findFirst({
          where: { 
            provider: "microsoft",
            providerAccountId 
          },
          select: { msal_cache: true },
        });

        if (account?.msal_cache) {
          const decrypted = decryptToken(account.msal_cache);
          if (decrypted) {
            cacheContext.tokenCache.deserialize(decrypted);
            logger.info("Loaded MSAL cache from database", { providerAccountId });
          }
        }
      } catch (error) {
        logger.error("Failed to load MSAL cache", { 
          providerAccountId, 
          error: error instanceof Error ? error.message : String(error) 
        });
        // Don't throw - allow MSAL to continue with empty cache
      }
    },

    async afterCacheAccess(cacheContext: TokenCacheContext): Promise<void> {
      if (!cacheContext.cacheHasChanged) {
        return;
      }

      try {
        const serialized = cacheContext.tokenCache.serialize();
        const encrypted = encryptToken(serialized);

        await prisma.account.updateMany({
          where: { 
            provider: "microsoft",
            providerAccountId 
          },
          data: { 
            msal_cache: encrypted,
            msal_cache_updated: new Date(),
          },
        });

        logger.info("Persisted MSAL cache to database", { providerAccountId });
      } catch (error) {
        logger.error("Failed to persist MSAL cache", { 
          providerAccountId, 
          error: error instanceof Error ? error.message : String(error) 
        });
      }
    },
  };
}
```

---

### Phase 3: Update MSAL Application Factory

**File:** `/Users/hack/github/inbox-zero/apps/web/utils/outlook/msal-device-code.ts`

#### 3.1 Add imports at top of file:

```typescript
import type { Configuration } from "@azure/msal-node";
import { createPrismaCachePlugin } from "./msal-cache-plugin";
import { decryptToken } from "@/utils/encryption";
```

#### 3.2 Replace singleton `getMSALApp()` with factory pattern (around line 116-151):

```typescript
// Change from singleton to factory that can create per-account instances
const msalAppCache = new Map<string, PublicClientApplication>();

function getMSALApp(providerAccountId?: string): PublicClientApplication {
  // For initiation (no providerAccountId yet), use shared instance
  const cacheKey = providerAccountId || "default";
  
  if (msalAppCache.has(cacheKey)) {
    return msalAppCache.get(cacheKey)!;
  }

  const clientId = env.MSAL_CLIENT_ID || env.MICROSOFT_CLIENT_ID || MICROSOFT_OFFICE_CLIENT_ID;
  const tenantId = env.MSAL_TENANT_ID || env.MICROSOFT_TENANT_ID || "common";
  const debugEnabled = env.MSAL_DEBUG === "true";

  const config: Configuration = {
    auth: {
      clientId,
      authority: `https://login.microsoftonline.com/${tenantId}`,
    },
    system: {
      loggerOptions: {
        loggerCallback: (level: LogLevel, message: string, containsPii: boolean) => {
          if (containsPii) return;
          if (debugEnabled || level === LogLevel.Error) {
            logger.info(`MSAL [${LogLevel[level]}]: ${message}`);
          }
        },
        piiLoggingEnabled: false,
        logLevel: debugEnabled ? LogLevel.Verbose : LogLevel.Error,
      },
      networkClient: new CustomNetworkModule(),
    },
  };

  // Add cache plugin for known accounts
  if (providerAccountId) {
    config.cache = {
      cachePlugin: createPrismaCachePlugin(providerAccountId),
    };
  }

  const app = new PublicClientApplication(config);
  msalAppCache.set(cacheKey, app);
  
  return app;
}
```

#### 3.3 Update `acquireMSALTokenSilent()` function (around line 438-504):

```typescript
export async function acquireMSALTokenSilent(
  providerAccountId: string,
  scopes: string[] = MSAL_DEVICE_CODE_SCOPES,
): Promise<{
  accessToken: string;
  expiresAt: Date;
  account: AccountInfo;
} | null> {
  if (!isMSALDeviceCodeEnabled()) {
    logger.warn("MSAL device code flow is not enabled");
    return null;
  }

  // Use per-account MSAL instance with cache plugin
  const app = getMSALApp(providerAccountId);
  const tokenCache = app.getTokenCache();

  try {
    const accounts = await tokenCache.getAllAccounts();
    
    if (accounts.length === 0) {
      logger.info("No accounts found in MSAL cache, trying direct refresh", { providerAccountId });
      return await directTokenRefresh(providerAccountId, scopes);
    }

    const account = accounts.find(
      (acc: AccountInfo) => acc.localAccountId === providerAccountId,
    );

    if (!account) {
      logger.info("Account not found in MSAL cache", { providerAccountId });
      return await directTokenRefresh(providerAccountId, scopes);
    }

    const result = await app.acquireTokenSilent({ account, scopes });
    
    if (!result) {
      logger.warn("acquireTokenSilent returned null", { providerAccountId });
      return await directTokenRefresh(providerAccountId, scopes);
    }

    logger.info("Successfully acquired token silently", {
      providerAccountId,
      expiresOn: result.expiresOn?.toISOString(),
    });

    return {
      accessToken: result.accessToken,
      expiresAt: result.expiresOn || new Date(Date.now() + 3_600_000),
      account,
    };
  } catch (error) {
    logger.error("Failed to acquire token silently, trying direct refresh", {
      providerAccountId,
      error: error instanceof Error ? error.message : String(error),
    });
    return await directTokenRefresh(providerAccountId, scopes);
  }
}
```

---

### Phase 4: Direct OAuth2 Token Refresh Fallback

**File:** `/Users/hack/github/inbox-zero/apps/web/utils/outlook/msal-device-code.ts`

Add these new functions at the end of the file (before the final closing brace):

```typescript
/**
 * Extract refresh token from stored MSAL cache
 * Used as fallback when acquireTokenSilent fails
 */
async function extractRefreshTokenFromCache(
  providerAccountId: string
): Promise<string | null> {
  const account = await prisma.account.findFirst({
    where: { 
      provider: "microsoft",
      providerAccountId 
    },
    select: { msal_cache: true },
  });

  if (!account?.msal_cache) {
    return null;
  }

  try {
    const decrypted = decryptToken(account.msal_cache);
    if (!decrypted) return null;

    // MSAL cache JSON structure contains RefreshToken entries
    const cache = JSON.parse(decrypted);
    const refreshTokens = cache.RefreshToken || {};
    
    // Find refresh token for this account
    for (const key of Object.keys(refreshTokens)) {
      if (key.toLowerCase().includes(providerAccountId.toLowerCase())) {
        return refreshTokens[key].secret;
      }
    }

    // Fallback: return first available refresh token
    const firstToken = Object.values(refreshTokens)[0] as { secret?: string } | undefined;
    return firstToken?.secret || null;
  } catch (error) {
    logger.error("Failed to extract refresh token from cache", { 
      providerAccountId, 
      error: error instanceof Error ? error.message : String(error),
    });
    return null;
  }
}

/**
 * Direct OAuth2 token refresh using Microsoft token endpoint
 * Fallback for when MSAL silent acquisition fails but we have a stored refresh token
 */
async function directTokenRefresh(
  providerAccountId: string,
  scopes: string[] = MSAL_DEVICE_CODE_SCOPES,
): Promise<{
  accessToken: string;
  expiresAt: Date;
  account: AccountInfo;
} | null> {
  logger.info("Attempting direct token refresh", { providerAccountId });

  const refreshToken = await extractRefreshTokenFromCache(providerAccountId);
  
  if (!refreshToken) {
    logger.warn("No refresh token available for direct refresh", { providerAccountId });
    return null;
  }

  const clientId = env.MSAL_CLIENT_ID || env.MICROSOFT_CLIENT_ID || MICROSOFT_OFFICE_CLIENT_ID;
  const tenantId = env.MSAL_TENANT_ID || env.MICROSOFT_TENANT_ID || "common";

  try {
    const response = await fetch(
      `https://login.microsoftonline.com/${tenantId}/oauth2/v2.0/token`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
        },
        body: new URLSearchParams({
          client_id: clientId,
          refresh_token: refreshToken,
          grant_type: "refresh_token",
          scope: scopes.join(" "),
        }),
      },
    );

    const tokens = await response.json();

    if (!response.ok) {
      logger.error("Direct token refresh failed", {
        providerAccountId,
        error: tokens.error_description || tokens.error,
      });
      return null;
    }

    logger.info("Direct token refresh successful", { providerAccountId });

    // Update stored tokens in Account table
    const encryptedAccessToken = encryptToken(tokens.access_token);
    await prisma.account.updateMany({
      where: { provider: "microsoft", providerAccountId },
      data: {
        access_token: encryptedAccessToken,
        expires_at: new Date(Date.now() + tokens.expires_in * 1000),
      },
    });

    // If we got a new refresh token, update the MSAL cache
    if (tokens.refresh_token) {
      await updateRefreshTokenInCache(providerAccountId, tokens.refresh_token);
    }

    return {
      accessToken: tokens.access_token,
      expiresAt: new Date(Date.now() + tokens.expires_in * 1000),
      account: {
        localAccountId: providerAccountId,
        homeAccountId: providerAccountId,
        environment: "login.microsoftonline.com",
        tenantId: tenantId,
        username: "",
      } as AccountInfo,
    };
  } catch (error) {
    logger.error("Direct token refresh error", {
      providerAccountId,
      error: error instanceof Error ? error.message : String(error),
    });
    return null;
  }
}

/**
 * Update refresh token in stored MSAL cache
 */
async function updateRefreshTokenInCache(
  providerAccountId: string,
  newRefreshToken: string,
): Promise<void> {
  const account = await prisma.account.findFirst({
    where: { provider: "microsoft", providerAccountId },
    select: { msal_cache: true },
  });

  if (!account?.msal_cache) return;

  try {
    const decrypted = decryptToken(account.msal_cache);
    if (!decrypted) return;

    const cache = JSON.parse(decrypted);
    const refreshTokens = cache.RefreshToken || {};

    // Update existing refresh token entries
    for (const key of Object.keys(refreshTokens)) {
      if (key.toLowerCase().includes(providerAccountId.toLowerCase())) {
        refreshTokens[key].secret = newRefreshToken;
      }
    }

    cache.RefreshToken = refreshTokens;
    const encrypted = encryptToken(JSON.stringify(cache));

    await prisma.account.updateMany({
      where: { provider: "microsoft", providerAccountId },
      data: { 
        msal_cache: encrypted,
        msal_cache_updated: new Date(),
      },
    });
  } catch (error) {
    logger.error("Failed to update refresh token in cache", { 
      providerAccountId, 
      error: error instanceof Error ? error.message : String(error),
    });
  }
}
```

---

### Phase 5: Update Device Code Poll Endpoint

**File:** `/Users/hack/github/inbox-zero/apps/web/app/api/outlook/device-code/poll/route.ts`

#### 5.1 Add imports at top:

```typescript
import { getMSALApp } from "@/utils/outlook/msal-device-code";
```

#### 5.2 Update `completeDeviceCodeAuthentication` function (around line 219, after the account upsert):

Add this code block after the `prisma.account.upsert` call:

```typescript
  // After account is created, persist the MSAL cache for future token refresh
  try {
    const app = getMSALApp();
    const tokenCache = app.getTokenCache();
    const serializedCache = tokenCache.serialize();
    
    if (serializedCache) {
      const encryptedCache = encryptToken(serializedCache);
      await prisma.account.updateMany({
        where: { 
          provider: "microsoft", 
          providerAccountId 
        },
        data: { 
          msal_cache: encryptedCache,
          msal_cache_updated: new Date(),
        },
      });
      logger.info("Persisted initial MSAL cache", { providerAccountId });
    }
  } catch (error) {
    // Non-fatal - log but don't fail the auth flow
    logger.error("Failed to persist initial MSAL cache", { 
      providerAccountId,
      error: error instanceof Error ? error.message : String(error),
    });
  }
```

---

## Edge Cases and Error Handling

### Multi-Instance Deployment

**Problem:** Multiple server instances may have stale in-memory caches.

**Solution:** The `ICachePlugin.beforeCacheAccess` is called before every token operation, ensuring the latest cache is loaded from the database.

### Cache Invalidation

**Problem:** User revokes access or changes password at Microsoft.

**Solution:** 
1. Direct OAuth2 refresh will fail with specific error codes (AADSTS70008, AADSTS50173, etc.)
2. Existing error handling in `/Users/hack/github/inbox-zero/apps/web/utils/outlook/client.ts` (lines 182-232) already handles these errors
3. User will be prompted to re-authenticate

### Encryption Key Rotation

**Problem:** If `EMAIL_ENCRYPT_SECRET` or `EMAIL_ENCRYPT_SALT` change, cached tokens become unreadable.

**Solution:**
1. Existing encryption utilities in `/Users/hack/github/inbox-zero/apps/web/utils/encryption.ts` already handle decryption failures gracefully (return `null`)
2. When cache decryption fails, the direct OAuth2 refresh fallback will also fail
3. User must re-authenticate - document this in ops runbook

### Race Conditions

**Problem:** Concurrent requests may race to update the cache.

**Solution:**
1. MSAL's token cache is designed to handle concurrent access
2. The `cacheHasChanged` flag prevents unnecessary writes
3. Prisma's `updateMany` is atomic
4. Accept that in rare cases, slightly older cache may be persisted (acceptable trade-off)

---

## Testing Plan

### Manual Testing Checklist

1. [ ] Device-code login at `/login/device-code`
2. [ ] Verify `msal_cache` field populated in Account table
3. [ ] Verify email stats load on setup page
4. [ ] Navigate to calendars, connect Outlook calendar
5. [ ] Restart dev server (`pnpm dev`)
6. [ ] Return to app - verify still authenticated (token refresh works)
7. [ ] Wait 1+ hour (or manually expire access token in DB)
8. [ ] Verify token refresh works without re-authentication

### Verification Queries

```sql
-- Check if MSAL cache is being stored
SELECT providerAccountId, 
       msal_cache IS NOT NULL as has_cache,
       msal_cache_updated
FROM "Account"
WHERE provider = 'microsoft';
```

---

## Rollback Procedure

If issues arise:

1. **Quick Disable:** Set `MSAL_ENABLED=false` in environment
2. **Schema Rollback:** 
   ```bash
   npx prisma migrate rollback --target add_msal_cache_to_account
   ```
3. **Code Rollback:** `git revert` the commits from this implementation

---

## Summary of Changes

| File | Change Type | Description |
|------|-------------|-------------|
| `apps/web/prisma/schema.prisma` | Modify | Add `msal_cache` and `msal_cache_updated` fields |
| `apps/web/utils/outlook/msal-cache-plugin.ts` | New | ICachePlugin implementation |
| `apps/web/utils/outlook/msal-device-code.ts` | Modify | Update factory pattern, add fallback functions |
| `apps/web/app/api/outlook/device-code/poll/route.ts` | Modify | Persist cache after successful auth |

---

### Critical Files for Implementation

1. **`/Users/hack/github/inbox-zero/apps/web/prisma/schema.prisma`** - Add `msal_cache` and `msal_cache_updated` fields to Account model (around line 24-31)

2. **`/Users/hack/github/inbox-zero/apps/web/utils/outlook/msal-device-code.ts`** - Core MSAL logic to update with cache plugin integration, factory pattern, and direct OAuth2 fallback

3. **`/Users/hack/github/inbox-zero/apps/web/utils/encryption.ts`** - Existing encryption utilities (no changes needed, reference for `encryptToken`/`decryptToken` patterns)

4. **`/Users/hack/github/inbox-zero/apps/web/app/api/outlook/device-code/poll/route.ts`** - Persist MSAL cache after successful device-code authentication (around line 219)

5. **`/Users/hack/github/inbox-zero/apps/web/utils/outlook/msal-cache-plugin.ts`** (NEW FILE) - ICachePlugin implementation for Prisma persistence using the encryption utilities
agentId: a63a101 (for resuming to continue this agent's work if needed)
```
</details></tool-use>

_**Agent - sidechain (2026-01-24T04:06:33.944Z)**_

Based on the gap analysis for MSAL device-code flow in inbox-zero:

**Critical Problem:**
The inbox-zero implementation discards refresh tokens and uses only in-memory MSAL cache, causing users to re-authenticate on server restart or cache clear.

**Reference Implementation Pattern (outlook-creds):**
- Stores refresh_token persistently
- Uses direct OAuth2 token endpoint refresh as fallback
- Survives process restarts

**Key Files to Analyze:**
1. `/Users/hack/github/inbox-zero/apps/web/utils/outlook/msal-device-code.ts` - MSAL flow implementation
2. `/Users/hack/github/inbox-zero/apps/web/app/api/outlook/device-code/poll/route.ts` - Account creation
3. `/Users/hack/github/inbox-zero/apps/web/utils/outlook/client.ts` - Token refresh logic

**Design a fix that:**
1. Extracts and stores refresh_token from MSAL's token cache (since AuthenticationResult doesn't expose it)
2. Implements a persistent cache plugin OR uses database storage
3. Adds direct token endpoint refresh as fallback when MSAL cache is empty
4. Maintains backward compatibility with existing OAuth flow

Consider:
- MSAL Node.js ICachePlugin interface
- Prisma schema changes needed
- Encryption for stored tokens (existing encryptToken utility)
- Edge cases (multi-instance deployment, cache invalidation)

Provide a detailed implementation plan with specific code changes.

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-24T04:06:36.741Z)**_

I'll analyze the codebase to understand the current implementation and design a comprehensive fix for the MSAL device-code flow token persistence issue.

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-24T04:06:37.103Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./apps/web/utils/outlook/msal-device-code.ts`
```
     1→/**
     2→ * MSAL Device Code Flow Authentication
     3→ *
     4→ * Provides device-code authentication for Microsoft accounts as an alternative
     5→ * to browser-based OAuth. Useful for CLI/headless environments.
     6→ *
     7→ * Key Features:
     8→ * - Uses MSAL Node.js library for device code flow
     9→ * - In-memory storage for pending flows (15-min expiration)
    10→ * - Integrates with existing token encryption system
    11→ * - Non-breaking: runs parallel to existing Better Auth OAuth
    12→ */
    13→
    14→import {
    15→  PublicClientApplication,
    16→  type DeviceCodeRequest,
    17→  type AuthenticationResult,
    18→  type AccountInfo,
    19→  LogLevel,
    20→  type INetworkModule,
    21→  type NetworkRequestOptions,
    22→  type NetworkResponse,
    23→} from "@azure/msal-node";
    24→import { env } from "@/env";
    25→import { createScopedLogger } from "@/utils/logger";
    26→
    27→/**
    28→ * Custom network module to handle fetch issues in Node.js 22+
    29→ * Uses fresh fetch calls with abort controller timeouts to avoid
    30→ * undici connection pool issues that cause "fetch failed" errors
    31→ */
    32→class CustomNetworkModule implements INetworkModule {
    33→  private readonly logger = createScopedLogger("msal-network");
    34→
    35→  async sendGetRequestAsync<T>(
    36→    url: string,
    37→    options?: NetworkRequestOptions,
    38→  ): Promise<NetworkResponse<T>> {
    39→    return this.sendRequest<T>(url, "GET", options);
    40→  }
    41→
    42→  async sendPostRequestAsync<T>(
    43→    url: string,
    44→    options?: NetworkRequestOptions,
    45→  ): Promise<NetworkResponse<T>> {
    46→    return this.sendRequest<T>(url, "POST", options);
    47→  }
    48→
    49→  private async sendRequest<T>(
    50→    url: string,
    51→    method: string,
    52→    options?: NetworkRequestOptions,
    53→  ): Promise<NetworkResponse<T>> {
    54→    const controller = new AbortController();
    55→    const timeoutId = setTimeout(() => controller.abort(), 30_000); // 30 second timeout
    56→
    57→    try {
    58→      const response = await fetch(url, {
    59→        method,
    60→        headers: options?.headers as Record<string, string>,
    61→        body: options?.body,
    62→        signal: controller.signal,
    63→        // Disable keep-alive to avoid connection pool issues
    64→        keepalive: false,
    65→      });
    66→
    67→      clearTimeout(timeoutId);
    68→
    69→      const headers: Record<string, string> = {};
    70→      response.headers.forEach((value, key) => {
    71→        headers[key] = value;
    72→      });
    73→
    74→      const body = (await response.json()) as T;
    75→
    76→      return {
    77→        headers,
    78→        body,
    79→        status: response.status,
    80→      };
    81→    } catch (error) {
    82→      clearTimeout(timeoutId);
    83→      this.logger.error("Network request failed", {
    84→        url,
    85→        method,
    86→        error: error instanceof Error ? error.message : String(error),
    87→      });
    88→      throw error;
    89→    }
    90→  }
    91→}
    92→
    93→// Use .default scope for device code flow with Microsoft Office client ID
    94→// This requests all pre-authorized permissions without requiring explicit consent
    95→const MSAL_DEVICE_CODE_SCOPES = ["https://graph.microsoft.com/.default"];
    96→
    97→// DeviceCodeResponse type matches what MSAL passes to the deviceCodeCallback
    98→// Defined locally to avoid importing from @azure/msal-common which is a transitive dep
    99→interface DeviceCodeResponse {
   100→  deviceCode: string;
   101→  userCode: string;
   102→  verificationUri: string;
   103→  expiresIn: number; // seconds until expiration
   104→  interval: number; // polling interval in seconds
   105→  message: string;
   106→}
   107→
   108→const logger = createScopedLogger("msal-device-code");
   109→
   110→// Default Microsoft Office client ID - works without app registration
   111→const MICROSOFT_OFFICE_CLIENT_ID = "d3590ed6-52b3-4102-aeff-aad2292ab01c";
   112→
   113→// Singleton MSAL application instance
   114→let msalApp: PublicClientApplication | null = null;
   115→
   116→function getMSALApp(): PublicClientApplication {
   117→  if (!msalApp) {
   118→    const clientId =
   119→      env.MSAL_CLIENT_ID ||
   120→      env.MICROSOFT_CLIENT_ID ||
   121→      MICROSOFT_OFFICE_CLIENT_ID;
   122→    const tenantId = env.MSAL_TENANT_ID || env.MICROSOFT_TENANT_ID || "common";
   123→    const debugEnabled = env.MSAL_DEBUG === "true";
   124→
   125→    msalApp = new PublicClientApplication({
   126→      auth: {
   127→        clientId,
   128→        authority: `https://login.microsoftonline.com/${tenantId}`,
   129→      },
   130→      system: {
   131→        loggerOptions: {
   132→          loggerCallback: (
   133→            level: LogLevel,
   134→            message: string,
   135→            containsPii: boolean,
   136→          ) => {
   137→            if (containsPii) return; // Don't log PII
   138→            if (debugEnabled || level === LogLevel.Error) {
   139→              logger.info(`MSAL [${LogLevel[level]}]: ${message}`);
   140→            }
   141→          },
   142→          piiLoggingEnabled: false,
   143→          logLevel: debugEnabled ? LogLevel.Verbose : LogLevel.Error,
   144→        },
   145→        // Use custom network module to avoid Node.js 22+ undici connection pool issues
   146→        networkClient: new CustomNetworkModule(),
   147→      },
   148→    });
   149→  }
   150→  return msalApp;
   151→}
   152→
   153→// Feature flag - defaults to disabled until explicitly enabled
   154→export function isMSALDeviceCodeEnabled(): boolean {
   155→  return env.MSAL_ENABLED === "true";
   156→}
   157→
   158→// Active device code flows (for polling)
   159→interface ActiveFlow {
   160→  deviceCode: string;
   161→  userCode: string;
   162→  verificationUri: string;
   163→  expiresAt: Date;
   164→  message: string;
   165→  promise: Promise<AuthenticationResult | null>;
   166→  resolve: (result: AuthenticationResult | null) => void;
   167→  reject: (error: Error) => void;
   168→}
   169→
   170→// Use globalThis to persist flows across Next.js hot reloads in development
   171→const globalForFlows = globalThis as unknown as {
   172→  msalActiveFlows: Map<string, ActiveFlow> | undefined;
   173→};
   174→
   175→const activeFlows =
   176→  globalForFlows.msalActiveFlows ?? new Map<string, ActiveFlow>();
   177→
   178→if (process.env.NODE_ENV !== "production") {
   179→  globalForFlows.msalActiveFlows = activeFlows;
   180→}
   181→
   182→// Cleanup expired flows periodically
   183→function cleanupExpiredFlows(): void {
   184→  const now = new Date();
   185→  for (const [sessionId, flow] of activeFlows.entries()) {
   186→    if (now > flow.expiresAt) {
   187→      activeFlows.delete(sessionId);
   188→      logger.info("Cleaned up expired device code flow", { sessionId });
   189→    }
   190→  }
   191→}
   192→
   193→// Run cleanup every 5 minutes
   194→setInterval(cleanupExpiredFlows, 5 * 60 * 1000);
   195→
   196→export interface DeviceCodeInitResponse {
   197→  sessionId: string;
   198→  userCode: string;
   199→  verificationUri: string;
   200→  expiresAt: Date;
   201→  message: string;
   202→}
   203→
   204→/**
   205→ * Initiate device code flow
   206→ * Returns the device code info for display to user
   207→ */
   208→export async function initiateDeviceCodeFlow(
   209→  sessionId: string,
   210→): Promise<DeviceCodeInitResponse> {
   211→  if (!isMSALDeviceCodeEnabled()) {
   212→    throw new Error("MSAL device code flow is not enabled");
   213→  }
   214→
   215→  const app = getMSALApp();
   216→
   217→  // Clean up expired flows
   218→  cleanupExpiredFlows();
   219→
   220→  // Check if session already exists
   221→  if (activeFlows.has(sessionId)) {
   222→    throw new Error("Session already exists");
   223→  }
   224→
   225→  let flowResolve: (result: AuthenticationResult | null) => void;
   226→  let flowReject: (error: Error) => void;
   227→  let capturedDeviceCode: DeviceCodeResponse | null = null;
   228→
   229→  const flowPromise = new Promise<AuthenticationResult | null>(
   230→    (resolve, reject) => {
   231→      flowResolve = resolve;
   232→      flowReject = reject;
   233→    },
   234→  );
   235→
   236→  const deviceCodeRequest: DeviceCodeRequest = {
   237→    scopes: MSAL_DEVICE_CODE_SCOPES,
   238→    deviceCodeCallback: (response: DeviceCodeResponse) => {
   239→      capturedDeviceCode = response;
   240→
   241→      // Calculate expiration time from expiresIn (seconds)
   242→      const expiresAt = new Date(Date.now() + response.expiresIn * 1000);
   243→
   244→      // Store flow info for polling
   245→      activeFlows.set(sessionId, {
   246→        deviceCode: response.deviceCode,
   247→        userCode: response.userCode,
   248→        verificationUri: response.verificationUri,
   249→        expiresAt,
   250→        message: response.message,
   251→        promise: flowPromise,
   252→        resolve: flowResolve!,
   253→        reject: flowReject!,
   254→      });
   255→
   256→      logger.info("Device code flow initiated", {
   257→        sessionId,
   258→        userCode: response.userCode,
   259→        expiresAt: expiresAt.toISOString(),
   260→      });
   261→    },
   262→    timeout: 900, // 15 minutes
   263→  };
   264→
   265→  // Start the flow (don't await - it blocks until user completes)
   266→  const authPromise = app.acquireTokenByDeviceCode(deviceCodeRequest);
   267→
   268→  // Wait for the callback to be called (provides device code)
   269→  await new Promise<void>((resolve, reject) => {
   270→    const checkInterval = setInterval(() => {
   271→      if (capturedDeviceCode) {
   272→        clearInterval(checkInterval);
   273→        resolve();
   274→      }
   275→    }, 100);
   276→
   277→    // Timeout after 10 seconds if callback not called
   278→    setTimeout(() => {
   279→      clearInterval(checkInterval);
   280→      if (!capturedDeviceCode) {
   281→        reject(new Error("Device code callback timeout"));
   282→      }
   283→    }, 10_000);
   284→  });
   285→
   286→  const flow = activeFlows.get(sessionId);
   287→  // Cast is needed because TypeScript doesn't track assignment in async callbacks
   288→  const deviceCodeInfo = capturedDeviceCode as DeviceCodeResponse | null;
   289→  if (!flow || !deviceCodeInfo) {
   290→    throw new Error("Failed to initiate device code flow");
   291→  }
   292→
   293→  // Wire up the auth promise to resolve/reject the flow
   294→  authPromise
   295→    .then((result: AuthenticationResult | null) => {
   296→      logger.info("Device code flow completed", { sessionId });
   297→      flow.resolve(result);
   298→    })
   299→    .catch((error: Error) => {
   300→      // Log detailed error info for debugging network issues
   301→      const errorDetails = {
   302→        sessionId,
   303→        error: error.message,
   304→        name: error.name,
   305→        stack: error.stack?.split("\n").slice(0, 5).join("\n"),
   306→        cause: error.cause ? String(error.cause) : undefined,
   307→      };
   308→      logger.error("Device code flow failed", errorDetails);
   309→      flow.reject(error);
   310→    });
   311→
   312→  // Calculate expiration time from expiresIn (seconds)
   313→  const expiresAt = new Date(Date.now() + deviceCodeInfo.expiresIn * 1000);
   314→
   315→  return {
   316→    sessionId,
   317→    userCode: deviceCodeInfo.userCode,
   318→    verificationUri: deviceCodeInfo.verificationUri,
   319→    expiresAt,
   320→    message: deviceCodeInfo.message,
   321→  };
   322→}
   323→
   324→export interface PollResult {
   325→  status: "pending" | "complete" | "expired" | "error";
   326→  error?: string;
   327→  result?: {
   328→    accessToken: string;
   329→    expiresAt: Date;
   330→    scopes: string[];
   331→    account: AccountInfo | null;
   332→  };
   333→}
   334→
   335→/**
   336→ * Poll for device code completion
   337→ */
   338→export async function pollDeviceCodeFlow(
   339→  sessionId: string,
   340→): Promise<PollResult> {
   341→  logger.info("Poll called", {
   342→    sessionId,
   343→    activeFlowCount: activeFlows.size,
   344→    hasFlow: activeFlows.has(sessionId),
   345→  });
   346→
   347→  const flow = activeFlows.get(sessionId);
   348→
   349→  if (!flow) {
   350→    logger.info("Flow not found in activeFlows", { sessionId });
   351→    return { status: "expired" };
   352→  }
   353→
   354→  if (new Date() > flow.expiresAt) {
   355→    logger.info("Flow expired", { sessionId, expiresAt: flow.expiresAt });
   356→    activeFlows.delete(sessionId);
   357→    return { status: "expired" };
   358→  }
   359→
   360→  // Check if promise is resolved (non-blocking check)
   361→  const raceResult = await Promise.race([
   362→    flow.promise
   363→      .then((result) => ({ done: true as const, result, error: null }))
   364→      .catch((error) => ({ done: true as const, result: null, error })),
   365→    new Promise<{ done: false }>((resolve) =>
   366→      setTimeout(() => resolve({ done: false }), 100),
   367→    ),
   368→  ]);
   369→
   370→  if (!raceResult.done) {
   371→    return { status: "pending" };
   372→  }
   373→
   374→  // Flow completed - clean up
   375→  activeFlows.delete(sessionId);
   376→
   377→  if (raceResult.error) {
   378→    const errorMessage =
   379→      raceResult.error instanceof Error
   380→        ? raceResult.error.message
   381→        : String(raceResult.error);
   382→
   383→    // Check for user cancellation
   384→    if (errorMessage.includes("authorization_pending")) {
   385→      return { status: "pending" };
   386→    }
   387→
   388→    logger.error("Device code flow error", { sessionId, error: errorMessage });
   389→    return { status: "error", error: errorMessage };
   390→  }
   391→
   392→  if (!raceResult.result) {
   393→    return { status: "error", error: "No authentication result" };
   394→  }
   395→
   396→  return {
   397→    status: "complete",
   398→    result: {
   399→      accessToken: raceResult.result.accessToken,
   400→      expiresAt:
   401→        raceResult.result.expiresOn || new Date(Date.now() + 3_600_000),
   402→      scopes: raceResult.result.scopes,
   403→      account: raceResult.result.account,
   404→    },
   405→  };
   406→}
   407→
   408→/**
   409→ * Cancel an active device code flow
   410→ */
   411→export function cancelDeviceCodeFlow(sessionId: string): boolean {
   412→  const flow = activeFlows.get(sessionId);
   413→  if (flow) {
   414→    flow.reject(new Error("Flow cancelled by user"));
   415→    activeFlows.delete(sessionId);
   416→    logger.info("Device code flow cancelled", { sessionId });
   417→    return true;
   418→  }
   419→  return false;
   420→}
   421→
   422→/**
   423→ * Get count of active flows (for monitoring)
   424→ */
   425→export function getActiveFlowCount(): number {
   426→  cleanupExpiredFlows();
   427→  return activeFlows.size;
   428→}
   429→
   430→/**
   431→ * Acquire token silently from MSAL cache
   432→ * Used for device-code authenticated accounts to get fresh tokens for calendar operations
   433→ *
   434→ * @param providerAccountId - The MSAL account's localAccountId (stored as providerAccountId in DB)
   435→ * @param scopes - Optional scopes to request (defaults to .default which includes all permissions)
   436→ * @returns Token info or null if account not in cache
   437→ */
   438→export async function acquireMSALTokenSilent(
   439→  providerAccountId: string,
   440→  scopes: string[] = MSAL_DEVICE_CODE_SCOPES,
   441→): Promise<{
   442→  accessToken: string;
   443→  expiresAt: Date;
   444→  account: AccountInfo;
   445→} | null> {
   446→  if (!isMSALDeviceCodeEnabled()) {
   447→    logger.warn("MSAL device code flow is not enabled");
   448→    return null;
   449→  }
   450→
   451→  const app = getMSALApp();
   452→  const tokenCache = app.getTokenCache();
   453→
   454→  try {
   455→    // Get all accounts from MSAL cache
   456→    const accounts = await tokenCache.getAllAccounts();
   457→
   458→    if (accounts.length === 0) {
   459→      logger.info("No accounts found in MSAL cache");
   460→      return null;
   461→    }
   462→
   463→    // Find the account matching the providerAccountId
   464→    const account = accounts.find(
   465→      (acc: AccountInfo) => acc.localAccountId === providerAccountId,
   466→    );
   467→
   468→    if (!account) {
   469→      logger.info("Account not found in MSAL cache", {
   470→        providerAccountId,
   471→        cachedAccountIds: accounts.map((a: AccountInfo) => a.localAccountId),
   472→      });
   473→      return null;
   474→    }
   475→
   476→    // Acquire token silently using cached credentials
   477→    const result = await app.acquireTokenSilent({
   478→      account,
   479→      scopes,
   480→    });
   481→
   482→    if (!result) {
   483→      logger.warn("acquireTokenSilent returned null", { providerAccountId });
   484→      return null;
   485→    }
   486→
   487→    logger.info("Successfully acquired token silently", {
   488→      providerAccountId,
   489→      expiresOn: result.expiresOn?.toISOString(),
   490→    });
   491→
   492→    return {
   493→      accessToken: result.accessToken,
   494→      expiresAt: result.expiresOn || new Date(Date.now() + 3_600_000), // Default 1 hour
   495→      account,
   496→    };
   497→  } catch (error) {
   498→    logger.error("Failed to acquire token silently", {
   499→      providerAccountId,
   500→      error: error instanceof Error ? error.message : String(error),
   501→    });
   502→    return null;
   503→  }
   504→}
   505→
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-24T04:06:37.529Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./apps/web/utils/outlook/client.ts`
```
     1→import { Client } from "@microsoft/microsoft-graph-client";
     2→import type { User } from "@microsoft/microsoft-graph-types";
     3→import { saveTokens } from "@/utils/auth";
     4→import { env } from "@/env";
     5→import type { Logger } from "@/utils/logger";
     6→import { SCOPES } from "@/utils/outlook/scopes";
     7→import { SafeError } from "@/utils/error";
     8→import { acquireMSALTokenSilent } from "@/utils/outlook/msal-device-code";
     9→import { encryptToken } from "@/utils/encryption";
    10→import prisma from "@/utils/prisma";
    11→
    12→// Add buffer time to prevent token expiry during long-running operations
    13→const TOKEN_REFRESH_BUFFER_MS = 10 * 60 * 1000; // 10 minutes
    14→
    15→// Wrapper class to hold both the Microsoft Graph client and its access token
    16→export class OutlookClient {
    17→  private readonly client: Client;
    18→  private readonly accessToken: string;
    19→  private readonly logger: Logger;
    20→  private folderIdCache: Record<string, string> | null = null;
    21→
    22→  constructor(accessToken: string, logger: Logger) {
    23→    this.accessToken = accessToken;
    24→    this.logger = logger;
    25→    this.client = Client.init({
    26→      authProvider: (done) => {
    27→        done(null, this.accessToken);
    28→      },
    29→      defaultVersion: "v1.0",
    30→      // Use immutable IDs to ensure message IDs remain stable
    31→      // https://learn.microsoft.com/en-us/graph/outlook-immutable-id
    32→      fetchOptions: {
    33→        headers: {
    34→          Prefer: 'IdType="ImmutableId"',
    35→        },
    36→      },
    37→    });
    38→  }
    39→
    40→  getClient(): Client {
    41→    return this.client;
    42→  }
    43→
    44→  getAccessToken(): string {
    45→    return this.accessToken;
    46→  }
    47→
    48→  getFolderIdCache(): Record<string, string> | null {
    49→    return this.folderIdCache;
    50→  }
    51→
    52→  setFolderIdCache(cache: Record<string, string>): void {
    53→    this.folderIdCache = cache;
    54→  }
    55→
    56→  // Helper methods for common operations
    57→  async getUserProfile(): Promise<User> {
    58→    return await this.client
    59→      .api("/me")
    60→      .select("id,displayName,mail,userPrincipalName")
    61→      .get();
    62→  }
    63→
    64→  async getUserPhoto(): Promise<string | null> {
    65→    try {
    66→      const photoResponse = await this.client.api("/me/photo/$value").get();
    67→
    68→      if (photoResponse) {
    69→        const arrayBuffer = await photoResponse.arrayBuffer();
    70→        const base64 = Buffer.from(arrayBuffer).toString("base64");
    71→        return `data:image/jpeg;base64,${base64}`;
    72→      }
    73→      return null;
    74→    } catch {
    75→      this.logger.warn("Error getting user photo");
    76→      return null;
    77→    }
    78→  }
    79→}
    80→
    81→// Helper to create OutlookClient instance
    82→export const createOutlookClient = (accessToken: string, logger: Logger) => {
    83→  if (!accessToken) throw new SafeError("No access token provided");
    84→  return new OutlookClient(accessToken, logger);
    85→};
    86→
    87→// Similar to Gmail's getGmailClientWithRefresh
    88→export const getOutlookClientWithRefresh = async ({
    89→  accessToken,
    90→  refreshToken,
    91→  expiresAt,
    92→  emailAccountId,
    93→  providerAccountId,
    94→  logger,
    95→}: {
    96→  accessToken?: string | null;
    97→  refreshToken: string | null;
    98→  expiresAt: number | null;
    99→  emailAccountId: string;
   100→  providerAccountId?: string | null;
   101→  logger: Logger;
   102→}): Promise<OutlookClient> => {
   103→  // Check if token is still valid
   104→  const expiryDate = expiresAt ? expiresAt : null;
   105→  if (
   106→    accessToken &&
   107→    expiryDate &&
   108→    expiryDate > Date.now() + TOKEN_REFRESH_BUFFER_MS
   109→  ) {
   110→    return createOutlookClient(accessToken, logger);
   111→  }
   112→
   113→  // For device-code accounts (no refresh token), use MSAL silent acquisition
   114→  if (!refreshToken && providerAccountId) {
   115→    logger.info("Using MSAL silent acquisition for email token refresh", {
   116→      emailAccountId,
   117→      providerAccountId,
   118→    });
   119→
   120→    const msalResult = await acquireMSALTokenSilent(providerAccountId);
   121→
   122→    if (!msalResult) {
   123→      throw new SafeError(
   124→        "Authentication expired. Please log in again using device code flow.",
   125→      );
   126→    }
   127→
   128→    // Update the account with the fresh token
   129→    await prisma.account.updateMany({
   130→      where: { providerAccountId },
   131→      data: {
   132→        access_token: encryptToken(msalResult.accessToken),
   133→        expires_at: msalResult.expiresAt,
   134→      },
   135→    });
   136→
   137→    logger.info("Updated account with MSAL token", {
   138→      emailAccountId,
   139→      providerAccountId,
   140→    });
   141→
   142→    return createOutlookClient(msalResult.accessToken, logger);
   143→  }
   144→
   145→  // Standard OAuth flow - requires refresh token
   146→  if (!refreshToken) {
   147→    logger.error("No refresh token", { emailAccountId });
   148→    throw new SafeError("No refresh token");
   149→  }
   150→
   151→  // Refresh token
   152→  try {
   153→    if (!env.MICROSOFT_CLIENT_ID || !env.MICROSOFT_CLIENT_SECRET) {
   154→      throw new Error("Microsoft login not enabled - missing credentials");
   155→    }
   156→
   157→    const response = await fetch(
   158→      `https://login.microsoftonline.com/${env.MICROSOFT_TENANT_ID}/oauth2/v2.0/token`,
   159→      {
   160→        method: "POST",
   161→        headers: {
   162→          "Content-Type": "application/x-www-form-urlencoded",
   163→        },
   164→        body: new URLSearchParams({
   165→          client_id: env.MICROSOFT_CLIENT_ID,
   166→          client_secret: env.MICROSOFT_CLIENT_SECRET,
   167→          refresh_token: refreshToken,
   168→          grant_type: "refresh_token",
   169→        }),
   170→      },
   171→    );
   172→
   173→    const tokens = await response.json();
   174→
   175→    if (!response.ok) {
   176→      const errorMessage =
   177→        tokens.error_description || "Failed to refresh token";
   178→
   179→      // AADSTS7000215 = Invalid client secret
   180→      // Happens when Azure AD client secret rotates or refresh token expires
   181→      // Background processes (watch-manager) will catch and log this as a warning
   182→      // User-facing flows will show an error prompting reconnection
   183→      if (errorMessage.includes("AADSTS7000215")) {
   184→        logger.warn(
   185→          "Microsoft refresh token failed - user may need to reconnect",
   186→          {
   187→            emailAccountId,
   188→          },
   189→        );
   190→      }
   191→
   192→      // Microsoft identity platform errors that require user re-authentication:
   193→      // AADSTS70000 = Scopes unauthorized or expired
   194→      // AADSTS70008 = Refresh token expired due to inactivity
   195→      // AADSTS70011 = Invalid scope
   196→      // AADSTS700082 = Refresh token expired
   197→      // AADSTS50173 = Invalid grant (refresh token revoked)
   198→      // AADSTS65001 = User hasn't consented to permissions
   199→      // AADSTS500011 = Resource principal not found (scope issue)
   200→      // AADSTS54005 = Authorization code already redeemed
   201→      // AADSTS50076 = MFA required (Conditional Access policy)
   202→      // AADSTS50079 = MFA registration required
   203→      // AADSTS50158 = External security challenge not satisfied
   204→      // invalid_grant = General token refresh failure
   205→      const requiresReauth =
   206→        errorMessage.includes("AADSTS70000") ||
   207→        errorMessage.includes("AADSTS70008") ||
   208→        errorMessage.includes("AADSTS70011") ||
   209→        errorMessage.includes("AADSTS700082") ||
   210→        errorMessage.includes("AADSTS50173") ||
   211→        errorMessage.includes("AADSTS65001") ||
   212→        errorMessage.includes("AADSTS500011") ||
   213→        errorMessage.includes("AADSTS54005") ||
   214→        errorMessage.includes("AADSTS50076") ||
   215→        errorMessage.includes("AADSTS50079") ||
   216→        errorMessage.includes("AADSTS50158") ||
   217→        errorMessage.includes("invalid_grant");
   218→
   219→      if (requiresReauth) {
   220→        logger.warn(
   221→          "Microsoft authorization expired - user needs to reconnect",
   222→          {
   223→            emailAccountId,
   224→            errorMessage,
   225→          },
   226→        );
   227→        throw new SafeError(
   228→          "Your Microsoft authorization has expired. Please sign out and log in again to reconnect your account.",
   229→        );
   230→      }
   231→
   232→      throw new Error(errorMessage);
   233→    }
   234→
   235→    // Save new tokens
   236→    await saveTokens({
   237→      tokens: {
   238→        access_token: tokens.access_token,
   239→        expires_at: Math.floor(Date.now() / 1000 + tokens.expires_in),
   240→      },
   241→      accountRefreshToken: refreshToken,
   242→      emailAccountId,
   243→      provider: "microsoft",
   244→    });
   245→
   246→    return createOutlookClient(tokens.access_token, logger);
   247→  } catch (error) {
   248→    const isInvalidGrantError =
   249→      error instanceof Error &&
   250→      (error.message.includes("invalid_grant") ||
   251→        error.message.includes("AADSTS50173"));
   252→
   253→    if (isInvalidGrantError) {
   254→      logger.warn("Error refreshing Outlook access token", { error });
   255→    }
   256→
   257→    throw error;
   258→  }
   259→};
   260→
   261→export const getAccessTokenFromClient = (client: OutlookClient): string => {
   262→  return client.getAccessToken();
   263→};
   264→
   265→// Helper function to get the OAuth2 URL for linking accounts
   266→export function getLinkingOAuth2Url() {
   267→  if (!env.MICROSOFT_CLIENT_ID) {
   268→    throw new Error("Microsoft login not enabled - missing client ID");
   269→  }
   270→
   271→  const baseUrl = `https://login.microsoftonline.com/${env.MICROSOFT_TENANT_ID}/oauth2/v2.0/authorize`;
   272→  const params = new URLSearchParams({
   273→    client_id: env.MICROSOFT_CLIENT_ID,
   274→    response_type: "code",
   275→    redirect_uri: `${env.NEXT_PUBLIC_BASE_URL}/api/outlook/linking/callback`,
   276→    scope: SCOPES.join(" "),
   277→    prompt: "select_account",
   278→  });
   279→
   280→  return `${baseUrl}?${params.toString()}`;
   281→}
   282→
   283→// Helper types for common Microsoft Graph operations
   284→export type { Client as GraphClient };
   285→
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-24T04:06:37.949Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./apps/web/app/api/outlook/device-code/poll/route.ts`
```
     1→import { type NextRequest, NextResponse } from "next/server";
     2→import { z } from "zod";
     3→import { serializeSignedCookie } from "better-call";
     4→import {
     5→  pollDeviceCodeFlow,
     6→  isMSALDeviceCodeEnabled,
     7→} from "@/utils/outlook/msal-device-code";
     8→import { createOutlookClient } from "@/utils/outlook/client";
     9→import { encryptToken } from "@/utils/encryption";
    10→import { createScopedLogger } from "@/utils/logger";
    11→import prisma from "@/utils/prisma";
    12→import { env } from "@/env";
    13→import { WELCOME_PATH } from "@/utils/config";
    14→
    15→const logger = createScopedLogger("api:msal:device-code:poll");
    16→
    17→interface CompletionResult {
    18→  email: string;
    19→  redirectUrl: string;
    20→  message: string;
    21→  signedSessionToken: string;
    22→  sessionExpires: Date;
    23→}
    24→
    25→interface CompletionEntry {
    26→  promise: Promise<CompletionResult>;
    27→  expiresAt: Date;
    28→}
    29→
    30→type PollCompleteResult = NonNullable<
    31→  Awaited<ReturnType<typeof pollDeviceCodeFlow>>["result"]
    32→>;
    33→
    34→const COMPLETION_CACHE_TTL_MS = 5 * 60 * 1000;
    35→const completionCache = getCompletionCache();
    36→
    37→const pollRequestSchema = z.object({
    38→  sessionId: z.string().min(1, "Session ID is required"),
    39→});
    40→
    41→export async function POST(request: NextRequest) {
    42→  if (!isMSALDeviceCodeEnabled()) {
    43→    return NextResponse.json(
    44→      { error: "MSAL device code authentication is not enabled" },
    45→      { status: 403 },
    46→    );
    47→  }
    48→
    49→  try {
    50→    const body = await request.json();
    51→    const { sessionId } = pollRequestSchema.parse(body);
    52→
    53→    logger.info("Poll request received", { sessionId });
    54→
    55→    cleanupCompletionCache();
    56→    const cachedCompletion = completionCache.get(sessionId);
    57→    if (cachedCompletion) {
    58→      return respondWithCompletionPromise({
    59→        sessionId,
    60→        entry: cachedCompletion,
    61→      });
    62→    }
    63→
    64→    const pollResult = await pollDeviceCodeFlow(sessionId);
    65→
    66→    logger.info("Poll result", { sessionId, status: pollResult.status });
    67→
    68→    if (pollResult.status === "pending") {
    69→      return NextResponse.json({ status: "pending" });
    70→    }
    71→
    72→    if (pollResult.status === "expired") {
    73→      const completedEntry = completionCache.get(sessionId);
    74→      if (completedEntry) {
    75→        return respondWithCompletionPromise({
    76→          sessionId,
    77→          entry: completedEntry,
    78→        });
    79→      }
    80→      logger.info("Flow expired or not found", { sessionId });
    81→      return NextResponse.json({ status: "expired" });
    82→    }
    83→
    84→    if (pollResult.status === "error") {
    85→      logger.error("Flow error", { sessionId, error: pollResult.error });
    86→      return NextResponse.json({
    87→        status: "error",
    88→        error: pollResult.error,
    89→      });
    90→    }
    91→
    92→    // Authentication complete - create/update account
    93→    if (pollResult.status === "complete" && pollResult.result) {
    94→      const completionPromise = completeDeviceCodeAuthentication({
    95→        pollResult: pollResult.result,
    96→        request,
    97→      });
    98→
    99→      completionCache.set(sessionId, {
   100→        promise: completionPromise,
   101→        expiresAt: new Date(Date.now() + COMPLETION_CACHE_TTL_MS),
   102→      });
   103→
   104→      return respondWithCompletionPromise({
   105→        sessionId,
   106→        entry: completionCache.get(sessionId)!,
   107→      });
   108→    }
   109→
   110→    return NextResponse.json({ status: pollResult.status });
   111→  } catch (error) {
   112→    if (error instanceof z.ZodError) {
   113→      return NextResponse.json(
   114→        { status: "error", error: "Invalid request body" },
   115→        { status: 400 },
   116→      );
   117→    }
   118→
   119→    logger.error("Poll failed", { error });
   120→    return NextResponse.json(
   121→      { status: "error", error: "Poll failed" },
   122→      { status: 500 },
   123→    );
   124→  }
   125→}
   126→
   127→async function respondWithCompletionPromise({
   128→  sessionId,
   129→  entry,
   130→}: {
   131→  sessionId: string;
   132→  entry: CompletionEntry;
   133→}): Promise<NextResponse> {
   134→  try {
   135→    const completion = await entry.promise;
   136→    return buildCompletionResponse(completion);
   137→  } catch (error) {
   138→    const errorMessage =
   139→      error instanceof Error ? error.message : "Authentication failed";
   140→    logger.error("MSAL device code completion failed", {
   141→      sessionId,
   142→      error: errorMessage,
   143→    });
   144→    return NextResponse.json({ status: "error", error: errorMessage });
   145→  }
   146→}
   147→
   148→async function completeDeviceCodeAuthentication({
   149→  pollResult,
   150→  request,
   151→}: {
   152→  pollResult: PollCompleteResult;
   153→  request: NextRequest;
   154→}): Promise<CompletionResult> {
   155→  const { accessToken, expiresAt, scopes, account } = pollResult;
   156→
   157→  if (!account) {
   158→    throw new Error("No account info in token response");
   159→  }
   160→
   161→  // Get user profile from Microsoft Graph
   162→  const client = createOutlookClient(accessToken, logger);
   163→  const profile = await client.getUserProfile();
   164→
   165→  const email =
   166→    profile.mail?.toLowerCase() || profile.userPrincipalName?.toLowerCase();
   167→  const name = profile.displayName;
   168→  const providerAccountId = account.localAccountId;
   169→
   170→  if (!email) {
   171→    throw new Error("Could not determine user email");
   172→  }
   173→
   174→  // Encrypt tokens
   175→  const encryptedAccessToken = encryptToken(accessToken);
   176→
   177→  // Find or create user
   178→  let user = await prisma.user.findUnique({
   179→    where: { email },
   180→  });
   181→
   182→  if (!user) {
   183→    user = await prisma.user.create({
   184→      data: {
   185→        email,
   186→        name: name || email,
   187→        emailVerified: true,
   188→      },
   189→    });
   190→    logger.info("Created new user via MSAL device code", { email });
   191→  }
   192→
   193→  // Create or update account
   194→  // Note: MSAL device code flow doesn't provide refresh_token directly
   195→  // The token cache handles refresh internally, but for our purposes
   196→  // we need to use the existing OAuth refresh mechanism
   197→  const accountRecord = await prisma.account.upsert({
   198→    where: {
   199→      provider_providerAccountId: {
   200→        provider: "microsoft",
   201→        providerAccountId,
   202→      },
   203→    },
   204→    create: {
   205→      userId: user.id,
   206→      provider: "microsoft",
   207→      providerAccountId,
   208→      access_token: encryptedAccessToken,
   209→      refresh_token: null, // MSAL doesn't expose refresh token
   210→      expires_at: expiresAt,
   211→      token_type: "Bearer",
   212→      scope: scopes.join(" "),
   213→    },
   214→    update: {
   215→      access_token: encryptedAccessToken,
   216→      expires_at: expiresAt,
   217→      scope: scopes.join(" "),
   218→    },
   219→  });
   220→
   221→  logger.info("MSAL device code authentication complete", {
   222→    email,
   223→    providerAccountId,
   224→  });
   225→
   226→  await prisma.$transaction([
   227→    prisma.emailAccount.upsert({
   228→      where: { email },
   229→      update: {
   230→        userId: user.id,
   231→        accountId: accountRecord.id,
   232→        name: name || email,
   233→      },
   234→      create: {
   235→        email,
   236→        userId: user.id,
   237→        accountId: accountRecord.id,
   238→        name: name || email,
   239→      },
   240→    }),
   241→    prisma.account.update({
   242→      where: { id: accountRecord.id },
   243→      data: { disconnectedAt: null },
   244→    }),
   245→  ]);
   246→
   247→  // Create a Better Auth session for the user
   248→  const sessionToken = crypto.randomUUID();
   249→  const sessionExpires = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000); // 30 days
   250→
   251→  await prisma.session.create({
   252→    data: {
   253→      sessionToken,
   254→      userId: user.id,
   255→      expires: sessionExpires,
   256→      ipAddress: request.headers.get("x-forwarded-for") || "unknown",
   257→      userAgent: request.headers.get("user-agent") || "unknown",
   258→    },
   259→  });
   260→
   261→  logger.info("Created session for MSAL device code user", {
   262→    email,
   263→    userId: user.id,
   264→  });
   265→
   266→  const signedSessionToken = await signSessionToken(sessionToken);
   267→
   268→  return {
   269→    email,
   270→    redirectUrl: WELCOME_PATH,
   271→    message: "Authentication successful! Redirecting...",
   272→    signedSessionToken,
   273→    sessionExpires,
   274→  };
   275→}
   276→
   277→function buildCompletionResponse({
   278→  email,
   279→  redirectUrl,
   280→  message,
   281→  signedSessionToken,
   282→  sessionExpires,
   283→}: CompletionResult): NextResponse {
   284→  const isProduction = env.NODE_ENV === "production";
   285→  const cookieName = getSessionCookieName(isProduction);
   286→  const response = NextResponse.json({
   287→    status: "complete",
   288→    email,
   289→    redirectUrl,
   290→    message,
   291→  });
   292→
   293→  response.cookies.set(cookieName, signedSessionToken, {
   294→    httpOnly: true,
   295→    secure: isProduction,
   296→    sameSite: "lax",
   297→    path: "/",
   298→    expires: sessionExpires,
   299→  });
   300→
   301→  logger.info("Set session cookie", {
   302→    cookieName,
   303→    email,
   304→  });
   305→
   306→  return response;
   307→}
   308→
   309→async function signSessionToken(sessionToken: string): Promise<string> {
   310→  const secret = env.AUTH_SECRET || env.NEXTAUTH_SECRET;
   311→  if (!secret) {
   312→    throw new Error("Missing auth secret for session cookie signing");
   313→  }
   314→  const signed = await serializeSignedCookie("", sessionToken, secret);
   315→  return normalizeSignedCookie(signed);
   316→}
   317→
   318→function normalizeSignedCookie(signed: string): string {
   319→  const decodedOnce = decodeURIComponent(signed);
   320→  const decodedTwice = decodedOnce.includes("%")
   321→    ? decodeURIComponent(decodedOnce)
   322→    : decodedOnce;
   323→  return decodedTwice.replace(/^=/, "");
   324→}
   325→
   326→function getSessionCookieName(isProduction: boolean): string {
   327→  return isProduction
   328→    ? "__Secure-better-auth.session_token"
   329→    : "better-auth.session_token";
   330→}
   331→
   332→function cleanupCompletionCache(): void {
   333→  const now = Date.now();
   334→  for (const [sessionId, entry] of completionCache.entries()) {
   335→    if (entry.expiresAt.getTime() <= now) {
   336→      completionCache.delete(sessionId);
   337→    }
   338→  }
   339→}
   340→
   341→function getCompletionCache(): Map<string, CompletionEntry> {
   342→  const globalForCompletion = globalThis as unknown as {
   343→    msalCompletionCache: Map<string, CompletionEntry> | undefined;
   344→  };
   345→
   346→  const cache = globalForCompletion.msalCompletionCache ?? new Map();
   347→  if (process.env.NODE_ENV !== "production") {
   348→    globalForCompletion.msalCompletionCache = cache;
   349→  }
   350→
   351→  return cache;
   352→}
   353→
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-24T04:06:46.812Z)**_

Now let me explore the Prisma schema to understand the database structure and look at related encryption utilities.

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-24T04:06:47.231Z)**_

<tool-use data-tool-type="search" data-tool-name="Glob"><details>
<summary>Tool use: **Glob**</summary>
 pattern `**/prisma/schema.prisma`
```
/Users/hack/github/inbox-zero/apps/web/prisma/schema.prisma
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-24T04:06:47.563Z)**_

<tool-use data-tool-type="search" data-tool-name="Glob"><details>
<summary>Tool use: **Glob**</summary>
 pattern `**/encryption.ts`
```
/Users/hack/github/inbox-zero/apps/web/utils/encryption.ts
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-24T04:06:48.426Z)**_

<tool-use data-tool-type="search" data-tool-name="Grep"><details>
<summary>Tool use: **Grep**</summary>
 path `./` pattern `ICachePlugin`
```
Found 4 files
.specstory/history/2026-01-24_03-52-27Z-please-audit-the-msal.md
.specstory/history/2026-01-24_00-33-19Z-command-name-clear-command.md
whats-next.md
.specstory/history/2026-01-22_04-47-20Z-command-name-add-dir.md
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-24T04:07:01.428Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./apps/web/utils/encryption.ts`
```
     1→import {
     2→  createCipheriv,
     3→  createDecipheriv,
     4→  randomBytes,
     5→  scryptSync,
     6→} from "node:crypto";
     7→import { env } from "@/env";
     8→import { createScopedLogger } from "@/utils/logger";
     9→
    10→const logger = createScopedLogger("encryption");
    11→
    12→// Cryptographic constants
    13→const ALGORITHM = "aes-256-gcm";
    14→const IV_LENGTH = 16; // 16 bytes for AES GCM
    15→const AUTH_TAG_LENGTH = 16; // 16 bytes for authentication tag
    16→const KEY_LENGTH = 32; // 32 bytes for AES-256
    17→
    18→// Derive encryption key from environment variables
    19→const key = scryptSync(
    20→  env.EMAIL_ENCRYPT_SECRET,
    21→  env.EMAIL_ENCRYPT_SALT,
    22→  KEY_LENGTH,
    23→);
    24→
    25→/**
    26→ * Encrypts a string using AES-256-GCM
    27→ * Returns a hex string containing: IV + Auth Tag + Encrypted content
    28→ */
    29→export function encryptToken(text: string | null): string | null {
    30→  if (text === null || text === undefined) return null;
    31→
    32→  try {
    33→    // Generate a random IV for each encryption
    34→    const iv = randomBytes(IV_LENGTH);
    35→
    36→    const cipher = createCipheriv(ALGORITHM, key, iv);
    37→    const encrypted = Buffer.concat([
    38→      cipher.update(text, "utf8"),
    39→      cipher.final(),
    40→    ]);
    41→
    42→    // Get authentication tag
    43→    const authTag = cipher.getAuthTag();
    44→
    45→    // Return IV + Auth Tag + Encrypted content as hex
    46→    return Buffer.concat([iv, authTag, encrypted]).toString("hex");
    47→  } catch (error) {
    48→    logger.error("Encryption failed", { error });
    49→    return null;
    50→  }
    51→}
    52→
    53→/**
    54→ * Decrypts a string that was encrypted with encryptToken
    55→ * Expects a hex string containing: IV + Auth Tag + Encrypted content
    56→ */
    57→export function decryptToken(encryptedText: string | null): string | null {
    58→  if (encryptedText === null || encryptedText === undefined) return null;
    59→
    60→  try {
    61→    const buffer = Buffer.from(encryptedText, "hex");
    62→
    63→    // Extract IV (first 16 bytes)
    64→    const iv = buffer.subarray(0, IV_LENGTH);
    65→
    66→    // Extract auth tag (next 16 bytes)
    67→    const authTag = buffer.subarray(IV_LENGTH, IV_LENGTH + AUTH_TAG_LENGTH);
    68→
    69→    // Extract encrypted content (remaining bytes)
    70→    const encrypted = buffer.subarray(IV_LENGTH + AUTH_TAG_LENGTH);
    71→
    72→    const decipher = createDecipheriv(ALGORITHM, key, iv);
    73→    decipher.setAuthTag(authTag);
    74→
    75→    const decrypted = Buffer.concat([
    76→      decipher.update(encrypted),
    77→      decipher.final(),
    78→    ]);
    79→
    80→    return decrypted.toString("utf8");
    81→  } catch (error) {
    82→    logger.error("Decryption failed", { error });
    83→    return null;
    84→  }
    85→}
    86→
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-24T04:07:01.827Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./apps/web/prisma/schema.prisma`
```
     1→datasource db {
     2→  provider  = "postgresql"
     3→  url       = env("DATABASE_URL")
     4→  directUrl = env("DIRECT_URL")
     5→}
     6→
     7→generator client {
     8→  provider               = "prisma-client"
     9→  output                 = "../generated/prisma"
    10→  engineType             = "client"
    11→  generatedFileExtension = "ts"
    12→  importFileExtension    = "ts"
    13→}
    14→
    15→// Account, User, Session, and VerificationToken based on: https://authjs.dev/reference/adapter/prisma
    16→model Account {
    17→  id                    String        @id @default(cuid())
    18→  createdAt             DateTime      @default(now())
    19→  updatedAt             DateTime      @updatedAt
    20→  userId                String
    21→  provider              String
    22→  type                  String        @default("oidc") // next-auth deprecated field
    23→  providerAccountId     String
    24→  refresh_token         String?       @db.Text
    25→  refreshTokenExpiresAt DateTime?
    26→  access_token          String?       @db.Text
    27→  expires_at            DateTime?     @default(now())
    28→  disconnectedAt        DateTime? // When OAuth tokens were invalidated (password change, revoked access)
    29→  token_type            String?
    30→  scope                 String?
    31→  id_token              String?       @db.Text
    32→  session_state         String?
    33→  user                  User          @relation(fields: [userId], references: [id], onDelete: Cascade)
    34→  emailAccount          EmailAccount?
    35→
    36→  @@unique([provider, providerAccountId])
    37→  @@index([userId])
    38→}
    39→
    40→// not in use. we only use jwt for sessions
    41→model Session {
    42→  id           String   @id @default(cuid())
    43→  sessionToken String   @unique
    44→  userId       String
    45→  expires      DateTime
    46→  createdAt    DateTime @default(now())
    47→  updatedAt    DateTime @updatedAt
    48→  ipAddress    String?
    49→  userAgent    String?
    50→  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
    51→
    52→  activeOrganizationId String?
    53→  activeOrganization   Organization? @relation(fields: [activeOrganizationId], references: [id], onDelete: SetNull)
    54→
    55→  @@index([userId])
    56→  @@index([activeOrganizationId])
    57→}
    58→
    59→model User {
    60→  id            String    @id @default(cuid())
    61→  createdAt     DateTime  @default(now())
    62→  updatedAt     DateTime  @updatedAt
    63→  name          String?
    64→  email         String    @unique
    65→  emailVerified Boolean?  @default(false)
    66→  image         String?
    67→  accounts      Account[]
    68→  sessions      Session[]
    69→
    70→  // additional fields
    71→  completedOnboardingAt    DateTime? // questions about the user. e.g. their role
    72→  completedAppOnboardingAt DateTime? // how to use the app
    73→  onboardingAnswers        Json?
    74→  lastLogin                DateTime?
    75→  utms                     Json?
    76→  errorMessages            Json? // eg. user set incorrect AI API key
    77→
    78→  // survey answers (extracted from onboardingAnswers for easier querying)
    79→  surveyFeatures     String[] // multiple choice: features user is interested in
    80→  surveyRole         String? // single choice: user's role. Now using `EmailAccount.role` instead
    81→  surveyGoal         String? // single choice: what user wants to achieve
    82→  surveyCompanySize  Int? // numeric company size: 1 (solo), 5 (2-10), 50 (11-100), 500 (101-1000), 1000 (1000+)
    83→  surveySource       String? // single choice: how user heard about Inbox Zero
    84→  surveyImprovements String? // open text: what user wants to improve
    85→
    86→  // settings
    87→  aiProvider    String?
    88→  aiModel       String?
    89→  aiApiKey      String?
    90→  webhookSecret String?
    91→
    92→  // referral system
    93→  referralCode String? @unique // User's own referral code
    94→
    95→  // premium can be shared among multiple users
    96→  premiumId      String?
    97→  premium        Premium? @relation(name: "userPremium", fields: [premiumId], references: [id])
    98→  // only admin users can manage premium
    99→  premiumAdminId String?
   100→  premiumAdmin   Premium? @relation(fields: [premiumAdminId], references: [id])
   101→
   102→  apiKeys ApiKey[]
   103→
   104→  emailAccounts EmailAccount[]
   105→
   106→  // Referral relationships
   107→  referralsMade    Referral[] @relation("ReferrerUser")
   108→  referralReceived Referral?  @relation("ReferredUser")
   109→}
   110→
   111→// Migrating over to the new settings model. Currently most settings are in the User model, but will be moved to this model in the future.
   112→model EmailAccount {
   113→  id        String   @id @default(cuid())
   114→  email     String   @unique
   115→  createdAt DateTime @default(now())
   116→  updatedAt DateTime @updatedAt
   117→
   118→  name  String? // Name associated with the Google account
   119→  image String? // Profile image URL from the Google account
   120→
   121→  about                          String?
   122→  writingStyle                   String?
   123→  signature                      String? // User's email signature from provider or manually set
   124→  includeReferralSignature       Boolean   @default(false)
   125→  watchEmailsExpirationDate      DateTime?
   126→  watchEmailsSubscriptionId      String? // For Outlook subscription ID
   127→  watchEmailsSubscriptionHistory Json? // Historical Outlook subscription IDs: [{ subscriptionId, createdAt, replacedAt }]
   128→  lastSyncedHistoryId            String?
   129→  behaviorProfile                Json?
   130→  personaAnalysis                Json? // ai analysis of the user's persona
   131→  role                           String? // the role confirmed by the user - previously `User.surveyRole`
   132→  timezone                       String? // User's timezone (IANA tz database format, e.g., "America/Los_Angeles", "Asia/Jerusalem") - handles DST automatically
   133→  calendarBookingLink            String? // User's calendar booking link
   134→
   135→  statsEmailFrequency       Frequency         @default(WEEKLY)
   136→  summaryEmailFrequency     Frequency         @default(WEEKLY)
   137→  lastSummaryEmailAt        DateTime?
   138→  coldEmailBlocker          ColdEmailSetting? // @deprecated
   139→  coldEmailDigest           Boolean           @default(false) // @deprecated
   140→  coldEmailPrompt           String? // @deprecated
   141→  rulesPrompt               String? // @deprecated
   142→  autoCategorizeSenders     Boolean           @default(false)
   143→  multiRuleSelectionEnabled Boolean           @default(false)
   144→
   145→  meetingBriefingsEnabled       Boolean @default(false)
   146→  meetingBriefingsMinutesBefore Int     @default(240) // 4 hours in minutes
   147→
   148→  digestSchedule Schedule?
   149→
   150→  userId    String
   151→  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
   152→  accountId String  @unique
   153→  account   Account @relation(fields: [accountId], references: [id], onDelete: Cascade)
   154→
   155→  labels           Label[]
   156→  rules            Rule[]
   157→  executedRules    ExecutedRule[]
   158→  newsletters      Newsletter[]
   159→  coldEmails       ColdEmail[]
   160→  groups           Group[]
   161→  categories       Category[]
   162→  threadTrackers   ThreadTracker[]
   163→  cleanupJobs      CleanupJob[]
   164→  cleanupThreads   CleanupThread[]
   165→  emailMessages    EmailMessage[]
   166→  emailTokens      EmailToken[]
   167→  knowledge        Knowledge[]
   168→  chats            Chat[]
   169→  digests          Digest[]
   170→  scheduledActions ScheduledAction[]
   171→  responseTimes    ResponseTime[]
   172→
   173→  members             Member[]
   174→  invitations         Invitation[]
   175→  ssoproviders        SsoProvider[]
   176→  calendarConnections CalendarConnection[]
   177→  mcpConnections      McpConnection[]
   178→  meetingBriefings    MeetingBriefing[]
   179→
   180→  @@index([userId])
   181→  @@index([lastSummaryEmailAt])
   182→}
   183→
   184→model Organization {
   185→  id          String        @id @default(cuid())
   186→  name        String
   187→  slug        String        @unique
   188→  logo        String?
   189→  metadata    Json?
   190→  createdAt   DateTime      @default(now())
   191→  updatedAt   DateTime      @updatedAt
   192→  members     Member[]
   193→  SsoProvider SsoProvider[]
   194→  sessions    Session[]
   195→  invitations Invitation[]
   196→}
   197→
   198→model Member {
   199→  id             String       @id @default(cuid())
   200→  organizationId String
   201→  emailAccountId String
   202→  role           String       @default("member") // "admin" | "member"
   203→  createdAt      DateTime     @default(now())
   204→  updatedAt      DateTime     @updatedAt
   205→  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
   206→  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   207→
   208→  @@unique([organizationId, emailAccountId])
   209→  @@index([emailAccountId])
   210→}
   211→
   212→model Invitation {
   213→  id             String       @id @default(cuid())
   214→  organizationId String
   215→  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
   216→  email          String
   217→  role           String?
   218→  status         String
   219→  expiresAt      DateTime
   220→  inviterId      String
   221→  inviter        EmailAccount @relation(fields: [inviterId], references: [id], onDelete: Cascade)
   222→
   223→  @@index([organizationId])
   224→  @@index([inviterId])
   225→  @@map("invitation")
   226→}
   227→
   228→model Verification {
   229→  id         String   @id @default(cuid())
   230→  identifier String
   231→  value      String
   232→  expiresAt  DateTime
   233→  createdAt  DateTime @default(now())
   234→  updatedAt  DateTime @default(now()) @updatedAt
   235→
   236→  @@map("verification")
   237→}
   238→
   239→model SsoProvider {
   240→  id             String        @id @default(cuid())
   241→  issuer         String
   242→  oidcConfig     String?
   243→  samlConfig     String?
   244→  emailAccountId String?
   245→  emailAccount   EmailAccount? @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   246→  providerId     String        @unique
   247→  organizationId String?
   248→  organization   Organization? @relation(fields: [organizationId], references: [id], onDelete: Cascade)
   249→  domain         String
   250→
   251→  @@index([emailAccountId])
   252→  @@index([organizationId])
   253→  @@map("ssoProvider")
   254→}
   255→
   256→model Digest {
   257→  id             String       @id @default(cuid())
   258→  createdAt      DateTime     @default(now())
   259→  updatedAt      DateTime     @updatedAt
   260→  emailAccountId String
   261→  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   262→  items          DigestItem[]
   263→  sentAt         DateTime?
   264→  status         DigestStatus @default(PENDING)
   265→
   266→  @@index([emailAccountId])
   267→}
   268→
   269→model DigestItem {
   270→  id          String          @id @default(cuid())
   271→  createdAt   DateTime        @default(now())
   272→  updatedAt   DateTime        @updatedAt
   273→  messageId   String
   274→  threadId    String
   275→  content     String          @db.Text
   276→  digestId    String
   277→  digest      Digest          @relation(fields: [digestId], references: [id], onDelete: Cascade)
   278→  actionId    String?
   279→  action      ExecutedAction? @relation(fields: [actionId], references: [id], onDelete: Cascade)
   280→  coldEmailId String?
   281→  coldEmail   ColdEmail?      @relation(fields: [coldEmailId], references: [id])
   282→
   283→  @@unique([digestId, threadId, messageId])
   284→  @@index([actionId])
   285→  @@index([coldEmailId])
   286→}
   287→
   288→model Schedule {
   289→  id        String   @id @default(cuid())
   290→  createdAt DateTime @default(now())
   291→  updatedAt DateTime @updatedAt
   292→
   293→  intervalDays Int? // Total interval in days
   294→  occurrences  Int? // Number of times within the interval
   295→
   296→  // Bit mask for days of week (0b0000000 to 0b1111111)
   297→  // Each bit represents a day (Sunday to Saturday)
   298→  // e.g., 0b1000001 means Sunday and Saturday
   299→  daysOfWeek Int? // 0-127 (2^7 - 1)
   300→
   301→  // Time of day stored as DateTime with canonical date (1970-01-01)
   302→  // Only the time portion is used, but DateTime preserves timezone info
   303→  // Example: "1970-01-01T09:30:00Z", "1970-01-01T14:15:00Z"
   304→  timeOfDay DateTime?
   305→
   306→  emailAccountId String
   307→  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   308→
   309→  lastOccurrenceAt DateTime?
   310→  nextOccurrenceAt DateTime?
   311→
   312→  @@unique([emailAccountId])
   313→}
   314→
   315→model Premium {
   316→  id        String   @id @default(cuid())
   317→  createdAt DateTime @default(now())
   318→  updatedAt DateTime @updatedAt
   319→
   320→  users  User[] @relation(name: "userPremium")
   321→  admins User[]
   322→
   323→  pendingInvites String[]
   324→
   325→  // lemon squeezy
   326→  lemonSqueezyRenewsAt           DateTime?
   327→  lemonSqueezyCustomerId         Int?
   328→  lemonSqueezySubscriptionId     Int?
   329→  lemonSqueezySubscriptionItemId Int?
   330→  lemonSqueezyOrderId            Int? // lifetime purchase is an order and not a subscription
   331→  lemonSqueezyProductId          Int?
   332→  lemonSqueezyVariantId          Int?
   333→  lemonLicenseKey                String?
   334→  lemonLicenseInstanceId         String?
   335→  lemonSubscriptionStatus        String?
   336→
   337→  // stripe
   338→  stripeCustomerId         String?   @unique
   339→  stripeSubscriptionId     String?   @unique
   340→  stripeSubscriptionItemId String?   @unique
   341→  stripePriceId            String?
   342→  stripeProductId          String?
   343→  stripeSubscriptionStatus String? // The current status from Stripe (e.g., 'active', 'trialing', 'past_due', 'canceled', 'unpaid').
   344→  stripeCancelAtPeriodEnd  Boolean? // If true, the subscription is set to cancel automatically at the end of the current billing period, rather than renew.
   345→  stripeRenewsAt           DateTime? // Timestamp for when the current billing period ends and the subscription attempts renewal (if not canceling). Derived from `current_period_end`.
   346→  stripeTrialEnd           DateTime? // Timestamp for when the free trial period ends (if applicable). Important for managing trial-to-paid transitions.
   347→  stripeCanceledAt         DateTime? // Timestamp for when the subscription was definitively marked as canceled in Stripe (might be immediate or after period end). Historical data.
   348→  stripeEndedAt            DateTime? // Timestamp for when the subscription ended permanently for any reason (cancellation, final payment failure). Historical data.
   349→
   350→  tier PremiumTier?
   351→
   352→  emailAccountsAccess Int?
   353→
   354→  // unsubscribe/ai credits
   355→  // if `unsubscribeMonth` not set to this month, set to current month
   356→  // reset `unsubscribeCredits` each time month is changed
   357→  unsubscribeMonth   Int? // 1-12
   358→  unsubscribeCredits Int?
   359→  aiMonth            Int? // 1-12
   360→  aiCredits          Int?
   361→
   362→  // Payment history
   363→  payments Payment[]
   364→
   365→  @@index([pendingInvites])
   366→}
   367→
   368→// not in use as it's only used for passwordless login
   369→model VerificationToken {
   370→  id         String   @id @default(cuid())
   371→  createdAt  DateTime @default(now())
   372→  updatedAt  DateTime @updatedAt
   373→  identifier String
   374→  token      String   @unique
   375→  expires    DateTime
   376→
   377→  @@unique([identifier, token])
   378→}
   379→
   380→model Label {
   381→  id           String   @id @default(cuid())
   382→  createdAt    DateTime @default(now())
   383→  updatedAt    DateTime @updatedAt
   384→  gmailLabelId String
   385→  name         String
   386→  description  String? // used in prompts
   387→  enabled      Boolean  @default(true)
   388→
   389→  emailAccountId String
   390→  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   391→
   392→  @@unique([gmailLabelId, emailAccountId])
   393→  @@unique([name, emailAccountId])
   394→}
   395→
   396→model Rule {
   397→  id           String   @id @default(cuid())
   398→  createdAt    DateTime @default(now())
   399→  updatedAt    DateTime @updatedAt
   400→  name         String
   401→  actions      Action[]
   402→  enabled      Boolean  @default(true)
   403→  automate     Boolean  @default(true) // @deprecated - No longer used. All rules are now automated. Kept for historical data only.
   404→  runOnThreads Boolean  @default(false) // if disabled, only runs on individual emails
   405→
   406→  emailAccountId String
   407→  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   408→
   409→  executedRules ExecutedRule[]
   410→
   411→  // conditions: ai, group, static, category
   412→  conditionalOperator LogicalOperator @default(AND)
   413→
   414→  // ai conditions
   415→  instructions String?
   416→
   417→  // group condition
   418→  groupId String? @unique
   419→  group   Group?  @relation(fields: [groupId], references: [id], onDelete: Cascade)
   420→
   421→  // static condition
   422→  // automatically apply this rule if it matches a filter. supports regex
   423→  from    String?
   424→  to      String?
   425→  subject String?
   426→  body    String?
   427→
   428→  // category condition
   429→  // only apply to (or do not apply to) senders in these categories
   430→  categoryFilterType CategoryFilterType? // deprecated
   431→  categoryFilters    Category[] // deprecated
   432→
   433→  systemType SystemType?
   434→
   435→  promptText String? // natural language for this rule for prompt file. prompt file is combination of these fields
   436→
   437→  history RuleHistory[]
   438→
   439→  @@unique([name, emailAccountId])
   440→  @@unique([emailAccountId, systemType])
   441→}
   442→
   443→model Action {
   444→  id        String     @id @default(cuid())
   445→  createdAt DateTime   @default(now())
   446→  updatedAt DateTime   @updatedAt
   447→  type      ActionType
   448→  ruleId    String
   449→  rule      Rule       @relation(fields: [ruleId], references: [id], onDelete: Cascade)
   450→
   451→  label          String? // labelName - labelId is the source of truth, and we use it when set
   452→  labelId        String? // Stable ID: Label ID (Gmail) or Category ID (Outlook)
   453→  subject        String?
   454→  content        String?
   455→  to             String?
   456→  cc             String?
   457→  bcc            String?
   458→  url            String?
   459→  folderName     String?
   460→  folderId       String?
   461→  delayInMinutes Int?
   462→
   463→  @@index([ruleId])
   464→}
   465→
   466→model RuleHistory {
   467→  id          String   @id @default(cuid())
   468→  createdAt   DateTime @default(now())
   469→  ruleId      String
   470→  rule        Rule     @relation(fields: [ruleId], references: [id], onDelete: Cascade)
   471→  version     Int
   472→  triggerType String // "ai_update" (AI), "manual_update" (user), "ai_creation" (AI), "manual_creation" (user), "system_creation" (system), "system_update" (system)
   473→  promptText  String? // The prompt text that generated this version
   474→
   475→  name                String
   476→  instructions        String?
   477→  enabled             Boolean
   478→  automate            Boolean
   479→  runOnThreads        Boolean
   480→  conditionalOperator String
   481→  from                String?
   482→  to                  String?
   483→  subject             String?
   484→  body                String?
   485→  categoryFilterType  String? // deprecated
   486→  systemType          String?
   487→
   488→  actions         Json
   489→  categoryFilters Json? // deprecated
   490→
   491→  @@unique([ruleId, version])
   492→  @@index([ruleId, createdAt])
   493→}
   494→
   495→// Rule/Action models represent the rules and actions that the AI can take.
   496→// ExecutedRule/ExecutedAction models represent the rules/actions that have been planned or executed by the AI.
   497→model ExecutedRule {
   498→  id            String             @id @default(cuid())
   499→  createdAt     DateTime           @default(now())
   500→  updatedAt     DateTime           @updatedAt
   501→  threadId      String
   502→  messageId     String
   503→  status        ExecutedRuleStatus
   504→  automated     Boolean
   505→  reason        String?
   506→  matchMetadata Json? // Stores structured match information (e.g., learned patterns, match types)
   507→
   508→  // may be null if the rule was deleted
   509→  ruleId String?
   510→  rule   Rule?   @relation(fields: [ruleId], references: [id])
   511→
   512→  // storing user here in case rule was deleted
   513→  emailAccountId String
   514→  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   515→
   516→  actionItems      ExecutedAction[]
   517→  scheduledActions ScheduledAction[]
   518→
   519→  @@index([emailAccountId, threadId, messageId, ruleId])
   520→  @@index([emailAccountId, messageId])
   521→  @@index([emailAccountId, status, createdAt])
   522→}
   523→
   524→model ExecutedAction {
   525→  id             String       @id @default(cuid())
   526→  createdAt      DateTime     @default(now())
   527→  updatedAt      DateTime     @updatedAt
   528→  type           ActionType
   529→  executedRuleId String
   530→  executedRule   ExecutedRule @relation(fields: [executedRuleId], references: [id], onDelete: Cascade)
   531→
   532→  // optional extra fields to be used with the action
   533→  label      String?
   534→  labelId    String? // Stable ID: Label ID (Gmail) or Category ID (Outlook)
   535→  subject    String?
   536→  content    String?
   537→  to         String?
   538→  cc         String?
   539→  bcc        String?
   540→  url        String?
   541→  folderName String?
   542→  folderId   String?
   543→
   544→  // additional fields as a result of the action
   545→  draftId         String? // Gmail draft ID created by DRAFT_EMAIL action
   546→  wasDraftSent    Boolean? // Tracks if the corresponding draft was sent (true) or ignored/superseded (false)
   547→  draftSendLog    DraftSendLog? // Will exist if the draft was sent
   548→  digestItems     DigestItem[] // Relation to digest items created by this action
   549→  scheduledAction ScheduledAction? // Reverse relation for delayed actions
   550→
   551→  @@index([executedRuleId])
   552→}
   553→
   554→model ScheduledAction {
   555→  id               String                @id @default(cuid())
   556→  createdAt        DateTime              @default(now())
   557→  updatedAt        DateTime              @updatedAt
   558→  executedRuleId   String
   559→  actionType       ActionType
   560→  messageId        String
   561→  threadId         String
   562→  scheduledFor     DateTime
   563→  emailAccountId   String
   564→  status           ScheduledActionStatus @default(PENDING)
   565→  schedulingStatus SchedulingStatus      @default(PENDING)
   566→
   567→  label       String?
   568→  labelId     String? // Stable ID: Label ID (Gmail) or Category ID (Outlook)
   569→  subject     String?
   570→  content     String?
   571→  to          String?
   572→  cc          String?
   573→  bcc         String?
   574→  url         String?
   575→  folderName  String?
   576→  folderId    String?
   577→  scheduledId String?
   578→
   579→  executedAt       DateTime?
   580→  executedActionId String?   @unique
   581→
   582→  executedRule   ExecutedRule    @relation(fields: [executedRuleId], references: [id], onDelete: Cascade)
   583→  executedAction ExecutedAction? @relation(fields: [executedActionId], references: [id], onDelete: Cascade)
   584→  emailAccount   EmailAccount    @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   585→
   586→  @@index([executedRuleId])
   587→  @@index([status, scheduledFor])
   588→  @@index([emailAccountId, messageId])
   589→}
   590→
   591→// Notes:
   592→// In the past groups stood on their own. Now they are attached to a rule.
   593→// A group without a rule does not do anything anymore. I may delete all detached groups in the future, and then make rule required
   594→// "Prompt" is no longer in use. It was used to generate the group, but now it's based on the rule the group is attached to.
   595→// "Name" is no longer in use although still required.
   596→// If we really wanted we could remove Group and just have a relation between Rule and GroupItem, but leaving as is for now.
   597→model Group {
   598→  id        String   @id @default(cuid())
   599→  createdAt DateTime @default(now())
   600→  updatedAt DateTime @updatedAt
   601→  name      String
   602→  prompt    String?
   603→
   604→  items GroupItem[]
   605→  rule  Rule?
   606→
   607→  emailAccountId String
   608→  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   609→
   610→  @@unique([name, emailAccountId])
   611→}
   612→
   613→model GroupItem {
   614→  id        String        @id @default(cuid())
   615→  createdAt DateTime      @default(now())
   616→  updatedAt DateTime      @updatedAt
   617→  groupId   String?
   618→  group     Group?        @relation(fields: [groupId], references: [id], onDelete: Cascade)
   619→  type      GroupItemType
   620→  value     String // eg "@gmail.com", "matt@gmail.com", "Receipt from"
   621→  exclude   Boolean       @default(false) // Whether this pattern should be excluded rather than included
   622→
   623→  @@unique([groupId, type, value])
   624→}
   625→
   626→model Category {
   627→  id          String   @id @default(cuid())
   628→  createdAt   DateTime @default(now())
   629→  updatedAt   DateTime @updatedAt
   630→  name        String
   631→  description String?
   632→
   633→  emailAccountId String
   634→  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   635→
   636→  emailSenders Newsletter[]
   637→  rules        Rule[]
   638→
   639→  @@unique([name, emailAccountId])
   640→}
   641→
   642→// Represents a sender (`email`) that a user can unsubscribe from,
   643→// or that our AI can mark as a cold email.
   644→// `Newsletter` is a bad name for this. Will rename this model in the future.
   645→model Newsletter {
   646→  id        String            @id @default(cuid())
   647→  createdAt DateTime          @default(now())
   648→  updatedAt DateTime          @updatedAt
   649→  email     String
   650→  status    NewsletterStatus?
   651→
   652→  // For learned patterns for rules
   653→  patternAnalyzed Boolean   @default(false)
   654→  lastAnalyzedAt  DateTime?
   655→
   656→  emailAccountId String
   657→  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   658→
   659→  categoryId String?
   660→  category   Category? @relation(fields: [categoryId], references: [id])
   661→
   662→  @@unique([email, emailAccountId])
   663→  @@index([emailAccountId, status])
   664→  @@index([categoryId])
   665→}
   666→
   667→model ColdEmail {
   668→  id        String           @id @default(cuid())
   669→  createdAt DateTime         @default(now())
   670→  updatedAt DateTime         @updatedAt
   671→  fromEmail String
   672→  messageId String?
   673→  threadId  String?
   674→  status    ColdEmailStatus?
   675→  reason    String?
   676→
   677→  emailAccountId String
   678→  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   679→
   680→  digestItems DigestItem[]
   681→
   682→  @@unique([emailAccountId, fromEmail])
   683→  @@index([emailAccountId, status])
   684→  @@index([emailAccountId, createdAt])
   685→}
   686→
   687→model EmailMessage {
   688→  id              String   @id @default(cuid())
   689→  createdAt       DateTime @default(now())
   690→  updatedAt       DateTime @updatedAt
   691→  threadId        String
   692→  messageId       String
   693→  date            DateTime // date of the email
   694→  from            String
   695→  fromName        String? // sender's display name
   696→  fromDomain      String
   697→  to              String
   698→  unsubscribeLink String?
   699→  read            Boolean
   700→  sent            Boolean
   701→  draft           Boolean
   702→  inbox           Boolean
   703→
   704→  emailAccountId String
   705→  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   706→
   707→  @@unique([emailAccountId, threadId, messageId])
   708→  @@index([emailAccountId, threadId])
   709→  @@index([emailAccountId, date])
   710→  @@index([emailAccountId, from])
   711→  @@index([emailAccountId, fromName])
   712→}
   713→
   714→model ResponseTime {
   715→  id                String   @id @default(cuid())
   716→  createdAt         DateTime @default(now())
   717→  threadId          String
   718→  sentMessageId     String
   719→  receivedMessageId String
   720→  responseTimeMins  Int // Denormalized: (sentAt - receivedAt) in minutes
   721→  receivedAt        DateTime
   722→  sentAt            DateTime
   723→
   724→  emailAccountId String
   725→  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   726→
   727→  @@unique([emailAccountId, sentMessageId])
   728→  @@index([emailAccountId, sentAt])
   729→}
   730→
   731→model ThreadTracker {
   732→  id        String            @id @default(cuid())
   733→  createdAt DateTime          @default(now())
   734→  updatedAt DateTime          @updatedAt
   735→  sentAt    DateTime
   736→  threadId  String
   737→  messageId String
   738→  resolved  Boolean           @default(false)
   739→  type      ThreadTrackerType
   740→
   741→  emailAccountId String
   742→  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   743→
   744→  @@unique([emailAccountId, threadId, messageId])
   745→  @@index([emailAccountId, resolved])
   746→  @@index([emailAccountId, resolved, sentAt, type])
   747→  @@index([emailAccountId, type, resolved, sentAt])
   748→}
   749→
   750→model CleanupJob {
   751→  id               String      @id @default(cuid())
   752→  createdAt        DateTime    @default(now())
   753→  updatedAt        DateTime    @updatedAt
   754→  action           CleanAction @default(ARCHIVE)
   755→  daysOld          Int         @default(7)
   756→  instructions     String?
   757→  skipReply        Boolean?
   758→  skipStarred      Boolean?
   759→  skipCalendar     Boolean?
   760→  skipReceipt      Boolean?
   761→  skipAttachment   Boolean?
   762→  skipConversation Boolean?
   763→
   764→  emailAccountId String
   765→  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   766→
   767→  threads CleanupThread[]
   768→
   769→  @@index([emailAccountId])
   770→}
   771→
   772→model CleanupThread {
   773→  id        String     @id @default(cuid())
   774→  createdAt DateTime   @default(now())
   775→  updatedAt DateTime   @updatedAt
   776→  threadId  String
   777→  archived  Boolean // this can also mean "mark as read". depends on CleanupJob.action
   778→  jobId     String
   779→  job       CleanupJob @relation(fields: [jobId], references: [id], onDelete: Cascade)
   780→
   781→  emailAccountId String
   782→  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   783→
   784→  @@index([jobId])
   785→}
   786→
   787→model Knowledge {
   788→  id        String   @id @default(cuid())
   789→  createdAt DateTime @default(now())
   790→  updatedAt DateTime @updatedAt
   791→  title     String
   792→  content   String
   793→
   794→  emailAccountId String
   795→  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   796→
   797→  @@unique([emailAccountId, title])
   798→}
   799→
   800→model ApiKey {
   801→  id        String   @id @default(cuid())
   802→  createdAt DateTime @default(now())
   803→  updatedAt DateTime @updatedAt
   804→  name      String?
   805→  hashedKey String   @unique
   806→  isActive  Boolean  @default(true)
   807→
   808→  userId String
   809→  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
   810→
   811→  @@index([userId, isActive])
   812→}
   813→
   814→model EmailToken {
   815→  id        String   @id @default(cuid())
   816→  createdAt DateTime @default(now())
   817→  token     String   @unique
   818→  expiresAt DateTime
   819→  // action    EmailTokenAction @default(UNSUBSCRIBE)
   820→
   821→  emailAccountId String
   822→  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   823→
   824→  @@index([emailAccountId])
   825→}
   826→
   827→model Payment {
   828→  id        String   @id @default(cuid())
   829→  createdAt DateTime // from processor
   830→  updatedAt DateTime // from processor
   831→
   832→  // Relation to Premium
   833→  premiumId String?
   834→  premium   Premium? @relation(fields: [premiumId], references: [id], onDelete: SetNull)
   835→
   836→  // Payment processor information
   837→  processorType           ProcessorType @default(LEMON_SQUEEZY)
   838→  processorId             String?       @unique // External payment ID from Stripe/Lemon Squeezy
   839→  processorSubscriptionId String? // External subscription ID
   840→  processorCustomerId     String? // External customer ID
   841→
   842→  // Core payment information
   843→  amount       Int // Total amount in cents
   844→  currency     String // 3-letter currency code: USD, EUR, etc.
   845→  status       String // paid, failed, refunded, etc.
   846→  tax          Int
   847→  taxInclusive Boolean
   848→
   849→  // Refund information
   850→  refunded       Boolean   @default(false)
   851→  refundedAt     DateTime?
   852→  refundedAmount Int? // in cents
   853→
   854→  // Metadata
   855→  billingReason String? // initial, renewal, update, etc.
   856→
   857→  @@index([premiumId])
   858→}
   859→
   860→model DraftSendLog {
   861→  id        String   @id @default(cuid())
   862→  createdAt DateTime @default(now())
   863→
   864→  executedActionId String         @unique
   865→  executedAction   ExecutedAction @relation(fields: [executedActionId], references: [id], onDelete: Cascade)
   866→
   867→  sentMessageId   String
   868→  similarityScore Float // Similarity score (0.0 to 1.0) between original draft and sent message
   869→
   870→  @@index([executedActionId])
   871→}
   872→
   873→model Chat {
   874→  id        String   @id @default(cuid())
   875→  createdAt DateTime @default(now())
   876→  updatedAt DateTime @updatedAt
   877→
   878→  messages       ChatMessage[]
   879→  emailAccountId String
   880→  emailAccount   EmailAccount  @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   881→
   882→  @@index([emailAccountId])
   883→}
   884→
   885→model ChatMessage {
   886→  id        String   @id @default(cuid())
   887→  createdAt DateTime @default(now())
   888→  updatedAt DateTime @updatedAt
   889→
   890→  role  String
   891→  parts Json
   892→  // attachments Json?
   893→
   894→  chatId String
   895→  chat   Chat   @relation(fields: [chatId], references: [id], onDelete: Cascade)
   896→
   897→  @@index([chatId])
   898→}
   899→
   900→model CalendarConnection {
   901→  id        String   @id @default(cuid())
   902→  createdAt DateTime @default(now())
   903→  updatedAt DateTime @updatedAt
   904→
   905→  provider     String // "google" or "microsoft"
   906→  email        String // Google account email (e.g., "elie@gmail.com")
   907→  accessToken  String?
   908→  refreshToken String?
   909→  expiresAt    DateTime?
   910→  isConnected  Boolean   @default(true)
   911→
   912→  emailAccountId String
   913→  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   914→
   915→  calendars Calendar[]
   916→
   917→  @@unique([emailAccountId, provider, email]) // Allow multiple Google accounts per user
   918→}
   919→
   920→model Calendar {
   921→  id        String   @id @default(cuid())
   922→  createdAt DateTime @default(now())
   923→  updatedAt DateTime @updatedAt
   924→
   925→  calendarId  String // External calendar ID from provider
   926→  name        String
   927→  description String?
   928→  primary     Boolean @default(false)
   929→  isEnabled   Boolean @default(true)
   930→  timezone    String?
   931→
   932→  connectionId String
   933→  connection   CalendarConnection @relation(fields: [connectionId], references: [id], onDelete: Cascade)
   934→
   935→  @@unique([connectionId, calendarId])
   936→}
   937→
   938→model MeetingBriefing {
   939→  id        String   @id @default(cuid())
   940→  createdAt DateTime @default(now())
   941→
   942→  calendarEventId String // External event ID from Google/Microsoft
   943→  eventTitle      String
   944→  eventStartTime  DateTime
   945→  guestCount      Int
   946→  status          MeetingBriefingStatus
   947→
   948→  emailAccountId String
   949→  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   950→
   951→  @@unique([emailAccountId, calendarEventId]) // Prevent duplicate briefings
   952→  @@index([emailAccountId])
   953→}
   954→
   955→model Referral {
   956→  id        String   @id @default(cuid())
   957→  createdAt DateTime @default(now())
   958→  updatedAt DateTime @updatedAt
   959→
   960→  // The user who made the referral (referrer)
   961→  referrerUserId String
   962→  referrerUser   User   @relation(name: "ReferrerUser", fields: [referrerUserId], references: [id], onDelete: Cascade)
   963→
   964→  // The user who was referred
   965→  referredUserId String @unique // Each user can only be referred once
   966→  referredUser   User   @relation(name: "ReferredUser", fields: [referredUserId], references: [id], onDelete: Cascade)
   967→
   968→  // The referral code used (stored as string)
   969→  referralCodeUsed String
   970→
   971→  // Status tracking
   972→  status ReferralStatus @default(PENDING)
   973→
   974→  // Reward tracking - using Stripe balance transactions
   975→  rewardGrantedAt            DateTime?
   976→  stripeBalanceTransactionId String? // Store Stripe txn ID for reference
   977→  rewardAmount               Int? // Amount in cents (e.g., 2000 for $20)
   978→
   979→  @@index([referrerUserId])
   980→  @@index([status])
   981→}
   982→
   983→model McpIntegration {
   984→  id        String   @id @default(cuid())
   985→  createdAt DateTime @default(now())
   986→  updatedAt DateTime @updatedAt
   987→
   988→  name String @unique // Lookup key to MCP_INTEGRATIONS config
   989→
   990→  // OAuth registration metadata (captured during dynamic registration)
   991→  // These represent what the credentials below were registered for
   992→  registeredServerUrl        String? // Server URL credentials are registered with
   993→  registeredAuthorizationUrl String? // OAuth authorization endpoint used
   994→  registeredTokenUrl         String? // OAuth token endpoint used
   995→
   996→  // OAuth client credentials (from dynamic registration - shared across all users)
   997→  oauthClientId     String?
   998→  oauthClientSecret String?
   999→
  1000→  connections McpConnection[]
  1001→}
  1002→
  1003→model McpConnection {
  1004→  id        String   @id @default(cuid())
  1005→  createdAt DateTime @default(now())
  1006→  updatedAt DateTime @updatedAt
  1007→
  1008→  name     String
  1009→  isActive Boolean @default(true)
  1010→
  1011→  // Encrypted credentials
  1012→  accessToken  String?
  1013→  refreshToken String?
  1014→  apiKey       String?
  1015→  expiresAt    DateTime?
  1016→
  1017→  integrationId  String
  1018→  integration    McpIntegration @relation(fields: [integrationId], references: [id], onDelete: Cascade)
  1019→  emailAccountId String?
  1020→  emailAccount   EmailAccount?  @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
  1021→  tools          McpTool[]
  1022→
  1023→  @@unique([emailAccountId, integrationId])
  1024→}
  1025→
  1026→model McpTool {
  1027→  id        String   @id @default(cuid())
  1028→  createdAt DateTime @default(now())
  1029→  updatedAt DateTime @updatedAt
  1030→
  1031→  name        String
  1032→  description String?
  1033→  schema      Json?
  1034→  isEnabled   Boolean @default(true)
  1035→
  1036→  connectionId String
  1037→  connection   McpConnection @relation(fields: [connectionId], references: [id], onDelete: Cascade)
  1038→
  1039→  @@unique([connectionId, name])
  1040→}
  1041→
  1042→enum ActionType {
  1043→  ARCHIVE
  1044→  LABEL
  1045→  REPLY
  1046→  SEND_EMAIL
  1047→  FORWARD
  1048→  DRAFT_EMAIL
  1049→  MARK_SPAM
  1050→  CALL_WEBHOOK
  1051→  MARK_READ
  1052→  // TRACK_THREAD // @deprecated - No longer used. We rely on rule SystemType instead to run this.
  1053→  DIGEST
  1054→  MOVE_FOLDER
  1055→  NOTIFY_SENDER // Sends notification from Inbox Zero (not user's email). Only for cold email rules.
  1056→  // SUMMARIZE
  1057→  // SNOOZE
  1058→  // ADD_TO_DO
  1059→  // INTEGRATION // for example, add to Notion
  1060→}
  1061→
  1062→enum Frequency {
  1063→  NEVER
  1064→  DAILY
  1065→  WEEKLY
  1066→  // MONTHLY
  1067→  // ANNUALLY
  1068→}
  1069→
  1070→enum NewsletterStatus {
  1071→  APPROVED
  1072→  UNSUBSCRIBED
  1073→  AUTO_ARCHIVED
  1074→}
  1075→
  1076→enum ColdEmailStatus {
  1077→  AI_LABELED_COLD
  1078→  USER_REJECTED_COLD
  1079→}
  1080→
  1081→// @deprecated - No longer used
  1082→enum ColdEmailSetting {
  1083→  DISABLED
  1084→  LIST
  1085→  LABEL
  1086→  ARCHIVE_AND_LABEL
  1087→  ARCHIVE_AND_READ_AND_LABEL
  1088→}
  1089→
  1090→enum PremiumTier {
  1091→  BASIC_MONTHLY
  1092→  BASIC_ANNUALLY
  1093→  PRO_MONTHLY
  1094→  PRO_ANNUALLY
  1095→  BUSINESS_MONTHLY
  1096→  BUSINESS_ANNUALLY
  1097→  BUSINESS_PLUS_MONTHLY
  1098→  BUSINESS_PLUS_ANNUALLY
  1099→  COPILOT_MONTHLY
  1100→  LIFETIME
  1101→}
  1102→
  1103→enum ExecutedRuleStatus {
  1104→  APPLIED
  1105→  APPLYING
  1106→  REJECTED // @deprecated - No longer created. Kept for historical data only.
  1107→  PENDING // @deprecated - No longer created. Kept for historical data only.
  1108→  SKIPPED
  1109→  ERROR
  1110→}
  1111→
  1112→enum GroupItemType {
  1113→  FROM
  1114→  SUBJECT
  1115→  BODY
  1116→}
  1117→
  1118→enum CategoryFilterType {
  1119→  INCLUDE
  1120→  EXCLUDE
  1121→}
  1122→
  1123→enum LogicalOperator {
  1124→  AND
  1125→  OR
  1126→}
  1127→
  1128→enum ThreadTrackerType {
  1129→  AWAITING // We're waiting for their reply
  1130→  NEEDS_REPLY // We need to reply to this
  1131→  NEEDS_ACTION // We need to do something else
  1132→}
  1133→
  1134→enum ProcessorType {
  1135→  LEMON_SQUEEZY
  1136→  STRIPE
  1137→}
  1138→
  1139→enum CleanAction {
  1140→  ARCHIVE
  1141→  MARK_READ
  1142→}
  1143→
  1144→enum SystemType {
  1145→  // conversation trackers
  1146→  TO_REPLY
  1147→  FYI
  1148→  AWAITING_REPLY
  1149→  ACTIONED
  1150→  // cold email blocker
  1151→  COLD_EMAIL
  1152→  // other labels
  1153→  NEWSLETTER
  1154→  MARKETING
  1155→  CALENDAR
  1156→  RECEIPT
  1157→  NOTIFICATION
  1158→}
  1159→
  1160→enum ReferralStatus {
  1161→  PENDING // Referral created, waiting for trial completion
  1162→  COMPLETED // Referral completed and reward granted
  1163→}
  1164→
  1165→enum DigestStatus {
  1166→  PENDING
  1167→  PROCESSING
  1168→  SENT
  1169→  FAILED
  1170→}
  1171→
  1172→enum ScheduledActionStatus {
  1173→  PENDING
  1174→  EXECUTING
  1175→  COMPLETED
  1176→  FAILED
  1177→  CANCELLED
  1178→}
  1179→
  1180→enum SchedulingStatus {
  1181→  PENDING
  1182→  SCHEDULED
  1183→  FAILED
  1184→}
  1185→
  1186→enum MeetingBriefingStatus {
  1187→  PENDING
  1188→  SENT
  1189→  FAILED
  1190→  SKIPPED
  1191→}
  1192→
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-24T04:07:10.652Z)**_

Now let me explore how the calendar connection and device code route handle tokens to understand the existing patterns better.

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-24T04:07:12.061Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./apps/web/app/api/outlook/calendar/device-code-connect/route.ts`
```
     1→import { NextResponse } from "next/server";
     2→import prisma from "@/utils/prisma";
     3→import { withEmailAccount } from "@/utils/middleware";
     4→import {
     5→  acquireMSALTokenSilent,
     6→  isMSALDeviceCodeEnabled,
     7→} from "@/utils/outlook/msal-device-code";
     8→import {
     9→  checkExistingConnection,
    10→  createCalendarConnection,
    11→} from "@/utils/calendar/oauth-callback-helpers";
    12→import { createMicrosoftCalendarProvider } from "@/utils/calendar/providers/microsoft";
    13→
    14→export type DeviceCodeCalendarConnectResponse =
    15→  | { success: true; connectionId: string }
    16→  | { success: false; error: string };
    17→
    18→export const POST = withEmailAccount(
    19→  "outlook/calendar/device-code-connect",
    20→  async (request) => {
    21→    const { emailAccountId } = request.auth;
    22→    const logger = request.logger;
    23→
    24→    // Step 1: Check if MSAL is enabled
    25→    if (!isMSALDeviceCodeEnabled()) {
    26→      logger.warn("MSAL device code flow is not enabled");
    27→      return NextResponse.json(
    28→        { success: false, error: "Device code flow is not enabled" },
    29→        { status: 400 },
    30→      );
    31→    }
    32→
    33→    // Step 2: Get email account with Account relation (including tokens)
    34→    const emailAccount = await prisma.emailAccount.findUnique({
    35→      where: { id: emailAccountId },
    36→      select: {
    37→        id: true,
    38→        email: true,
    39→        account: {
    40→          select: {
    41→            provider: true,
    42→            providerAccountId: true,
    43→            refresh_token: true,
    44→            access_token: true,
    45→            expires_at: true,
    46→          },
    47→        },
    48→      },
    49→    });
    50→
    51→    if (!emailAccount) {
    52→      logger.warn("Email account not found", { emailAccountId });
    53→      return NextResponse.json(
    54→        { success: false, error: "Email account not found" },
    55→        { status: 404 },
    56→      );
    57→    }
    58→
    59→    // Step 3: Verify it's a device-code account
    60→    const isDeviceCodeAuth =
    61→      emailAccount.account?.provider === "microsoft" &&
    62→      !emailAccount.account?.refresh_token;
    63→
    64→    if (!isDeviceCodeAuth) {
    65→      logger.warn("Account is not device-code authenticated", {
    66→        emailAccountId,
    67→        provider: emailAccount.account?.provider,
    68→        hasRefreshToken: !!emailAccount.account?.refresh_token,
    69→      });
    70→      return NextResponse.json(
    71→        {
    72→          success: false,
    73→          error: "This endpoint is only for device-code authenticated accounts",
    74→        },
    75→        { status: 400 },
    76→      );
    77→    }
    78→
    79→    const providerAccountId = emailAccount.account?.providerAccountId;
    80→    if (!providerAccountId) {
    81→      logger.error("Missing providerAccountId for device-code account", {
    82→        emailAccountId,
    83→      });
    84→      return NextResponse.json(
    85→        { success: false, error: "Account configuration error" },
    86→        { status: 500 },
    87→      );
    88→    }
    89→
    90→    // Step 4: Get access token - try stored token first, then MSAL
    91→    let accessToken: string;
    92→    let tokenExpiresAt: Date;
    93→
    94→    const storedToken = emailAccount.account?.access_token;
    95→    const storedExpiry = emailAccount.account?.expires_at;
    96→    const tokenStillValid =
    97→      storedToken &&
    98→      storedExpiry &&
    99→      storedExpiry.getTime() > Date.now() + 5 * 60 * 1000; // 5 min buffer
   100→
   101→    if (tokenStillValid && storedToken) {
   102→      // Use stored token if still valid
   103→      logger.info("Using stored access token for calendar setup", {
   104→        emailAccountId,
   105→        expiresAt: storedExpiry?.toISOString(),
   106→      });
   107→      // Need to decrypt the token
   108→      const { decryptToken } = await import("@/utils/encryption");
   109→      const decrypted = decryptToken(storedToken);
   110→      if (!decrypted) {
   111→        logger.error("Failed to decrypt stored access token", { emailAccountId });
   112→        return NextResponse.json(
   113→          { success: false, error: "Token decryption failed" },
   114→          { status: 500 },
   115→        );
   116→      }
   117→      accessToken = decrypted;
   118→      tokenExpiresAt = storedExpiry!;
   119→    } else {
   120→      // Try MSAL for token refresh
   121→      const msalResult = await acquireMSALTokenSilent(providerAccountId);
   122→
   123→      if (!msalResult) {
   124→        logger.warn("Failed to acquire MSAL token silently", {
   125→          emailAccountId,
   126→          providerAccountId,
   127→        });
   128→        return NextResponse.json(
   129→          {
   130→            success: false,
   131→            error:
   132→              "Authentication expired. Please log in again using device code flow.",
   133→          },
   134→          { status: 401 },
   135→        );
   136→      }
   137→
   138→      accessToken = msalResult.accessToken;
   139→      tokenExpiresAt = msalResult.expiresAt;
   140→    }
   141→
   142→    // Step 5: Fetch user email from Graph API to verify token works
   143→    let microsoftEmail: string;
   144→    try {
   145→      const profileResponse = await fetch(
   146→        "https://graph.microsoft.com/v1.0/me",
   147→        {
   148→          headers: {
   149→            Authorization: `Bearer ${accessToken}`,
   150→          },
   151→        },
   152→      );
   153→
   154→      if (!profileResponse.ok) {
   155→        throw new Error(`Graph API error: ${profileResponse.status}`);
   156→      }
   157→
   158→      const profile = await profileResponse.json();
   159→      microsoftEmail = profile.mail || profile.userPrincipalName;
   160→
   161→      if (!microsoftEmail) {
   162→        throw new Error("Profile missing email");
   163→      }
   164→    } catch (error) {
   165→      logger.error("Failed to fetch user profile from Graph API", {
   166→        error,
   167→        emailAccountId,
   168→      });
   169→      return NextResponse.json(
   170→        { success: false, error: "Failed to verify Microsoft account" },
   171→        { status: 500 },
   172→      );
   173→    }
   174→
   175→    // Step 6: Check for existing connection
   176→    const existingConnection = await checkExistingConnection(
   177→      emailAccountId,
   178→      "microsoft",
   179→      microsoftEmail,
   180→    );
   181→
   182→    if (existingConnection) {
   183→      logger.info("Calendar connection already exists", {
   184→        emailAccountId,
   185→        email: microsoftEmail,
   186→      });
   187→      return NextResponse.json({
   188→        success: true,
   189→        connectionId: existingConnection.id,
   190→      });
   191→    }
   192→
   193→    // Step 7: Create CalendarConnection with refreshToken = null (device-code flow)
   194→    const connection = await createCalendarConnection({
   195→      provider: "microsoft",
   196→      email: microsoftEmail,
   197→      emailAccountId,
   198→      accessToken,
   199→      refreshToken: "", // Empty string since device-code doesn't provide refresh tokens
   200→      expiresAt: tokenExpiresAt,
   201→    });
   202→
   203→    logger.info("Created calendar connection for device-code account", {
   204→      emailAccountId,
   205→      connectionId: connection.id,
   206→      email: microsoftEmail,
   207→    });
   208→
   209→    // Step 8: Sync calendars
   210→    try {
   211→      const microsoftProvider = createMicrosoftCalendarProvider(logger);
   212→      await microsoftProvider.syncCalendars(
   213→        connection.id,
   214→        accessToken,
   215→        "", // No refresh token for device-code
   216→        emailAccountId,
   217→        tokenExpiresAt,
   218→        providerAccountId, // Pass for MSAL token refresh
   219→      );
   220→
   221→      logger.info("Synced calendars for device-code account", {
   222→        emailAccountId,
   223→        connectionId: connection.id,
   224→      });
   225→    } catch (error) {
   226→      logger.error("Failed to sync calendars", {
   227→        error,
   228→        emailAccountId,
   229→        connectionId: connection.id,
   230→      });
   231→      // Don't fail the entire operation - connection was created
   232→      // Sync can be retried later
   233→    }
   234→
   235→    return NextResponse.json({
   236→      success: true,
   237→      connectionId: connection.id,
   238→    });
   239→  },
   240→);
   241→
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-24T04:07:13.012Z)**_

<tool-use data-tool-type="search" data-tool-name="Grep"><details>
<summary>Tool use: **Grep**</summary>
 path `./apps/web/utils` pattern `CalendarConnection`
```
Found 5 files
apps/web/utils/calendar/providers/microsoft-events.ts
apps/web/utils/calendar/unified-availability.test.ts
apps/web/utils/calendar/handle-calendar-callback.ts
apps/web/utils/calendar/oauth-callback-helpers.ts
apps/web/utils/calendar/providers/google-events.ts
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-24T04:07:21.587Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./apps/web/utils/calendar/providers/microsoft.ts`
```
     1→import { env } from "@/env";
     2→import prisma from "@/utils/prisma";
     3→import type { Logger } from "@/utils/logger";
     4→import {
     5→  fetchMicrosoftCalendars,
     6→  getCalendarClientWithRefresh,
     7→} from "@/utils/outlook/calendar-client";
     8→import type { CalendarOAuthProvider, CalendarTokens } from "../oauth-types";
     9→import { autoPopulateTimezone } from "../timezone-helpers";
    10→
    11→export function createMicrosoftCalendarProvider(
    12→  logger: Logger,
    13→): CalendarOAuthProvider {
    14→  return {
    15→    name: "microsoft",
    16→
    17→    async exchangeCodeForTokens(code: string): Promise<CalendarTokens> {
    18→      if (!env.MICROSOFT_CLIENT_ID || !env.MICROSOFT_CLIENT_SECRET) {
    19→        throw new Error("Microsoft credentials not configured");
    20→      }
    21→
    22→      // Exchange code for tokens
    23→      const tokenResponse = await fetch(
    24→        `https://login.microsoftonline.com/${env.MICROSOFT_TENANT_ID}/oauth2/v2.0/token`,
    25→        {
    26→          method: "POST",
    27→          headers: {
    28→            "Content-Type": "application/x-www-form-urlencoded",
    29→          },
    30→          body: new URLSearchParams({
    31→            client_id: env.MICROSOFT_CLIENT_ID,
    32→            client_secret: env.MICROSOFT_CLIENT_SECRET,
    33→            code,
    34→            grant_type: "authorization_code",
    35→            redirect_uri: `${env.NEXT_PUBLIC_BASE_URL}/api/outlook/calendar/callback`,
    36→          }),
    37→        },
    38→      );
    39→
    40→      const tokens = await tokenResponse.json();
    41→
    42→      if (!tokenResponse.ok) {
    43→        throw new Error(
    44→          tokens.error_description || "Failed to exchange code for tokens",
    45→        );
    46→      }
    47→
    48→      // Get user profile using the access token
    49→      const profileResponse = await fetch(
    50→        "https://graph.microsoft.com/v1.0/me",
    51→        {
    52→          headers: {
    53→            Authorization: `Bearer ${tokens.access_token}`,
    54→          },
    55→        },
    56→      );
    57→
    58→      if (!profileResponse.ok) {
    59→        throw new Error("Failed to fetch user profile");
    60→      }
    61→
    62→      const profile = await profileResponse.json();
    63→      const microsoftEmail = profile.mail || profile.userPrincipalName;
    64→
    65→      if (!microsoftEmail) {
    66→        throw new Error("Profile missing required email");
    67→      }
    68→
    69→      if (!tokens.refresh_token) {
    70→        throw new Error(
    71→          "No refresh_token returned from Microsoft (ensure offline_access scope and correct app type)",
    72→        );
    73→      }
    74→
    75→      return {
    76→        accessToken: tokens.access_token,
    77→        refreshToken: tokens.refresh_token,
    78→        expiresAt: tokens.expires_in
    79→          ? new Date(Date.now() + tokens.expires_in * 1000)
    80→          : null,
    81→        email: microsoftEmail,
    82→      };
    83→    },
    84→
    85→    async syncCalendars(
    86→      connectionId: string,
    87→      accessToken: string,
    88→      refreshToken: string,
    89→      emailAccountId: string,
    90→      expiresAt: Date | null,
    91→      providerAccountId?: string | null,
    92→    ): Promise<void> {
    93→      try {
    94→        const calendarClient = await getCalendarClientWithRefresh({
    95→          accessToken,
    96→          refreshToken,
    97→          expiresAt: expiresAt?.getTime() ?? null,
    98→          emailAccountId,
    99→          providerAccountId,
   100→          logger,
   101→        });
   102→
   103→        const microsoftCalendars = await fetchMicrosoftCalendars(
   104→          calendarClient,
   105→          logger,
   106→        );
   107→
   108→        for (const microsoftCalendar of microsoftCalendars) {
   109→          if (!microsoftCalendar.id) continue;
   110→
   111→          await prisma.calendar.upsert({
   112→            where: {
   113→              connectionId_calendarId: {
   114→                connectionId,
   115→                calendarId: microsoftCalendar.id,
   116→              },
   117→            },
   118→            update: {
   119→              name: microsoftCalendar.name || "Untitled Calendar",
   120→              description: microsoftCalendar.description,
   121→              timezone: null,
   122→            },
   123→            create: {
   124→              connectionId,
   125→              calendarId: microsoftCalendar.id,
   126→              name: microsoftCalendar.name || "Untitled Calendar",
   127→              description: microsoftCalendar.description,
   128→              timezone: null,
   129→              isEnabled: true,
   130→            },
   131→          });
   132→        }
   133→
   134→        await autoPopulateTimezone(emailAccountId, microsoftCalendars, logger);
   135→      } catch (error) {
   136→        logger.error("Error syncing calendars", { error, connectionId });
   137→        await prisma.calendarConnection.update({
   138→          where: { id: connectionId },
   139→          data: { isConnected: false },
   140→        });
   141→        throw error;
   142→      }
   143→    },
   144→  };
   145→}
   146→
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-24T04:07:22.675Z)**_

<tool-use data-tool-type="search" data-tool-name="Grep"><details>
<summary>Tool use: **Grep**</summary>
 path `./` pattern `getTokenCache|serialize|deserialize`
```
whats-next.md:78:   - Serialize/deserialize token cache to database
whats-next.md:89:   - After successful auth, serialize and store the MSAL cache
.specstory/history/2026-01-23_04-52-11Z-command-name-clear-command.md:286: serialize-error                    12.0.0  →    13.0.1
.specstory/history/2026-01-23_04-52-11Z-command-name-clear-command.md:333:23. `serialize-error` (12.x → 13.x) - Major version
.specstory/history/2026-01-23_04-52-11Z-command-name-clear-command.md:586:   161→    "serialize-error": "13.0.1",
.specstory/history/2026-01-22_23-30-15Z-command-name-clear-command.md:905:   161→    "serialize-error": "12.0.0",
.specstory/history/2026-01-23_20-09-20Z-fix-the-pnpm-lint.md:49:inbox-zero-ai:lint: /Users/hack/github/inbox-zero/biome.json:2:14 deserialize ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
.specstory/history/2026-01-23_20-09-20Z-fix-the-pnpm-lint.md:66:inbox-zero-ai:lint: /Users/hack/github/inbox-zero/biome.json:308:9 deserialize ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
.specstory/history/2026-01-23_20-09-20Z-fix-the-pnpm-lint.md:161:inbox-zero-ai:lint: /Users/hack/github/inbox-zero/biome.json:310:9 deserialize ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
.specstory/history/2026-01-23_20-09-20Z-fix-the-pnpm-lint.md:667:inbox-zero-ai:lint: /Users/hack/github/inbox-zero/biome.json:2:14 deserialize ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
.specstory/history/2026-01-23_20-09-20Z-fix-the-pnpm-lint.md:684:inbox-zero-ai:lint: /Users/hack/github/inbox-zero/biome.json:308:9 deserialize ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
.specstory/history/2026-01-23_20-09-20Z-fix-the-pnpm-lint.md:779:inbox-zero-ai:lint: /Users/hack/github/inbox-zero/biome.json:310:9 deserialize ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
.specstory/history/2026-01-23_20-09-20Z-fix-the-pnpm-lint.md:1648:/Users/hack/github/inbox-zero/biome.json:308:9 deserialize
.specstory/history/2026-01-23_20-09-20Z-fix-the-pnpm-lint.md:2030:/Users/hack/github/inbox-zero/biome.json:2:14 deserialize ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
.specstory/history/2026-01-23_20-09-20Z-fix-the-pnpm-lint.md:2047:/Users/hack/github/inbox-zero/biome.json:308:9 deserialize ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
.specstory/history/2026-01-23_20-09-20Z-fix-the-pnpm-lint.md:2548:/Users/hack/github/inbox-zero/biome.json:2:14 deserialize ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
.specstory/history/2026-01-23_20-09-20Z-fix-the-pnpm-lint.md:2565:/Users/hack/github/inbox-zero/biome.json:308:9 deserialize ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
.specstory/history/2026-01-23_20-09-20Z-fix-the-pnpm-lint.md:2994:inbox-zero-ai:lint: /Users/hack/github/inbox-zero/biome.json:2:14 deserialize ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
.specstory/history/2026-01-23_20-09-20Z-fix-the-pnpm-lint.md:3011:inbox-zero-ai:lint: /Users/hack/github/inbox-zero/biome.json:308:9 deserialize ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
.specstory/history/2026-01-23_20-09-20Z-fix-the-pnpm-lint.md:3703:w3c-xmlserializer@5.0.0
.claude/prompts/msal-integration-implement.md:371:  const cache = app.getTokenCache();
.claude/prompts/msal-integration-implement.md:381:  const cache = app.getTokenCache();
.specstory/history/2026-01-24_03-52-27Z-please-audit-the-msal.md:729:  const tokenCache = app.getTokenCache();
.specstory/history/2026-01-24_03-52-27Z-please-audit-the-msal.md:2564:   452→  const tokenCache = app.getTokenCache();
.specstory/history/2026-01-24_03-52-27Z-please-audit-the-msal.md:3670:     3→import { serializeSignedCookie } from "better-call";
.specstory/history/2026-01-24_03-52-27Z-please-audit-the-msal.md:3981:   314→  const signed = await serializeSignedCookie("", sessionToken, secret);
.specstory/history/2026-01-24_03-52-27Z-please-audit-the-msal.md:9542:  const tokenCache = app.getTokenCache();
.specstory/history/2026-01-24_03-52-27Z-please-audit-the-msal.md:10960:    if (cache) context.tokenCache.deserialize(cache.data);
.specstory/history/2026-01-24_03-52-27Z-please-audit-the-msal.md:10967:        update: { data: context.tokenCache.serialize() },
.specstory/history/2026-01-24_03-52-27Z-please-audit-the-msal.md:10968:        create: { key: "default", data: context.tokenCache.serialize() },
.specstory/history/2026-01-24_03-52-27Z-please-audit-the-msal.md:11600:   452→  const tokenCache = app.getTokenCache();
.specstory/history/2026-01-24_03-52-27Z-please-audit-the-msal.md:11959:     3→import { serializeSignedCookie } from "better-call";
.specstory/history/2026-01-24_03-52-27Z-please-audit-the-msal.md:12270:   314→  const signed = await serializeSignedCookie("", sessionToken, secret);
.specstory/history/2026-01-24_03-52-27Z-please-audit-the-msal.md:13927: path `./` pattern `getTokenCache|serialize|deserialize`
.specstory/history/2026-01-23_08-15-24Z-command-name-mcp-command.md:668:   161→    "serialize-error": "13.0.1",
.specstory/history/2026-01-23_08-15-24Z-command-name-mcp-command.md:3023:[Omitted long matching line]
.specstory/history/2026-01-24_00-33-19Z-command-name-clear-command.md:1619:inbox-zero-ai:dev: [msal-device-code]: MSAL [Info]: [Sat, 24 Jan 2026 02:39:45 GMT] : [] : @azure/msal-node@5.0.2 : Info - getTokenCache called 
.specstory/history/2026-01-24_00-33-19Z-command-name-clear-command.md:2309:   452→  const tokenCache = app.getTokenCache();
.specstory/history/2026-01-24_00-33-19Z-command-name-clear-command.md:2644:1. **Persist the MSAL token cache** - Store the refresh token / cache serialized to database
.specstory/history/2026-01-24_00-33-19Z-command-name-clear-command.md:2863:     3→import { serializeSignedCookie } from "better-call";
.specstory/history/2026-01-24_00-33-19Z-command-name-clear-command.md:3174:   314→  const signed = await serializeSignedCookie("", sessionToken, secret);
.specstory/history/2026-01-24_00-33-19Z-command-name-clear-command.md:3227:The solution needs to:1. **Persist MSAL's token cache** - MSAL does provide a way to serialize and deserialize its token cache
.specstory/history/2026-01-24_00-33-19Z-command-name-clear-command.md:3231:Looking at MSAL-node documentation, there's a way to:- Export the cache using `tokenCache.serialize()`
.specstory/history/2026-01-24_00-33-19Z-command-name-clear-command.md:3234:Let me explore if we can store the MSAL refresh token in the database. Actually, MSAL's `AuthenticationResult` returned from device code flow includes a refresh token internally - it's just not exposed directly. But the serialized cache contains it.
.specstory/history/2026-01-24_00-33-19Z-command-name-clear-command.md:3236:The better approach is to:1. Store the MSAL access token AND the serialized token cache entry in the database2. On request, check if we have a cached token and it's not expired3. If expired, use the serialized cache to get a new token silently
.specstory/history/2026-01-24_00-33-19Z-command-name-clear-command.md:3240:- When device-code auth completes, serialize the MSAL token cache- Store the serialized cache as a blob in the Account table or a new table
.specstory/history/2026-01-24_00-33-19Z-command-name-clear-command.md:3243:- Restore the cache from the database on startup or when `acquireTokenSilent` fails. I need to implement a custom cache plugin that reads from and writes to the database, storing the serialized token data alongside the account record.
.specstory/history/2026-01-24_00-33-19Z-command-name-clear-command.md:3571:2. Serialize/deserialize the token cache
.specstory/history/2026-01-24_00-33-19Z-command-name-clear-command.md:3737:   114→2. Serialize/deserialize the token cache
.specstory/history/2026-01-24_00-33-19Z-command-name-clear-command.md:3935:2. Serialize/deserialize the token cache
.specstory/history/2026-01-24_00-33-19Z-command-name-clear-command.md:6071:   - Serialize/deserialize token cache to database
.specstory/history/2026-01-24_00-33-19Z-command-name-clear-command.md:6082:   - After successful auth, serialize and store the MSAL cache
.specstory/history/2026-01-22_20-48-41Z-command-name-clear-command.md:1189:   371→  const cache = app.getTokenCache();
.specstory/history/2026-01-22_20-48-41Z-command-name-clear-command.md:1199:   381→  const cache = app.getTokenCache();
.specstory/history/2026-01-23_22-31-05Z-command-name-clear-command.md:6490:     3→import { serializeSignedCookie } from "better-call";
.specstory/history/2026-01-23_22-31-05Z-command-name-clear-command.md:6801:   314→  const signed = await serializeSignedCookie("", sessionToken, secret);
.specstory/history/2026-01-23_22-31-05Z-command-name-clear-command.md:8970:     3→import { serializeSignedCookie } from "better-call";
.specstory/history/2026-01-23_22-31-05Z-command-name-clear-command.md:9281:   314→  const signed = await serializeSignedCookie("", sessionToken, secret);
.specstory/history/2026-01-23_22-31-05Z-command-name-clear-command.md:13149:     3→import { serializeSignedCookie } from "better-call";
.specstory/history/2026-01-23_22-31-05Z-command-name-clear-command.md:13460:   314→  const signed = await serializeSignedCookie("", sessionToken, secret);
.specstory/history/2026-01-23_22-31-05Z-command-name-clear-command.md:15680:- Call `app.getTokenCache().getAllAccounts()`
.specstory/history/2026-01-23_22-31-05Z-command-name-clear-command.md:15980:- Call `app.getTokenCache().getAllAccounts()`
.specstory/history/2026-01-23_22-31-05Z-command-name-clear-command.md:16220:Add new exported function to acquire tokens silently from MSAL cache for device-code accounts. Uses getMSALApp(), getTokenCache().getAllAccounts(), and acquireTokenSilent().
.specstory/history/2026-01-23_22-31-05Z-command-name-clear-command.md:16343:   452→  const tokenCache = app.getTokenCache();
.specstory/history/2026-01-22_04-47-20Z-command-name-add-dir.md:2095:   135→                    auth_record = AuthenticationRecord.deserialize(
.specstory/history/2026-01-22_04-47-20Z-command-name-add-dir.md:2110:   150→            auth_record_data = json.loads(auth_record.serialize())
.specstory/history/2026-01-22_04-47-20Z-command-name-add-dir.md:9549:  const cache = app.getTokenCache();
.specstory/history/2026-01-22_04-47-20Z-command-name-add-dir.md:9559:  const cache = app.getTokenCache();
.specstory/history/2026-01-22_04-47-20Z-command-name-add-dir.md:10125:pca.getTokenCache(): TokenCache;
.specstory/history/2026-01-22_04-47-20Z-command-name-add-dir.md:12314:- `clearCache()`, `getLogger()`, `setLogger()`, `getTokenCache()`
.specstory/history/2026-01-22_04-47-20Z-command-name-add-dir.md:12843:   159→    "serialize-error": "12.0.0",
.specstory/history/2026-01-22_04-47-20Z-command-name-add-dir.md:14113:pca.getTokenCache(): TokenCache;
apps/web/utils/outlook/msal-device-code.ts:452:  const tokenCache = app.getTokenCache();
apps/web/utils/logger.test.ts:31:  it("should serialize simple Error objects", () => {
apps/web/utils/logger.test.ts:42:  it("should serialize Error instances as message only", () => {
apps/web/utils/logger.test.ts:59:  it("should serialize nested error objects", () => {
apps/web/utils/logger.test.ts:77:  it("should serialize deeply nested errors", () => {
apps/web/utils/logger.test.ts:103:  it("should serialize arrays of errors", () => {
apps/web/utils/logger.test.ts:121:  it("should serialize axios-like error structure", () => {
apps/web/package.json:161:    "serialize-error": "13.0.1",
apps/web/app/api/outlook/device-code/poll/route.ts:3:import { serializeSignedCookie } from "better-call";
apps/web/app/api/outlook/device-code/poll/route.ts:314:  const signed = await serializeSignedCookie("", sessionToken, secret);
apps/web/utils/logger.ts:3:import { serializeError } from "serialize-error";
apps/web/utils/logger.ts:131:  const errorFull = serializeError(error);
apps/web/utils/ai/choose-rule/run-rules.ts:16:import { serializeMatchReasons } from "@/utils/ai/choose-rule/types";
apps/web/utils/ai/choose-rule/run-rules.ts:334:      matchMetadata: serializeMatchReasons(matchReasons),
apps/web/utils/ai/choose-rule/types.ts:62:export function serializeMatchReasons(
apps/web/components/editor/extensions/LabelMention.tsx:217:          serialize: (state: MarkdownSerializerState, node: MarkdownNode) => {
apps/web/components/GroupedTable.tsx:105:    serialize: (value) => value.join(","),
apps/web/components/assistant-chat/tools.tsx:206:  // Check if actions have changed by comparing serialized versions
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-24T04:07:30.987Z)**_

Let me also check the calendar client for token refresh patterns and explore what already exists for reference implementations.

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-24T04:07:31.685Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./apps/web/utils/outlook/calendar-client.ts`
```
     1→import { env } from "@/env";
     2→import type { Logger } from "@/utils/logger";
     3→import { CALENDAR_SCOPES } from "@/utils/outlook/scopes";
     4→import { SafeError } from "@/utils/error";
     5→import prisma from "@/utils/prisma";
     6→import {
     7→  Client,
     8→  type AuthenticationProvider,
     9→} from "@microsoft/microsoft-graph-client";
    10→import { acquireMSALTokenSilent } from "@/utils/outlook/msal-device-code";
    11→
    12→class CalendarAuthProvider implements AuthenticationProvider {
    13→  private readonly accessToken: string;
    14→
    15→  constructor(accessToken: string) {
    16→    this.accessToken = accessToken;
    17→  }
    18→
    19→  async getAccessToken(): Promise<string> {
    20→    return this.accessToken;
    21→  }
    22→}
    23→
    24→export function getCalendarOAuth2Url(state: string): string {
    25→  if (!env.MICROSOFT_CLIENT_ID) {
    26→    throw new Error("Microsoft login not enabled - missing client ID");
    27→  }
    28→
    29→  const baseUrl = `https://login.microsoftonline.com/${env.MICROSOFT_TENANT_ID}/oauth2/v2.0/authorize`;
    30→  const params = new URLSearchParams({
    31→    client_id: env.MICROSOFT_CLIENT_ID,
    32→    response_type: "code",
    33→    redirect_uri: `${env.NEXT_PUBLIC_BASE_URL}/api/outlook/calendar/callback`,
    34→    scope: CALENDAR_SCOPES.join(" "),
    35→    state,
    36→  });
    37→
    38→  return `${baseUrl}?${params.toString()}`;
    39→}
    40→
    41→export const getCalendarClientWithRefresh = async ({
    42→  accessToken,
    43→  refreshToken,
    44→  expiresAt,
    45→  emailAccountId,
    46→  providerAccountId,
    47→  logger,
    48→}: {
    49→  accessToken?: string | null;
    50→  refreshToken: string | null;
    51→  expiresAt: number | null;
    52→  emailAccountId: string;
    53→  providerAccountId?: string | null;
    54→  logger: Logger;
    55→}): Promise<Client> => {
    56→  // Check if token is still valid
    57→  if (expiresAt && expiresAt > Date.now() && accessToken) {
    58→    const authProvider = new CalendarAuthProvider(accessToken);
    59→    return Client.initWithMiddleware({ authProvider });
    60→  }
    61→
    62→  // For device-code accounts (no refresh token), use MSAL silent acquisition
    63→  if (!refreshToken && providerAccountId) {
    64→    logger.info("Using MSAL silent acquisition for calendar token refresh", {
    65→      emailAccountId,
    66→      providerAccountId,
    67→    });
    68→
    69→    const msalResult = await acquireMSALTokenSilent(providerAccountId);
    70→
    71→    if (!msalResult) {
    72→      throw new SafeError(
    73→        "Authentication expired. Please log in again using device code flow.",
    74→      );
    75→    }
    76→
    77→    // Update the calendar connection with the fresh token
    78→    const calendarConnection = await prisma.calendarConnection.findFirst({
    79→      where: {
    80→        emailAccountId,
    81→        provider: "microsoft",
    82→      },
    83→      select: { id: true },
    84→    });
    85→
    86→    if (calendarConnection) {
    87→      await prisma.calendarConnection.update({
    88→        where: { id: calendarConnection.id },
    89→        data: {
    90→          accessToken: msalResult.accessToken,
    91→          expiresAt: msalResult.expiresAt,
    92→        },
    93→      });
    94→      logger.info("Updated calendar connection with MSAL token", {
    95→        connectionId: calendarConnection.id,
    96→      });
    97→    }
    98→
    99→    const authProvider = new CalendarAuthProvider(msalResult.accessToken);
   100→    return Client.initWithMiddleware({ authProvider });
   101→  }
   102→
   103→  // Standard OAuth flow - requires refresh token
   104→  if (!refreshToken) {
   105→    throw new SafeError("No refresh token available for calendar access");
   106→  }
   107→
   108→  // Token is expired or missing, need to refresh using OAuth
   109→  try {
   110→    if (!env.MICROSOFT_CLIENT_ID || !env.MICROSOFT_CLIENT_SECRET) {
   111→      throw new Error("Microsoft login not enabled - missing credentials");
   112→    }
   113→
   114→    const response = await fetch(
   115→      `https://login.microsoftonline.com/${env.MICROSOFT_TENANT_ID}/oauth2/v2.0/token`,
   116→      {
   117→        method: "POST",
   118→        headers: {
   119→          "Content-Type": "application/x-www-form-urlencoded",
   120→        },
   121→        body: new URLSearchParams({
   122→          client_id: env.MICROSOFT_CLIENT_ID,
   123→          client_secret: env.MICROSOFT_CLIENT_SECRET,
   124→          refresh_token: refreshToken,
   125→          grant_type: "refresh_token",
   126→          scope: CALENDAR_SCOPES.join(" "),
   127→        }),
   128→      },
   129→    );
   130→
   131→    const tokens = await response.json();
   132→
   133→    if (!response.ok) {
   134→      throw new Error(tokens.error_description || "Failed to refresh token");
   135→    }
   136→
   137→    if (!tokens.expires_in) {
   138→      throw new Error("Token response missing expires_in field");
   139→    }
   140→
   141→    // Find the calendar connection to update
   142→    const calendarConnection = await prisma.calendarConnection.findFirst({
   143→      where: {
   144→        emailAccountId,
   145→        provider: "microsoft",
   146→      },
   147→      select: { id: true },
   148→    });
   149→
   150→    if (calendarConnection) {
   151→      await saveCalendarTokens({
   152→        tokens: {
   153→          access_token: tokens.access_token,
   154→          refresh_token: tokens.refresh_token,
   155→          expires_at: Math.floor(Date.now() / 1000 + Number(tokens.expires_in)),
   156→        },
   157→        connectionId: calendarConnection.id,
   158→        logger,
   159→      });
   160→    } else {
   161→      logger.warn("No calendar connection found to update tokens", {
   162→        emailAccountId,
   163→      });
   164→    }
   165→
   166→    const authProvider = new CalendarAuthProvider(tokens.access_token);
   167→    return Client.initWithMiddleware({ authProvider });
   168→  } catch (error) {
   169→    const isInvalidGrantError =
   170→      error instanceof Error && error.message.includes("invalid_grant");
   171→
   172→    if (isInvalidGrantError) {
   173→      logger.warn("Error refreshing Calendar access token", {
   174→        emailAccountId,
   175→        error: error.message,
   176→      });
   177→    }
   178→
   179→    throw error;
   180→  }
   181→};
   182→
   183→export async function fetchMicrosoftCalendars(
   184→  calendarClient: Client,
   185→  logger: Logger,
   186→): Promise<
   187→  Array<{
   188→    id?: string;
   189→    name?: string;
   190→    description?: string;
   191→    isDefaultCalendar?: boolean;
   192→  }>
   193→> {
   194→  try {
   195→    const response = await calendarClient
   196→      .api("/me/calendars")
   197→      .select("id,name,color,isDefaultCalendar,canEdit,owner")
   198→      .get();
   199→
   200→    return response.value || [];
   201→  } catch (error) {
   202→    logger.error("Error fetching Microsoft calendars", { error });
   203→    throw new SafeError("Failed to fetch calendars");
   204→  }
   205→}
   206→
   207→async function saveCalendarTokens({
   208→  tokens,
   209→  connectionId,
   210→  logger,
   211→}: {
   212→  tokens: {
   213→    access_token?: string;
   214→    refresh_token?: string;
   215→    expires_at?: number; // seconds
   216→  };
   217→  connectionId: string;
   218→  logger: Logger;
   219→}) {
   220→  if (!tokens.access_token) {
   221→    logger.warn("No access token to save for calendar connection", {
   222→      connectionId,
   223→    });
   224→    return;
   225→  }
   226→
   227→  try {
   228→    await prisma.calendarConnection.update({
   229→      where: { id: connectionId },
   230→      data: {
   231→        accessToken: tokens.access_token,
   232→        refreshToken: tokens.refresh_token,
   233→        expiresAt: tokens.expires_at
   234→          ? new Date(tokens.expires_at * 1000)
   235→          : null,
   236→      },
   237→    });
   238→
   239→    logger.info("Calendar tokens saved successfully", { connectionId });
   240→  } catch (error) {
   241→    logger.error("Failed to save calendar tokens", { error, connectionId });
   242→    throw error;
   243→  }
   244→}
   245→
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-24T04:07:32.149Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./whats-next.md`
```
     1→<original_task>
     2→Fix MSAL device-code authentication issues for Microsoft Outlook integration. The device-code auth flow was failing because:
     3→1. Email client threw "No refresh token" error for device-code authenticated accounts
     4→2. Calendar device-code-connect endpoint returned 401 when MSAL cache was empty
     5→3. The MSAL token cache is in-memory and lost on server restart
     6→
     7→The goal was to enable device-code authenticated users to successfully complete account setup and use email/calendar features by implementing MSAL token fallback similar to what was already done for the calendar client.
     8→</original_task>
     9→
    10→<work_completed>
    11→## Commits Created
    12→
    13→1. **`efee46c70`** - `feat: add MSAL token fallback for device-code authenticated accounts`
    14→2. **`53f37c08d`** - `fix: wrap ResizeGroup return in fragment for valid JSX element`
    15→
    16→## Files Modified
    17→
    18→### 1. `apps/web/utils/outlook/client.ts`
    19→- Added imports for `acquireMSALTokenSilent`, `encryptToken`, and `prisma`
    20→- Added `providerAccountId?: string | null` parameter to `getOutlookClientWithRefresh` function
    21→- Added MSAL fallback logic (lines 113-143):
    22→  - When `!refreshToken && providerAccountId`, attempts MSAL silent acquisition
    23→  - On success, updates Account table with encrypted new token
    24→  - On failure, throws user-friendly SafeError asking for re-authentication
    25→- Reordered logic: checks token validity first, then MSAL fallback, then standard OAuth refresh
    26→
    27→### 2. `apps/web/utils/account.ts`
    28→- Updated `getTokens()` function to also select and return `providerAccountId` from Account relation
    29→- Updated `getOutlookClientForEmail()` to pass `providerAccountId: tokens.providerAccountId` and use `null` instead of empty string for refreshToken
    30→- Updated `getOutlookAndAccessTokenForEmail()` same changes
    31→- Updated `getOutlookClientForEmailId()` to select `providerAccountId` and pass it through
    32→
    33→### 3. `apps/web/app/api/outlook/calendar/device-code-connect/route.ts`
    34→- Added `access_token` and `expires_at` to the Account select query
    35→- Added logic (lines 90-132) to check for valid stored access token before trying MSAL:
    36→  - If stored token is valid (not expired with 5-min buffer), decrypt and use it
    37→  - If stored token is expired, fall back to MSAL silent acquisition
    38→  - If MSAL fails, return 401 with re-auth message
    39→- Updated all references from `msalResult.accessToken` to `accessToken` variable
    40→- Updated all references from `msalResult.expiresAt` to `tokenExpiresAt` variable
    41→
    42→### 4. `apps/web/components/email-list/EmailList.tsx` (line 499)
    43→- Fixed TypeScript error: Changed `if (!right) return left;` to `if (!right) return <>{left}</>;`
    44→- The ResizeGroup component was returning React.ReactNode which includes undefined, not a valid JSX element
    45→
    46→## Previously Modified Files (in staged commit)
    47→These were already implemented before this session:
    48→- `apps/web/app/(app)/[emailAccountId]/calendars/ConnectCalendar.tsx` - Device-code flow branching
    49→- `apps/web/app/api/user/email-accounts/route.ts` - Added isDeviceCodeAuth and providerAccountId to response
    50→- `apps/web/providers/EmailAccountProvider.tsx` - Exposed isDeviceCodeAuth and providerAccountId in context
    51→- `apps/web/utils/calendar/oauth-types.ts` - Updated syncCalendars signature with optional providerAccountId
    52→- `apps/web/utils/calendar/providers/microsoft.ts` - Pass providerAccountId to calendar client
    53→- `apps/web/utils/calendar/providers/google.ts` - Updated signature to match interface
    54→- `apps/web/utils/outlook/calendar-client.ts` - Already had MSAL fallback for calendar token refresh
    55→- `apps/web/utils/outlook/msal-device-code.ts` - Added `acquireMSALTokenSilent()` function
    56→
    57→## Commands Run
    58→- `pnpm tsc --noEmit -p apps/web/tsconfig.json` - Verified TypeScript compilation
    59→- `git commit --no-verify` - Used to bypass failing pre-commit hook (ultracite config issue)
    60→</work_completed>
    61→
    62→<work_remaining>
    63→## Phase 3: MSAL Cache Persistence (Not Implemented - Optional Enhancement)
    64→
    65→The current implementation works when:
    66→- The server is still running after device-code login
    67→- The stored access token in the Account table is still valid
    68→
    69→It will FAIL when:
    70→- Server restarts AND stored access token has expired
    71→- In this case, user must re-authenticate via device-code flow
    72→
    73→### To implement persistent MSAL cache:
    74→
    75→1. **Create `apps/web/utils/outlook/msal-cache-persistence.ts`**
    76→   - Implement custom MSAL cache plugin using `ICachePlugin` interface
    77→   - Methods needed: `beforeCacheAccess()` and `afterCacheAccess()`
    78→   - Serialize/deserialize token cache to database
    79→
    80→2. **Database schema change (optional approaches)**:
    81→   - Option A: Add `msal_cache TEXT` column to Account table
    82→   - Option B: Create new `MsalTokenCache` table with `providerAccountId` and `cacheBlob`
    83→
    84→3. **Update `getMSALApp()` in `msal-device-code.ts`**:
    85→   - Pass the cache plugin to PublicClientApplication config
    86→   - Load existing cache for known accounts on startup
    87→
    88→4. **Update device-code poll endpoint**:
    89→   - After successful auth, serialize and store the MSAL cache
    90→
    91→## Testing Required
    92→
    93→1. Log in via device-code flow at `/login/device-code`
    94→2. Navigate to setup page - verify email stats load without error
    95→3. Navigate to calendars page - click "Add Outlook Calendar"
    96→4. Verify calendar connects successfully
    97→5. Test token refresh by waiting for token to expire (~1 hour) or manually invalidating
    98→
    99→## Pre-commit Hook Issue
   100→
   101→The pre-commit hook (`husky`) is failing with:
   102→```
   103→× Failed to resolve the configuration from ultracite/biome/core
   104→  Could not resolve ultracite/biome/core: module not found
   105→```
   106→
   107→This is a lint configuration issue unrelated to the code changes. May need to:
   108→- Run `pnpm install` to ensure ultracite is properly installed
   109→- Check `package.json` for ultracite dependency
   110→- Verify `.lintstagedrc` or similar config
   111→</work_remaining>
   112→
   113→<attempted_approaches>
   114→## Successful Approaches
   115→
   116→1. **Mirroring calendar-client.ts pattern for email client**
   117→   - The calendar client already had MSAL fallback logic
   118→   - Copied and adapted the same pattern for email client
   119→   - This worked well for consistency
   120→
   121→2. **Using stored access token before MSAL**
   122→   - Added check for valid stored token in device-code-connect endpoint
   123→   - This allows calendar setup to work even when MSAL cache is empty
   124→   - Requires token decryption using `decryptToken()`
   125→
   126→## Issues Encountered
   127→
   128→1. **Linter reverted ResizeGroup fix**
   129→   - First fix was reverted by a linter/formatter
   130→   - Had to re-apply the fragment wrapper fix
   131→
   132→2. **TypeScript errors with decryptToken**
   133→   - `decryptToken()` can return `null`
   134→   - Had to add null check and error handling
   135→
   136→3. **Pre-commit hook failure**
   137→   - Ultracite configuration issue prevents normal commits
   138→   - Workaround: Used `--no-verify` flag
   139→   - Root cause not investigated (out of scope)
   140→
   141→## Not Attempted
   142→
   143→1. **MSAL cache persistence to database**
   144→   - Would require schema migration
   145→   - Deferred as optional enhancement (Phase 3)
   146→   - Current solution works for active sessions
   147→</attempted_approaches>
   148→
   149→<critical_context>
   150→## How MSAL Device-Code Auth Works
   151→
   152→1. User initiates device-code flow → gets user code to enter at Microsoft
   153→2. MSAL library polls Microsoft until user completes auth
   154→3. MSAL returns `AuthenticationResult` with access token
   155→4. Access token stored (encrypted) in Account table
   156→5. `refresh_token` is stored as `null` (MSAL manages refresh internally)
   157→6. MSAL keeps tokens in **in-memory cache** for silent refresh
   158→
   159→## Key Insight: Two Token Refresh Mechanisms
   160→
   161→| Auth Type | Refresh Mechanism |
   162→|-----------|-------------------|
   163→| Standard OAuth | Uses `refresh_token` from database with Microsoft token endpoint |
   164→| Device-Code | Uses MSAL's `acquireTokenSilent()` with in-memory cache |
   165→
   166→## The Core Problem
   167→
   168→MSAL's in-memory cache is lost on:
   169→- Server restart
   170→- Process termination
   171→- Load balancer routing to different instance
   172→
   173→When cache is empty, `acquireTokenSilent()` returns null, requiring re-authentication.
   174→
   175→## Current Mitigation
   176→
   177→1. Store access token in Account table during device-code login
   178→2. Check if stored token is still valid before trying MSAL
   179→3. If stored token valid → use it directly
   180→4. If stored token expired → try MSAL silent refresh
   181→5. If MSAL fails → ask user to re-authenticate
   182→
   183→## Important File Relationships
   184→
   185→```
   186→getOutlookClientForEmail() [account.ts]
   187→  └── getTokens() [account.ts]
   188→        └── returns { accessToken, refreshToken, expiresAt, providerAccountId }
   189→  └── getOutlookClientWithRefresh() [client.ts]
   190→        ├── If token valid → use it
   191→        ├── If no refreshToken && providerAccountId → try MSAL
   192→        └── If refreshToken → standard OAuth refresh
   193→```
   194→
   195→## Environment Variables for MSAL
   196→
   197→- `MSAL_ENABLED=true` - Required to enable device-code flow
   198→- `MSAL_CLIENT_ID` - Optional, falls back to MICROSOFT_CLIENT_ID
   199→- `MSAL_TENANT_ID` - Optional, falls back to MICROSOFT_TENANT_ID or "common"
   200→- `MSAL_DEBUG=true` - Enables verbose MSAL logging
   201→</critical_context>
   202→
   203→<current_state>
   204→## Git Status
   205→
   206→- **Branch**: `feature/alternative-auth-method`
   207→- **Latest commits**:
   208→  - `53f37c08d` - fix: wrap ResizeGroup return in fragment for valid JSX element
   209→  - `efee46c70` - feat: add MSAL token fallback for device-code authenticated accounts
   210→
   211→## Uncommitted Changes
   212→
   213→```
   214→M  apps/web/components.json        # shadcn config changes (unrelated)
   215→M  apps/web/components/ui/resizable.tsx  # shadcn component update (unrelated)
   216→?? .specstory/history/...          # Various history files
   217→?? apps/web/lib/                   # New directory (unrelated)
   218→```
   219→
   220→## Implementation Status
   221→
   222→| Phase | Status | Description |
   223→|-------|--------|-------------|
   224→| Phase 1 | ✅ Complete | MSAL fallback in email client |
   225→| Phase 2 | ✅ Complete | providerAccountId passed through token chain |
   226→| Phase 3 | ⏳ Not Started | MSAL cache persistence (optional) |
   227→| Phase 4 | ✅ Complete | Calendar device-code-connect uses stored token |
   228→
   229→## What Works Now
   230→
   231→1. Device-code login creates account with proper providerAccountId
   232→2. Email operations use MSAL fallback when no refresh token
   233→3. Calendar device-code-connect uses stored token before MSAL
   234→4. ResizeGroup TypeScript error is fixed
   235→
   236→## What Doesn't Work
   237→
   238→1. After server restart with expired stored token, user must re-authenticate
   239→2. Pre-commit hooks fail due to ultracite configuration issue
   240→
   241→## Ready for Testing
   242→
   243→The implementation is complete and committed. User should:
   244→1. Restart dev server: `pnpm dev`
   245→2. Test device-code login flow
   246→3. Verify email stats load on setup page
   247→4. Verify calendar connection works
   248→</current_state>
   249→
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-24T04:07:39.714Z)**_

Now let me look at the MSAL Node.js documentation patterns for cache plugin implementation.

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-24T04:07:41.242Z)**_

<tool-use data-tool-type="search" data-tool-name="Grep"><details>
<summary>Tool use: **Grep**</summary>
 path `./` pattern `ICachePlugin|beforeCacheAccess|afterCacheAccess`
```
whats-next.md:76:   - Implement custom MSAL cache plugin using `ICachePlugin` interface
whats-next.md:77:   - Methods needed: `beforeCacheAccess()` and `afterCacheAccess()`
.specstory/history/2026-01-24_03-52-27Z-please-audit-the-msal.md:10955:import { ICachePlugin } from "@azure/msal-node";
.specstory/history/2026-01-24_03-52-27Z-please-audit-the-msal.md:10957:class PrismaCachePlugin implements ICachePlugin {
.specstory/history/2026-01-24_03-52-27Z-please-audit-the-msal.md:10958:  async beforeCacheAccess(context) {
.specstory/history/2026-01-24_03-52-27Z-please-audit-the-msal.md:10963:  async afterCacheAccess(context) {
.specstory/history/2026-01-24_03-52-27Z-please-audit-the-msal.md:11132:- MSAL Node.js ICachePlugin interface
.specstory/history/2026-01-24_03-52-27Z-please-audit-the-msal.md:12341: path `./` pattern `ICachePlugin`
.specstory/history/2026-01-24_03-52-27Z-please-audit-the-msal.md:14509:    76→   - Implement custom MSAL cache plugin using `ICachePlugin` interface
.specstory/history/2026-01-24_03-52-27Z-please-audit-the-msal.md:14510:    77→   - Methods needed: `beforeCacheAccess()` and `afterCacheAccess()`
.specstory/history/2026-01-24_03-52-27Z-please-audit-the-msal.md:14694: path `./` pattern `ICachePlugin|beforeCacheAccess|afterCacheAccess`
.specstory/history/2026-01-24_00-33-19Z-command-name-clear-command.md:6069:   - Implement custom MSAL cache plugin using `ICachePlugin` interface
.specstory/history/2026-01-24_00-33-19Z-command-name-clear-command.md:6070:   - Methods needed: `beforeCacheAccess()` and `afterCacheAccess()`
.specstory/history/2026-01-22_04-47-20Z-command-name-add-dir.md:10143:    cachePlugin?: ICachePlugin;               // Custom cache implementation
.specstory/history/2026-01-22_04-47-20Z-command-name-add-dir.md:10621:3. [ ] Implement ICachePlugin for database storage with encryption
.specstory/history/2026-01-22_04-47-20Z-command-name-add-dir.md:14131:    cachePlugin?: ICachePlugin;               // Custom cache implementation
.specstory/history/2026-01-22_04-47-20Z-command-name-add-dir.md:14609:3. [ ] Implement ICachePlugin for database storage with encryption
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-24T04:07:41.797Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./apps/web/utils/auth.ts`
```
     1→// based on: https://github.com/vercel/platforms/blob/main/lib/auth.ts
     2→
     3→import { sso } from "@better-auth/sso";
     4→import { createContact as createLoopsContact } from "@inboxzero/loops";
     5→import { createContact as createResendContact } from "@inboxzero/resend";
     6→import type { Account, AuthContext } from "better-auth";
     7→import { betterAuth } from "better-auth";
     8→import { prismaAdapter } from "better-auth/adapters/prisma";
     9→import { nextCookies } from "better-auth/next-js";
    10→import { cookies, headers } from "next/headers";
    11→import { env } from "@/env";
    12→import { trackDubSignUp } from "@/utils/dub";
    13→import {
    14→  isGoogleProvider,
    15→  isMicrosoftProvider,
    16→} from "@/utils/email/provider-types";
    17→import { encryptToken } from "@/utils/encryption";
    18→import { captureException } from "@/utils/error";
    19→import { getContactsClient as getGoogleContactsClient } from "@/utils/gmail/client";
    20→import { SCOPES as GMAIL_SCOPES } from "@/utils/gmail/scopes";
    21→import { createScopedLogger } from "@/utils/logger";
    22→import { createOutlookClient } from "@/utils/outlook/client";
    23→import { SCOPES as OUTLOOK_SCOPES } from "@/utils/outlook/scopes";
    24→import {
    25→  claimPendingPremiumInvite,
    26→  updateAccountSeats,
    27→} from "@/utils/premium/server";
    28→import { clearUserErrorMessages } from "@/utils/error-messages";
    29→import prisma from "@/utils/prisma";
    30→
    31→const logger = createScopedLogger("auth");
    32→
    33→export const betterAuthConfig = betterAuth({
    34→  advanced: {
    35→    database: {
    36→      generateId: false,
    37→    },
    38→  },
    39→  logger: {
    40→    level: "info",
    41→    log: (level, message, ...args) => {
    42→      switch (level) {
    43→        case "info":
    44→          logger.info(message, { args });
    45→          break;
    46→        case "error":
    47→          logger.error(message, { args });
    48→          break;
    49→      }
    50→    },
    51→  },
    52→  baseURL: env.NEXT_PUBLIC_BASE_URL,
    53→  trustedOrigins: [env.NEXT_PUBLIC_BASE_URL],
    54→  secret: env.AUTH_SECRET || env.NEXTAUTH_SECRET,
    55→  emailAndPassword: {
    56→    enabled: false,
    57→  },
    58→  database: prismaAdapter(prisma, {
    59→    provider: "postgresql",
    60→  }),
    61→  plugins: [
    62→    nextCookies(),
    63→    sso({
    64→      disableImplicitSignUp: false,
    65→      organizationProvisioning: { disabled: true },
    66→    }),
    67→  ],
    68→  session: {
    69→    modelName: "Session",
    70→    fields: {
    71→      token: "sessionToken",
    72→      expiresAt: "expires",
    73→    },
    74→    cookieCache: {
    75→      enabled: true,
    76→      maxAge: 60 * 60 * 24 * 30, // 30 days
    77→    },
    78→    expiresIn: 60 * 60 * 24 * 30, // 30 days
    79→    updateAge: 60 * 60 * 24 * 3, // 1 day (every 1 day the session expiration is updated)
    80→  },
    81→  account: {
    82→    modelName: "Account",
    83→    fields: {
    84→      accountId: "providerAccountId",
    85→      providerId: "provider",
    86→      refreshToken: "refresh_token",
    87→      refreshTokenExpiresAt: "refreshTokenExpiresAt",
    88→      accessToken: "access_token",
    89→      accessTokenExpiresAt: "expires_at",
    90→      idToken: "id_token",
    91→    },
    92→  },
    93→  verification: {
    94→    modelName: "VerificationToken",
    95→    fields: {
    96→      value: "token",
    97→      expiresAt: "expires",
    98→    },
    99→  },
   100→  socialProviders: {
   101→    google: {
   102→      clientId: env.GOOGLE_CLIENT_ID,
   103→      clientSecret: env.GOOGLE_CLIENT_SECRET,
   104→      scope: [...GMAIL_SCOPES],
   105→      accessType: "offline",
   106→      prompt: "select_account consent",
   107→      disableIdTokenSignIn: true,
   108→    },
   109→    microsoft: {
   110→      clientId: env.MICROSOFT_CLIENT_ID || "",
   111→      clientSecret: env.MICROSOFT_CLIENT_SECRET || "",
   112→      scope: [...OUTLOOK_SCOPES],
   113→      tenantId: env.MICROSOFT_TENANT_ID,
   114→      disableIdTokenSignIn: true,
   115→    },
   116→  },
   117→  databaseHooks: {
   118→    user: {
   119→      create: {
   120→        after: async (user) => {
   121→          await postSignUp({
   122→            id: user.id,
   123→            email: user.email,
   124→            name: user.name,
   125→            image: user.image,
   126→          }).catch((error) => {
   127→            logger.error("Error posting sign up", { error, user });
   128→            captureException(error, { extra: { user } });
   129→          });
   130→        },
   131→      },
   132→    },
   133→    account: {
   134→      create: {
   135→        after: async (account: Account) => {
   136→          await handleLinkAccount(account);
   137→        },
   138→      },
   139→      update: {
   140→        after: async (account: Account) => {
   141→          await handleLinkAccount(account);
   142→        },
   143→      },
   144→    },
   145→  },
   146→  onAPIError: {
   147→    throw: true,
   148→    onError: (error: unknown, ctx: AuthContext) => {
   149→      logger.error("Auth API encountered an error", { error, ctx });
   150→    },
   151→    errorURL: "/login/error",
   152→  },
   153→});
   154→
   155→async function postSignUp({
   156→  id: userId,
   157→  email,
   158→  name,
   159→  image,
   160→}: {
   161→  id: string;
   162→  email: string;
   163→  name?: string | null;
   164→  image?: string | null;
   165→}) {
   166→  const loops = async () => {
   167→    const account = await prisma.account
   168→      .findFirst({
   169→        where: { userId },
   170→        select: { provider: true },
   171→      })
   172→      .catch((error) => {
   173→        logger.error("Error finding account", {
   174→          userId,
   175→          error,
   176→        });
   177→        captureException(error, { userEmail: email });
   178→      });
   179→
   180→    await createLoopsContact(
   181→      email,
   182→      name?.split(" ")?.[0],
   183→      account?.provider,
   184→    ).catch((error) => {
   185→      const alreadyExists =
   186→        error instanceof Error && error.message.includes("409");
   187→      if (!alreadyExists) {
   188→        logger.error("Error creating Loops contact", {
   189→          email,
   190→          error,
   191→        });
   192→        captureException(error, { userEmail: email });
   193→      }
   194→    });
   195→  };
   196→
   197→  const resend = createResendContact({ email }).catch((error) => {
   198→    logger.error("Error creating Resend contact", {
   199→      email,
   200→      error,
   201→    });
   202→    captureException(error, { userEmail: email });
   203→  });
   204→
   205→  const dub = trackDubSignUp({ id: userId, email, name, image }, logger).catch(
   206→    (error) => {
   207→      logger.error("Error tracking Dub sign up", {
   208→        email,
   209→        error,
   210→      });
   211→      captureException(error, { userEmail: email });
   212→    },
   213→  );
   214→
   215→  await Promise.all([
   216→    loops(),
   217→    resend,
   218→    dub,
   219→    handlePendingPremiumInvite({ email }),
   220→    handleReferralOnSignUp({ userId, email }),
   221→  ]);
   222→}
   223→
   224→async function handlePendingPremiumInvite({ email }: { email: string }) {
   225→  try {
   226→    logger.info("Handling pending premium invite", { email });
   227→
   228→    // Check for pending invite
   229→    const premium = await prisma.premium.findFirst({
   230→      where: { pendingInvites: { has: email } },
   231→      select: {
   232→        id: true,
   233→        lemonSqueezySubscriptionItemId: true,
   234→        stripeSubscriptionId: true,
   235→      },
   236→    });
   237→
   238→    if (
   239→      premium?.lemonSqueezySubscriptionItemId ||
   240→      premium?.stripeSubscriptionId
   241→    ) {
   242→      const user = await prisma.user.findUnique({
   243→        where: { email },
   244→        select: { id: true },
   245→      });
   246→
   247→      if (user) {
   248→        await claimPendingPremiumInvite({
   249→          visitorId: user.id,
   250→          premiumId: premium.id,
   251→          email,
   252→        });
   253→        logger.info("Added user to premium from invite", { email });
   254→      }
   255→    }
   256→  } catch (error) {
   257→    logger.error("Error handling pending premium invite", { error, email });
   258→    captureException(error, {
   259→      extra: { email, location: "handlePendingPremiumInvite" },
   260→    });
   261→  }
   262→}
   263→
   264→export async function handleReferralOnSignUp({
   265→  userId,
   266→  email,
   267→}: {
   268→  userId: string;
   269→  email: string;
   270→}) {
   271→  try {
   272→    const cookieStore = await cookies();
   273→    const referralCookie = cookieStore.get("referral_code");
   274→
   275→    if (!referralCookie?.value) {
   276→      logger.info("No referral code found in cookies", { email });
   277→      return;
   278→    }
   279→
   280→    const referralCode = referralCookie.value;
   281→    logger.info("Processing referral for new user", {
   282→      email,
   283→      referralCode,
   284→    });
   285→
   286→    // Import the createReferral function
   287→    const { createReferral } = await import("@/utils/referral/referral-code");
   288→    await createReferral(userId, referralCode);
   289→    logger.info("Successfully created referral", {
   290→      email,
   291→      referralCode,
   292→    });
   293→  } catch (error) {
   294→    logger.error("Error processing referral on sign up", {
   295→      error,
   296→      userId,
   297→      email,
   298→    });
   299→    // Don't throw error - referral failure shouldn't prevent sign up
   300→    captureException(error, {
   301→      extra: { userId, email, location: "handleReferralOnSignUp" },
   302→    });
   303→  }
   304→}
   305→
   306→// TODO: move into email provider instead of checking the provider type
   307→async function getProfileData(providerId: string, accessToken: string) {
   308→  if (isGoogleProvider(providerId)) {
   309→    const contactsClient = getGoogleContactsClient({ accessToken });
   310→    const profileResponse = await contactsClient.people.get({
   311→      resourceName: "people/me",
   312→      personFields: "emailAddresses,names,photos",
   313→    });
   314→
   315→    return {
   316→      email: profileResponse.data.emailAddresses
   317→        ?.find((e) => e.metadata?.primary)
   318→        ?.value?.toLowerCase(),
   319→      name: profileResponse.data.names?.find((n) => n.metadata?.primary)
   320→        ?.displayName,
   321→      image: profileResponse.data.photos?.find((p) => p.metadata?.primary)?.url,
   322→    };
   323→  }
   324→
   325→  if (isMicrosoftProvider(providerId)) {
   326→    const client = createOutlookClient(accessToken, logger);
   327→    try {
   328→      const profileResponse = await client.getUserProfile();
   329→
   330→      // Get photo separately as it requires a different endpoint
   331→      let photoUrl = null;
   332→      try {
   333→        const photo = await client.getUserPhoto();
   334→        if (photo) {
   335→          photoUrl = photo;
   336→        }
   337→      } catch (error) {
   338→        logger.info("User has no profile photo", { error });
   339→      }
   340→
   341→      return {
   342→        email:
   343→          profileResponse.mail?.toLowerCase() ||
   344→          profileResponse.userPrincipalName?.toLowerCase(),
   345→        name: profileResponse.displayName,
   346→        image: photoUrl,
   347→      };
   348→    } catch (error) {
   349→      logger.error("Error fetching Microsoft profile data", { error });
   350→      throw error;
   351→    }
   352→  }
   353→}
   354→
   355→async function handleLinkAccount(account: Account) {
   356→  let primaryEmail: string | null | undefined;
   357→  let primaryName: string | null | undefined;
   358→  let primaryPhotoUrl: string | null | undefined;
   359→
   360→  try {
   361→    if (!account.accessToken) {
   362→      logger.error(
   363→        "[linkAccount] No access_token found in data, cannot fetch profile.",
   364→      );
   365→      throw new Error("Missing access token during account linking.");
   366→    }
   367→    const profileData = await getProfileData(
   368→      account.providerId,
   369→      account.accessToken,
   370→    );
   371→
   372→    if (!profileData?.email) {
   373→      logger.error("[handleLinkAccount] No email found in profile data");
   374→    }
   375→
   376→    primaryEmail = profileData?.email;
   377→    primaryName = profileData?.name;
   378→    primaryPhotoUrl = profileData?.image;
   379→
   380→    if (!primaryEmail) {
   381→      logger.error(
   382→        "[linkAccount] Primary email could not be determined from profile.",
   383→      );
   384→      throw new Error("Primary email not found for linked account.");
   385→    }
   386→
   387→    const user = await prisma.user.findUnique({
   388→      where: { id: account.userId },
   389→      select: { email: true, name: true, image: true },
   390→    });
   391→
   392→    if (!user?.email) {
   393→      logger.error("[linkAccount] No user email found", {
   394→        userId: account.userId,
   395→      });
   396→      return;
   397→    }
   398→
   399→    const data = {
   400→      userId: account.userId,
   401→      accountId: account.id,
   402→      name: primaryName,
   403→      image: primaryPhotoUrl,
   404→    };
   405→
   406→    await prisma.$transaction([
   407→      prisma.emailAccount.upsert({
   408→        where: { email: profileData?.email },
   409→        update: data,
   410→        create: {
   411→          ...data,
   412→          email: primaryEmail,
   413→        },
   414→      }),
   415→      prisma.account.update({
   416→        where: { id: account.id },
   417→        data: { disconnectedAt: null },
   418→      }),
   419→    ]);
   420→
   421→    await clearUserErrorMessages({ userId: account.userId });
   422→
   423→    // Handle premium account seats
   424→    await updateAccountSeats({ userId: account.userId }).catch((error) => {
   425→      logger.error("[linkAccount] Error updating premium account seats:", {
   426→        userId: account.userId,
   427→        error,
   428→      });
   429→      captureException(error, { extra: { userId: account.userId } });
   430→    });
   431→
   432→    logger.info("[linkAccount] Successfully linked account", {
   433→      email: user.email,
   434→      userId: account.userId,
   435→      accountId: account.id,
   436→    });
   437→  } catch (error) {
   438→    logger.error("[linkAccount] Error during linking process:", {
   439→      userId: account.userId,
   440→      error,
   441→    });
   442→    captureException(error, {
   443→      extra: { userId: account.userId, location: "linkAccount" },
   444→    });
   445→    throw error;
   446→  }
   447→}
   448→
   449→export async function saveTokens({
   450→  tokens,
   451→  accountRefreshToken,
   452→  providerAccountId,
   453→  emailAccountId,
   454→  provider,
   455→}: {
   456→  tokens: {
   457→    access_token?: string;
   458→    refresh_token?: string;
   459→    expires_at?: number;
   460→  };
   461→  accountRefreshToken: string | null;
   462→  provider: string;
   463→} & ( // provide one of these:
   464→  | {
   465→      providerAccountId: string;
   466→      emailAccountId?: never;
   467→    }
   468→  | {
   469→      emailAccountId: string;
   470→      providerAccountId?: never;
   471→    }
   472→)) {
   473→  const refreshToken = tokens.refresh_token ?? accountRefreshToken;
   474→
   475→  if (!refreshToken) {
   476→    logger.error("Attempted to save null refresh token", { providerAccountId });
   477→    captureException("Cannot save null refresh token", {
   478→      extra: { providerAccountId },
   479→    });
   480→    return;
   481→  }
   482→
   483→  const data = {
   484→    access_token: tokens.access_token,
   485→    expires_at: tokens.expires_at ? new Date(tokens.expires_at * 1000) : null,
   486→    refresh_token: refreshToken,
   487→    disconnectedAt: null,
   488→  };
   489→
   490→  if (emailAccountId) {
   491→    // Encrypt tokens in data directly
   492→    // Usually we do this in prisma-extensions.ts but we need to do it here because we're updating the account via the emailAccount
   493→    // We could also edit prisma-extensions.ts to handle this case but this is easier for now
   494→    if (data.access_token)
   495→      data.access_token = encryptToken(data.access_token) || undefined;
   496→    if (data.refresh_token)
   497→      data.refresh_token = encryptToken(data.refresh_token) || "";
   498→
   499→    const emailAccount = await prisma.emailAccount.update({
   500→      where: { id: emailAccountId },
   501→      data: { account: { update: data } },
   502→      select: { userId: true },
   503→    });
   504→
   505→    await clearUserErrorMessages({ userId: emailAccount.userId });
   506→  } else {
   507→    if (!providerAccountId) {
   508→      logger.error("No providerAccountId found in database", {
   509→        emailAccountId,
   510→      });
   511→      captureException("No providerAccountId found in database", {
   512→        extra: { emailAccountId },
   513→      });
   514→      return;
   515→    }
   516→
   517→    const account = await prisma.account.update({
   518→      where: {
   519→        provider_providerAccountId: {
   520→          provider,
   521→          providerAccountId,
   522→        },
   523→      },
   524→      data,
   525→    });
   526→
   527→    await clearUserErrorMessages({ userId: account.userId });
   528→
   529→    return account;
   530→  }
   531→}
   532→
   533→export const auth = async () =>
   534→  betterAuthConfig.api.getSession({ headers: await headers() });
   535→
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-24T04:07:51.030Z)**_

Now let me check the account.ts file for context on how tokens are retrieved and used.

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-24T04:07:51.943Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./apps/web/utils/account.ts`
```
     1→import { notFound } from "next/navigation";
     2→import { cookies } from "next/headers";
     3→import { auth } from "@/utils/auth";
     4→import {
     5→  getGmailClientWithRefresh,
     6→  getAccessTokenFromClient,
     7→} from "@/utils/gmail/client";
     8→import {
     9→  getOutlookClientWithRefresh,
    10→  getAccessTokenFromClient as getOutlookAccessToken,
    11→} from "@/utils/outlook/client";
    12→import { redirect } from "next/navigation";
    13→import prisma from "@/utils/prisma";
    14→import {
    15→  LAST_EMAIL_ACCOUNT_COOKIE,
    16→  type LastEmailAccountCookieValue,
    17→} from "@/utils/cookies";
    18→import type { Logger } from "@/utils/logger";
    19→
    20→export async function getGmailClientForEmail({
    21→  emailAccountId,
    22→  logger,
    23→}: {
    24→  emailAccountId: string;
    25→  logger: Logger;
    26→}) {
    27→  const tokens = await getTokens({ emailAccountId });
    28→  const gmail = getGmailClientWithRefresh({
    29→    accessToken: tokens.accessToken,
    30→    refreshToken: tokens.refreshToken || "",
    31→    expiresAt: tokens.expiresAt,
    32→    emailAccountId,
    33→    logger,
    34→  });
    35→  return gmail;
    36→}
    37→
    38→export async function getGmailAndAccessTokenForEmail({
    39→  emailAccountId,
    40→  logger,
    41→}: {
    42→  emailAccountId: string;
    43→  logger: Logger;
    44→}) {
    45→  const tokens = await getTokens({ emailAccountId });
    46→  const gmail = await getGmailClientWithRefresh({
    47→    accessToken: tokens.accessToken,
    48→    refreshToken: tokens.refreshToken || "",
    49→    expiresAt: tokens.expiresAt,
    50→    emailAccountId,
    51→    logger,
    52→  });
    53→  const accessToken = getAccessTokenFromClient(gmail);
    54→  return { gmail, accessToken, tokens };
    55→}
    56→
    57→export async function getOutlookClientForEmail({
    58→  emailAccountId,
    59→  logger,
    60→}: {
    61→  emailAccountId: string;
    62→  logger: Logger;
    63→}) {
    64→  const tokens = await getTokens({ emailAccountId });
    65→  const outlook = await getOutlookClientWithRefresh({
    66→    accessToken: tokens.accessToken,
    67→    refreshToken: tokens.refreshToken || null,
    68→    expiresAt: tokens.expiresAt,
    69→    emailAccountId,
    70→    providerAccountId: tokens.providerAccountId,
    71→    logger,
    72→  });
    73→  return outlook;
    74→}
    75→
    76→export async function getOutlookAndAccessTokenForEmail({
    77→  emailAccountId,
    78→  logger,
    79→}: {
    80→  emailAccountId: string;
    81→  logger: Logger;
    82→}) {
    83→  const tokens = await getTokens({ emailAccountId });
    84→  const outlook = await getOutlookClientWithRefresh({
    85→    accessToken: tokens.accessToken,
    86→    refreshToken: tokens.refreshToken || null,
    87→    expiresAt: tokens.expiresAt,
    88→    emailAccountId,
    89→    providerAccountId: tokens.providerAccountId,
    90→    logger,
    91→  });
    92→  const accessToken = getOutlookAccessToken(outlook);
    93→  return { outlook, accessToken, tokens };
    94→}
    95→
    96→export async function getOutlookClientForEmailId({
    97→  emailAccountId,
    98→  logger,
    99→}: {
   100→  emailAccountId: string;
   101→  logger: Logger;
   102→}) {
   103→  const emailAccount = await prisma.emailAccount.findUnique({
   104→    where: { id: emailAccountId },
   105→    select: {
   106→      account: {
   107→        select: {
   108→          access_token: true,
   109→          refresh_token: true,
   110→          expires_at: true,
   111→          providerAccountId: true,
   112→        },
   113→      },
   114→    },
   115→  });
   116→  const outlook = await getOutlookClientWithRefresh({
   117→    accessToken: emailAccount?.account.access_token,
   118→    refreshToken: emailAccount?.account.refresh_token || null,
   119→    expiresAt: emailAccount?.account.expires_at?.getTime() ?? null,
   120→    emailAccountId,
   121→    providerAccountId: emailAccount?.account.providerAccountId,
   122→    logger,
   123→  });
   124→  return outlook;
   125→}
   126→
   127→async function getTokens({ emailAccountId }: { emailAccountId: string }) {
   128→  const emailAccount = await prisma.emailAccount.findUnique({
   129→    where: { id: emailAccountId },
   130→    select: {
   131→      account: {
   132→        select: {
   133→          access_token: true,
   134→          refresh_token: true,
   135→          expires_at: true,
   136→          providerAccountId: true,
   137→        },
   138→      },
   139→    },
   140→  });
   141→
   142→  return {
   143→    accessToken: emailAccount?.account.access_token,
   144→    refreshToken: emailAccount?.account.refresh_token,
   145→    expiresAt: emailAccount?.account.expires_at?.getTime() ?? null,
   146→    providerAccountId: emailAccount?.account.providerAccountId,
   147→  };
   148→}
   149→
   150→export async function redirectToEmailAccountPath(path: `/${string}`) {
   151→  const session = await auth();
   152→  const userId = session?.user.id;
   153→  if (!userId) throw new Error("Not authenticated");
   154→
   155→  const lastEmailAccountId = await getLastEmailAccountFromCookie(userId);
   156→
   157→  let emailAccountId = lastEmailAccountId;
   158→
   159→  // If no last account or it doesn't exist, fall back to first account
   160→  if (!emailAccountId) {
   161→    const emailAccount = await prisma.emailAccount.findFirst({
   162→      where: { userId },
   163→    });
   164→    emailAccountId = emailAccount?.id ?? null;
   165→  }
   166→
   167→  if (!emailAccountId) {
   168→    notFound();
   169→  }
   170→
   171→  const redirectUrl = `/${emailAccountId}${path}`;
   172→
   173→  redirect(redirectUrl);
   174→}
   175→
   176→async function getLastEmailAccountFromCookie(
   177→  userId: string,
   178→): Promise<string | null> {
   179→  try {
   180→    const cookieStore = await cookies();
   181→    const cookieValue = cookieStore.get(LAST_EMAIL_ACCOUNT_COOKIE)?.value;
   182→    if (!cookieValue) return null;
   183→
   184→    // Handle backward compatibility: old cookies stored just the emailAccountId as a plain string
   185→    // New cookies store JSON with { userId, emailAccountId }
   186→    try {
   187→      const parsed = JSON.parse(cookieValue) as LastEmailAccountCookieValue;
   188→      // Validate userId matches to prevent stale data
   189→      if (parsed.userId !== userId) return null;
   190→      return parsed.emailAccountId;
   191→    } catch {
   192→      // If JSON parse fails, it's an old-format cookie (plain emailAccountId string)
   193→      // Return it as-is (the caller will still validate the user owns this account)
   194→      return cookieValue;
   195→    }
   196→  } catch {
   197→    return null;
   198→  }
   199→}
   200→
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-24T04:08:01.108Z)**_

I now have a comprehensive understanding of the codebase. Let me write the detailed implementation plan to the plan file.

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-24T04:09:30.584Z)**_

<tool-use data-tool-type="write" data-tool-name="Write"><details>
<summary>Tool use: **Write**</summary>

```md
# MSAL Device-Code Token Persistence Implementation Plan

## Problem Statement

The inbox-zero MSAL device-code authentication flow discards refresh tokens and uses only an in-memory MSAL cache. This causes users to re-authenticate after:
- Server restarts
- Cache eviction
- Load balancer routing to a different instance
- Access token expiration (~1 hour) when MSAL cache is empty

**Current State (from `whats-next.md`):**
- Phase 1 (Complete): MSAL fallback in email client
- Phase 2 (Complete): `providerAccountId` passed through token chain
- Phase 3 (Not Started): **MSAL cache persistence - THIS PLAN**
- Phase 4 (Complete): Calendar device-code-connect uses stored token

## Solution Overview

Implement a database-backed MSAL token cache using the `ICachePlugin` interface, combined with a direct OAuth2 token endpoint refresh as fallback when MSAL cache is unavailable.

### Architecture Decision

**Option A: MSAL ICachePlugin with Prisma** (Recommended)
- Pros: Native MSAL integration, handles all token types, maintains MSAL's token lifecycle
- Cons: More complex, requires understanding MSAL internals

**Option B: Direct OAuth2 token refresh fallback**
- Pros: Simpler, bypasses MSAL complexity
- Cons: Must extract refresh token from MSAL cache manually, may miss MSAL token updates

**Chosen Approach:** Hybrid - Implement ICachePlugin for primary persistence, with direct OAuth2 fallback for edge cases.

---

## Implementation Plan

### Phase 1: Database Schema Changes

**File: `apps/web/prisma/schema.prisma`**

Add a new field to the Account model to store the MSAL token cache:

\```prisma
model Account {
  // ... existing fields ...
  
  // MSAL device-code flow cache persistence
  // Stores serialized MSAL token cache for accounts authenticated via device-code flow
  // This enables token refresh to survive server restarts
  msal_cache         String?       @db.Text
  msal_cache_updated DateTime?
}
\```

**Rationale:**
- Adding to `Account` model keeps tokens with their owning account
- `@db.Text` handles the potentially large JSON blob
- `msal_cache_updated` helps with debugging and cache invalidation
- No new table needed - simpler migration and query patterns

**Migration Steps:**
1. Create migration: `npx prisma migrate dev --name add_msal_cache_to_account`
2. No data migration needed (new field is nullable)

---

### Phase 2: MSAL Cache Plugin Implementation

**New File: `apps/web/utils/outlook/msal-cache-plugin.ts`**

\```typescript
/**
 * MSAL Token Cache Persistence Plugin
 * 
 * Implements ICachePlugin to persist MSAL's token cache to PostgreSQL.
 * This enables device-code authenticated accounts to refresh tokens
 * after server restarts.
 * 
 * Key Design Decisions:
 * - Uses Account.msal_cache field for storage
 * - Encrypts cache data using existing encryption utilities
 * - Per-account cache isolation via providerAccountId lookup
 */

import type { ICachePlugin, TokenCacheContext } from "@azure/msal-node";
import prisma from "@/utils/prisma";
import { encryptToken, decryptToken } from "@/utils/encryption";
import { createScopedLogger } from "@/utils/logger";

const logger = createScopedLogger("msal-cache-plugin");

export function createPrismaCachePlugin(providerAccountId: string): ICachePlugin {
  return {
    async beforeCacheAccess(cacheContext: TokenCacheContext): Promise<void> {
      try {
        const account = await prisma.account.findFirst({
          where: { 
            provider: "microsoft",
            providerAccountId 
          },
          select: { msal_cache: true },
        });

        if (account?.msal_cache) {
          const decrypted = decryptToken(account.msal_cache);
          if (decrypted) {
            cacheContext.tokenCache.deserialize(decrypted);
            logger.info("Loaded MSAL cache from database", { providerAccountId });
          }
        }
      } catch (error) {
        logger.error("Failed to load MSAL cache", { 
          providerAccountId, 
          error: error instanceof Error ? error.message : String(error) 
        });
        // Don't throw - allow MSAL to continue with empty cache
      }
    },

    async afterCacheAccess(cacheContext: TokenCacheContext): Promise<void> {
      if (!cacheContext.cacheHasChanged) {
        return;
      }

      try {
        const serialized = cacheContext.tokenCache.serialize();
        const encrypted = encryptToken(serialized);

        await prisma.account.updateMany({
          where: { 
            provider: "microsoft",
            providerAccountId 
          },
          data: { 
            msal_cache: encrypted,
            msal_cache_updated: new Date(),
          },
        });

        logger.info("Persisted MSAL cache to database", { providerAccountId });
      } catch (error) {
        logger.error("Failed to persist MSAL cache", { 
          providerAccountId, 
          error: error instanceof Error ? error.message : String(error) 
        });
        // Don't throw - cache persistence failure shouldn't break auth
      }
    },
  };
}
\```

---

### Phase 3: Update MSAL Application Factory

**File: `apps/web/utils/outlook/msal-device-code.ts`**

**Changes Required:**

1. **Modify `getMSALApp()` to accept optional cache plugin:**

\```typescript
// Change from singleton to factory that can create per-account instances
const msalAppCache = new Map<string, PublicClientApplication>();

function getMSALApp(providerAccountId?: string): PublicClientApplication {
  // For initiation (no providerAccountId yet), use shared instance
  const cacheKey = providerAccountId || "default";
  
  if (msalAppCache.has(cacheKey)) {
    return msalAppCache.get(cacheKey)!;
  }

  const clientId = env.MSAL_CLIENT_ID || env.MICROSOFT_CLIENT_ID || MICROSOFT_OFFICE_CLIENT_ID;
  const tenantId = env.MSAL_TENANT_ID || env.MICROSOFT_TENANT_ID || "common";
  const debugEnabled = env.MSAL_DEBUG === "true";

  const config: Configuration = {
    auth: {
      clientId,
      authority: `https://login.microsoftonline.com/${tenantId}`,
    },
    system: {
      loggerOptions: {
        loggerCallback: (level, message, containsPii) => {
          if (containsPii) return;
          if (debugEnabled || level === LogLevel.Error) {
            logger.info(`MSAL [${LogLevel[level]}]: ${message}`);
          }
        },
        piiLoggingEnabled: false,
        logLevel: debugEnabled ? LogLevel.Verbose : LogLevel.Error,
      },
      networkClient: new CustomNetworkModule(),
    },
  };

  // Add cache plugin for known accounts
  if (providerAccountId) {
    config.cache = {
      cachePlugin: createPrismaCachePlugin(providerAccountId),
    };
  }

  const app = new PublicClientApplication(config);
  msalAppCache.set(cacheKey, app);
  
  return app;
}
\```

2. **Update `acquireMSALTokenSilent()` to use per-account MSAL instance:**

\```typescript
export async function acquireMSALTokenSilent(
  providerAccountId: string,
  scopes: string[] = MSAL_DEVICE_CODE_SCOPES,
): Promise<{
  accessToken: string;
  expiresAt: Date;
  account: AccountInfo;
} | null> {
  if (!isMSALDeviceCodeEnabled()) {
    logger.warn("MSAL device code flow is not enabled");
    return null;
  }

  // Use per-account MSAL instance with cache plugin
  const app = getMSALApp(providerAccountId);
  const tokenCache = app.getTokenCache();

  try {
    const accounts = await tokenCache.getAllAccounts();
    
    if (accounts.length === 0) {
      logger.info("No accounts found in MSAL cache, trying database fallback", { providerAccountId });
      // Cache plugin should have loaded from DB in beforeCacheAccess
      // If still empty, try direct OAuth2 refresh
      return await directTokenRefresh(providerAccountId, scopes);
    }

    const account = accounts.find(
      (acc: AccountInfo) => acc.localAccountId === providerAccountId,
    );

    if (!account) {
      logger.info("Account not found in MSAL cache", { providerAccountId });
      return await directTokenRefresh(providerAccountId, scopes);
    }

    const result = await app.acquireTokenSilent({ account, scopes });
    
    if (!result) {
      logger.warn("acquireTokenSilent returned null", { providerAccountId });
      return await directTokenRefresh(providerAccountId, scopes);
    }

    return {
      accessToken: result.accessToken,
      expiresAt: result.expiresOn || new Date(Date.now() + 3_600_000),
      account,
    };
  } catch (error) {
    logger.error("Failed to acquire token silently, trying direct refresh", {
      providerAccountId,
      error: error instanceof Error ? error.message : String(error),
    });
    return await directTokenRefresh(providerAccountId, scopes);
  }
}
\```

3. **Add new function for extracting refresh token from cache:**

\```typescript
/**
 * Extract refresh token from MSAL cache for direct OAuth2 refresh
 * Used as fallback when acquireTokenSilent fails
 */
async function extractRefreshTokenFromCache(
  providerAccountId: string
): Promise<string | null> {
  const account = await prisma.account.findFirst({
    where: { 
      provider: "microsoft",
      providerAccountId 
    },
    select: { msal_cache: true },
  });

  if (!account?.msal_cache) {
    return null;
  }

  try {
    const decrypted = decryptToken(account.msal_cache);
    if (!decrypted) return null;

    // MSAL cache JSON structure contains RefreshToken entries
    const cache = JSON.parse(decrypted);
    const refreshTokens = cache.RefreshToken || {};
    
    // Find refresh token for this account
    for (const key of Object.keys(refreshTokens)) {
      if (key.includes(providerAccountId.toLowerCase())) {
        return refreshTokens[key].secret;
      }
    }

    // Fallback: return first available refresh token
    const firstToken = Object.values(refreshTokens)[0] as { secret?: string } | undefined;
    return firstToken?.secret || null;
  } catch (error) {
    logger.error("Failed to extract refresh token from cache", { 
      providerAccountId, 
      error 
    });
    return null;
  }
}
\```

---

### Phase 4: Direct OAuth2 Token Refresh Fallback

**File: `apps/web/utils/outlook/msal-device-code.ts`**

Add fallback function that uses direct Microsoft token endpoint:

\```typescript
/**
 * Direct OAuth2 token refresh using Microsoft token endpoint
 * Fallback for when MSAL silent acquisition fails but we have a stored refresh token
 */
async function directTokenRefresh(
  providerAccountId: string,
  scopes: string[] = MSAL_DEVICE_CODE_SCOPES,
): Promise<{
  accessToken: string;
  expiresAt: Date;
  account: AccountInfo;
} | null> {
  logger.info("Attempting direct token refresh", { providerAccountId });

  // Try to extract refresh token from stored MSAL cache
  const refreshToken = await extractRefreshTokenFromCache(providerAccountId);
  
  if (!refreshToken) {
    logger.warn("No refresh token available for direct refresh", { providerAccountId });
    return null;
  }

  const clientId = env.MSAL_CLIENT_ID || env.MICROSOFT_CLIENT_ID || MICROSOFT_OFFICE_CLIENT_ID;
  const tenantId = env.MSAL_TENANT_ID || env.MICROSOFT_TENANT_ID || "common";

  try {
    const response = await fetch(
      `https://login.microsoftonline.com/${tenantId}/oauth2/v2.0/token`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
        },
        body: new URLSearchParams({
          client_id: clientId,
          refresh_token: refreshToken,
          grant_type: "refresh_token",
          scope: scopes.join(" "),
        }),
      },
    );

    const tokens = await response.json();

    if (!response.ok) {
      logger.error("Direct token refresh failed", {
        providerAccountId,
        error: tokens.error_description || tokens.error,
      });
      return null;
    }

    logger.info("Direct token refresh successful", { providerAccountId });

    // Update stored tokens in Account table
    const encryptedAccessToken = encryptToken(tokens.access_token);
    await prisma.account.updateMany({
      where: { provider: "microsoft", providerAccountId },
      data: {
        access_token: encryptedAccessToken,
        expires_at: new Date(Date.now() + tokens.expires_in * 1000),
      },
    });

    // If we got a new refresh token, update the MSAL cache
    if (tokens.refresh_token) {
      await updateRefreshTokenInCache(providerAccountId, tokens.refresh_token);
    }

    // Return result in MSAL-compatible format
    return {
      accessToken: tokens.access_token,
      expiresAt: new Date(Date.now() + tokens.expires_in * 1000),
      account: {
        localAccountId: providerAccountId,
        homeAccountId: providerAccountId,
        environment: "login.microsoftonline.com",
        tenantId: tenantId,
        username: "",
      } as AccountInfo,
    };
  } catch (error) {
    logger.error("Direct token refresh error", {
      providerAccountId,
      error: error instanceof Error ? error.message : String(error),
    });
    return null;
  }
}

/**
 * Update refresh token in stored MSAL cache
 */
async function updateRefreshTokenInCache(
  providerAccountId: string,
  newRefreshToken: string,
): Promise<void> {
  const account = await prisma.account.findFirst({
    where: { provider: "microsoft", providerAccountId },
    select: { msal_cache: true },
  });

  if (!account?.msal_cache) return;

  try {
    const decrypted = decryptToken(account.msal_cache);
    if (!decrypted) return;

    const cache = JSON.parse(decrypted);
    const refreshTokens = cache.RefreshToken || {};

    // Update existing refresh token entries
    for (const key of Object.keys(refreshTokens)) {
      if (key.includes(providerAccountId.toLowerCase())) {
        refreshTokens[key].secret = newRefreshToken;
      }
    }

    cache.RefreshToken = refreshTokens;
    const encrypted = encryptToken(JSON.stringify(cache));

    await prisma.account.updateMany({
      where: { provider: "microsoft", providerAccountId },
      data: { 
        msal_cache: encrypted,
        msal_cache_updated: new Date(),
      },
    });
  } catch (error) {
    logger.error("Failed to update refresh token in cache", { providerAccountId, error });
  }
}
\```

---

### Phase 5: Update Device Code Poll Endpoint

**File: `apps/web/app/api/outlook/device-code/poll/route.ts`**

After successful authentication, persist the MSAL cache:

\```typescript
// In completeDeviceCodeAuthentication function, after creating the account:

async function completeDeviceCodeAuthentication({
  pollResult,
  request,
}: {
  pollResult: PollCompleteResult;
  request: NextRequest;
}): Promise<CompletionResult> {
  const { accessToken, expiresAt, scopes, account } = pollResult;

  if (!account) {
    throw new Error("No account info in token response");
  }

  // ... existing profile fetch and account creation code ...

  // After account is created, persist the MSAL cache
  const providerAccountId = account.localAccountId;
  
  // Get MSAL app and serialize its cache
  const app = getMSALApp();
  const tokenCache = app.getTokenCache();
  const serializedCache = tokenCache.serialize();
  
  if (serializedCache) {
    const encryptedCache = encryptToken(serializedCache);
    await prisma.account.updateMany({
      where: { 
        provider: "microsoft", 
        providerAccountId 
      },
      data: { 
        msal_cache: encryptedCache,
        msal_cache_updated: new Date(),
      },
    });
    logger.info("Persisted initial MSAL cache", { providerAccountId });
  }

  // ... rest of existing code ...
}
\```

---

### Phase 6: Update Imports and Exports

**File: `apps/web/utils/outlook/msal-device-code.ts`**

Add necessary imports at the top:

\```typescript
import type { 
  Configuration,
  // ... existing imports
} from "@azure/msal-node";
import { createPrismaCachePlugin } from "./msal-cache-plugin";
import prisma from "@/utils/prisma";
import { encryptToken, decryptToken } from "@/utils/encryption";
\```

Export the new functions for external use if needed:

\```typescript
export { 
  // ... existing exports
  extractRefreshTokenFromCache,  // For debugging/admin use
};
\```

---

## Testing Plan

### Unit Tests

**New File: `apps/web/utils/outlook/msal-cache-plugin.test.ts`**

\```typescript
import { describe, it, expect, vi, beforeEach } from "vitest";
import { createPrismaCachePlugin } from "./msal-cache-plugin";

describe("PrismaCachePlugin", () => {
  const mockProviderAccountId = "test-provider-id";
  
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe("beforeCacheAccess", () => {
    it("should load cache from database when available", async () => {
      // Test implementation
    });

    it("should handle missing cache gracefully", async () => {
      // Test implementation
    });

    it("should handle decryption failure gracefully", async () => {
      // Test implementation
    });
  });

  describe("afterCacheAccess", () => {
    it("should persist cache when changed", async () => {
      // Test implementation
    });

    it("should skip persistence when cache unchanged", async () => {
      // Test implementation
    });
  });
});
\```

### Integration Tests

1. **Test: Fresh device-code login persists cache**
   - Login via device-code
   - Verify `msal_cache` field is populated in Account table
   - Verify cache is encrypted

2. **Test: Server restart with valid cache**
   - Login via device-code
   - Simulate server restart (clear in-memory cache)
   - Verify token refresh works using persisted cache

3. **Test: Direct OAuth2 fallback**
   - Login via device-code
   - Corrupt MSAL cache (but leave refresh token valid)
   - Verify direct token refresh works

4. **Test: Cache invalidation on token revocation**
   - Login via device-code
   - Revoke token at Microsoft
   - Verify appropriate error message

### Manual Testing Checklist

1. [ ] Device-code login at `/login/device-code`
2. [ ] Verify email stats load on setup page
3. [ ] Navigate to calendars, connect Outlook calendar
4. [ ] Restart dev server (`pnpm dev`)
5. [ ] Return to app - verify still authenticated
6. [ ] Wait 1+ hour (or manually expire token)
7. [ ] Verify token refresh works without re-auth

---

## Edge Cases and Error Handling

### Multi-Instance Deployment

**Problem:** Multiple server instances may have stale in-memory caches.

**Solution:** The `ICachePlugin.beforeCacheAccess` is called before every token operation, ensuring the latest cache is loaded from the database.

### Cache Invalidation

**Problem:** User revokes access or changes password at Microsoft.

**Solution:** 
1. Direct OAuth2 refresh will fail with specific error codes (AADSTS70008, etc.)
2. Clear cached tokens and prompt for re-authentication
3. Existing error handling in `getOutlookClientWithRefresh` already handles this

### Encryption Key Rotation

**Problem:** If `EMAIL_ENCRYPT_SECRET` or `EMAIL_ENCRYPT_SALT` change, cached tokens become unreadable.

**Solution:**
1. Existing encryption utilities already handle decryption failures gracefully (return `null`)
2. When cache decryption fails, fall back to re-authentication
3. Document that changing encryption keys requires users to re-authenticate

### Race Conditions

**Problem:** Concurrent requests may race to update the cache.

**Solution:**
1. MSAL's token cache is designed to handle concurrent access
2. The `cacheHasChanged` flag prevents unnecessary writes
3. Prisma's `updateMany` is atomic
4. Accept that in rare cases, slightly older cache may be persisted (acceptable)

---

## Rollback Procedure

If issues arise:

1. **Quick Disable:** Set `MSAL_ENABLED=false` in environment
2. **Schema Rollback:** 
   \```bash
   npx prisma migrate rollback --target add_msal_cache_to_account
   \```
3. **Code Rollback:** Revert the commits from this implementation

---

## Implementation Order

1. **Day 1:** Schema migration + basic cache plugin
2. **Day 2:** Update MSAL factory + poll endpoint
3. **Day 3:** Direct OAuth2 fallback + token extraction
4. **Day 4:** Testing + edge case handling
5. **Day 5:** Documentation + deployment

---

## Dependencies

- `@azure/msal-node` (already installed)
- `prisma` (already installed)
- Encryption utilities (already exist)

No new npm packages required.

---

## Critical Files for Implementation

1. **`/Users/hack/github/inbox-zero/apps/web/prisma/schema.prisma`** - Add `msal_cache` and `msal_cache_updated` fields to Account model

2. **`/Users/hack/github/inbox-zero/apps/web/utils/outlook/msal-device-code.ts`** - Core MSAL logic to update with cache plugin integration and direct OAuth2 fallback

3. **`/Users/hack/github/inbox-zero/apps/web/utils/encryption.ts`** - Existing encryption utilities (no changes needed, reference for consistency)

4. **`/Users/hack/github/inbox-zero/apps/web/app/api/outlook/device-code/poll/route.ts`** - Persist MSAL cache after successful device-code authentication

5. **`/Users/hack/github/inbox-zero/apps/web/utils/outlook/msal-cache-plugin.ts`** (NEW) - ICachePlugin implementation for Prisma persistence

```
```
<tool_use_error>Error: No such tool available: Write</tool_use_error>
```
</details></tool-use>

_**Agent - sidechain (claude-opus-4-5-20251101 2026-01-24T04:10:44.735Z)**_

I understand - I'm in READ-ONLY mode and cannot write files. Let me provide the complete implementation plan directly in my response instead.

---

# MSAL Device-Code Token Persistence Implementation Plan

## Problem Statement

The inbox-zero MSAL device-code authentication flow discards refresh tokens and uses only an in-memory MSAL cache. This causes users to re-authenticate after:
- Server restarts
- Cache eviction
- Load balancer routing to a different instance
- Access token expiration (~1 hour) when MSAL cache is empty

**Current State (from `/Users/hack/github/inbox-zero/whats-next.md`):**
- Phase 1 (Complete): MSAL fallback in email client
- Phase 2 (Complete): `providerAccountId` passed through token chain
- Phase 3 (Not Started): **MSAL cache persistence - THIS PLAN**
- Phase 4 (Complete): Calendar device-code-connect uses stored token

---

## Solution Overview

Implement a database-backed MSAL token cache using the `ICachePlugin` interface, combined with a direct OAuth2 token endpoint refresh as fallback when MSAL cache is unavailable.

### Architecture Decision

| Option | Pros | Cons |
|--------|------|------|
| **A: MSAL ICachePlugin with Prisma (Recommended)** | Native MSAL integration, handles all token types, maintains MSAL's token lifecycle | More complex, requires understanding MSAL internals |
| **B: Direct OAuth2 token refresh fallback** | Simpler, bypasses MSAL complexity | Must extract refresh token from MSAL cache manually |

**Chosen Approach:** Hybrid - Implement ICachePlugin for primary persistence, with direct OAuth2 fallback for edge cases.

---

## Implementation Plan

### Phase 1: Database Schema Changes

**File:** `/Users/hack/github/inbox-zero/apps/web/prisma/schema.prisma`

Add two new fields to the `Account` model (around line 16-38):

```prisma
model Account {
  // ... existing fields ...
  
  // MSAL device-code flow cache persistence
  // Stores serialized MSAL token cache for accounts authenticated via device-code flow
  // This enables token refresh to survive server restarts
  msal_cache         String?       @db.Text
  msal_cache_updated DateTime?
}
```

**Rationale:**
- Adding to `Account` model keeps tokens with their owning account
- `@db.Text` handles the potentially large JSON blob (MSAL cache can be several KB)
- `msal_cache_updated` helps with debugging and cache invalidation
- No new table needed - simpler migration and query patterns

**Migration Command:**
```bash
npx prisma migrate dev --name add_msal_cache_to_account
```

---

### Phase 2: MSAL Cache Plugin Implementation

**New File:** `/Users/hack/github/inbox-zero/apps/web/utils/outlook/msal-cache-plugin.ts`

```typescript
/**
 * MSAL Token Cache Persistence Plugin
 * 
 * Implements ICachePlugin to persist MSAL's token cache to PostgreSQL.
 * This enables device-code authenticated accounts to refresh tokens
 * after server restarts.
 */

import type { ICachePlugin, TokenCacheContext } from "@azure/msal-node";
import prisma from "@/utils/prisma";
import { encryptToken, decryptToken } from "@/utils/encryption";
import { createScopedLogger } from "@/utils/logger";

const logger = createScopedLogger("msal-cache-plugin");

export function createPrismaCachePlugin(providerAccountId: string): ICachePlugin {
  return {
    async beforeCacheAccess(cacheContext: TokenCacheContext): Promise<void> {
      try {
        const account = await prisma.account.findFirst({
          where: { 
            provider: "microsoft",
            providerAccountId 
          },
          select: { msal_cache: true },
        });

        if (account?.msal_cache) {
          const decrypted = decryptToken(account.msal_cache);
          if (decrypted) {
            cacheContext.tokenCache.deserialize(decrypted);
            logger.info("Loaded MSAL cache from database", { providerAccountId });
          }
        }
      } catch (error) {
        logger.error("Failed to load MSAL cache", { 
          providerAccountId, 
          error: error instanceof Error ? error.message : String(error) 
        });
        // Don't throw - allow MSAL to continue with empty cache
      }
    },

    async afterCacheAccess(cacheContext: TokenCacheContext): Promise<void> {
      if (!cacheContext.cacheHasChanged) {
        return;
      }

      try {
        const serialized = cacheContext.tokenCache.serialize();
        const encrypted = encryptToken(serialized);

        await prisma.account.updateMany({
          where: { 
            provider: "microsoft",
            providerAccountId 
          },
          data: { 
            msal_cache: encrypted,
            msal_cache_updated: new Date(),
          },
        });

        logger.info("Persisted MSAL cache to database", { providerAccountId });
      } catch (error) {
        logger.error("Failed to persist MSAL cache", { 
          providerAccountId, 
          error: error instanceof Error ? error.message : String(error) 
        });
      }
    },
  };
}
```

---

### Phase 3: Update MSAL Application Factory

**File:** `/Users/hack/github/inbox-zero/apps/web/utils/outlook/msal-device-code.ts`

#### 3.1 Add imports at top of file:

```typescript
import type { Configuration } from "@azure/msal-node";
import { createPrismaCachePlugin } from "./msal-cache-plugin";
import { decryptToken } from "@/utils/encryption";
```

#### 3.2 Replace singleton `getMSALApp()` with factory pattern (around line 116-151):

```typescript
// Change from singleton to factory that can create per-account instances
const msalAppCache = new Map<string, PublicClientApplication>();

function getMSALApp(providerAccountId?: string): PublicClientApplication {
  // For initiation (no providerAccountId yet), use shared instance
  const cacheKey = providerAccountId || "default";
  
  if (msalAppCache.has(cacheKey)) {
    return msalAppCache.get(cacheKey)!;
  }

  const clientId = env.MSAL_CLIENT_ID || env.MICROSOFT_CLIENT_ID || MICROSOFT_OFFICE_CLIENT_ID;
  const tenantId = env.MSAL_TENANT_ID || env.MICROSOFT_TENANT_ID || "common";
  const debugEnabled = env.MSAL_DEBUG === "true";

  const config: Configuration = {
    auth: {
      clientId,
      authority: `https://login.microsoftonline.com/${tenantId}`,
    },
    system: {
      loggerOptions: {
        loggerCallback: (level: LogLevel, message: string, containsPii: boolean) => {
          if (containsPii) return;
          if (debugEnabled || level === LogLevel.Error) {
            logger.info(`MSAL [${LogLevel[level]}]: ${message}`);
          }
        },
        piiLoggingEnabled: false,
        logLevel: debugEnabled ? LogLevel.Verbose : LogLevel.Error,
      },
      networkClient: new CustomNetworkModule(),
    },
  };

  // Add cache plugin for known accounts
  if (providerAccountId) {
    config.cache = {
      cachePlugin: createPrismaCachePlugin(providerAccountId),
    };
  }

  const app = new PublicClientApplication(config);
  msalAppCache.set(cacheKey, app);
  
  return app;
}
```

#### 3.3 Update `acquireMSALTokenSilent()` function (around line 438-504):

```typescript
export async function acquireMSALTokenSilent(
  providerAccountId: string,
  scopes: string[] = MSAL_DEVICE_CODE_SCOPES,
): Promise<{
  accessToken: string;
  expiresAt: Date;
  account: AccountInfo;
} | null> {
  if (!isMSALDeviceCodeEnabled()) {
    logger.warn("MSAL device code flow is not enabled");
    return null;
  }

  // Use per-account MSAL instance with cache plugin
  const app = getMSALApp(providerAccountId);
  const tokenCache = app.getTokenCache();

  try {
    const accounts = await tokenCache.getAllAccounts();
    
    if (accounts.length === 0) {
      logger.info("No accounts found in MSAL cache, trying direct refresh", { providerAccountId });
      return await directTokenRefresh(providerAccountId, scopes);
    }

    const account = accounts.find(
      (acc: AccountInfo) => acc.localAccountId === providerAccountId,
    );

    if (!account) {
      logger.info("Account not found in MSAL cache", { providerAccountId });
      return await directTokenRefresh(providerAccountId, scopes);
    }

    const result = await app.acquireTokenSilent({ account, scopes });
    
    if (!result) {
      logger.warn("acquireTokenSilent returned null", { providerAccountId });
      return await directTokenRefresh(providerAccountId, scopes);
    }

    logger.info("Successfully acquired token silently", {
      providerAccountId,
      expiresOn: result.expiresOn?.toISOString(),
    });

    return {
      accessToken: result.accessToken,
      expiresAt: result.expiresOn || new Date(Date.now() + 3_600_000),
      account,
    };
  } catch (error) {
    logger.error("Failed to acquire token silently, trying direct refresh", {
      providerAccountId,
      error: error instanceof Error ? error.message : String(error),
    });
    return await directTokenRefresh(providerAccountId, scopes);
  }
}
```

---

### Phase 4: Direct OAuth2 Token Refresh Fallback

**File:** `/Users/hack/github/inbox-zero/apps/web/utils/outlook/msal-device-code.ts`

Add these new functions at the end of the file (before the final closing brace):

```typescript
/**
 * Extract refresh token from stored MSAL cache
 * Used as fallback when acquireTokenSilent fails
 */
async function extractRefreshTokenFromCache(
  providerAccountId: string
): Promise<string | null> {
  const account = await prisma.account.findFirst({
    where: { 
      provider: "microsoft",
      providerAccountId 
    },
    select: { msal_cache: true },
  });

  if (!account?.msal_cache) {
    return null;
  }

  try {
    const decrypted = decryptToken(account.msal_cache);
    if (!decrypted) return null;

    // MSAL cache JSON structure contains RefreshToken entries
    const cache = JSON.parse(decrypted);
    const refreshTokens = cache.RefreshToken || {};
    
    // Find refresh token for this account
    for (const key of Object.keys(refreshTokens)) {
      if (key.toLowerCase().includes(providerAccountId.toLowerCase())) {
        return refreshTokens[key].secret;
      }
    }

    // Fallback: return first available refresh token
    const firstToken = Object.values(refreshTokens)[0] as { secret?: string } | undefined;
    return firstToken?.secret || null;
  } catch (error) {
    logger.error("Failed to extract refresh token from cache", { 
      providerAccountId, 
      error: error instanceof Error ? error.message : String(error),
    });
    return null;
  }
}

/**
 * Direct OAuth2 token refresh using Microsoft token endpoint
 * Fallback for when MSAL silent acquisition fails but we have a stored refresh token
 */
async function directTokenRefresh(
  providerAccountId: string,
  scopes: string[] = MSAL_DEVICE_CODE_SCOPES,
): Promise<{
  accessToken: string;
  expiresAt: Date;
  account: AccountInfo;
} | null> {
  logger.info("Attempting direct token refresh", { providerAccountId });

  const refreshToken = await extractRefreshTokenFromCache(providerAccountId);
  
  if (!refreshToken) {
    logger.warn("No refresh token available for direct refresh", { providerAccountId });
    return null;
  }

  const clientId = env.MSAL_CLIENT_ID || env.MICROSOFT_CLIENT_ID || MICROSOFT_OFFICE_CLIENT_ID;
  const tenantId = env.MSAL_TENANT_ID || env.MICROSOFT_TENANT_ID || "common";

  try {
    const response = await fetch(
      `https://login.microsoftonline.com/${tenantId}/oauth2/v2.0/token`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
        },
        body: new URLSearchParams({
          client_id: clientId,
          refresh_token: refreshToken,
          grant_type: "refresh_token",
          scope: scopes.join(" "),
        }),
      },
    );

    const tokens = await response.json();

    if (!response.ok) {
      logger.error("Direct token refresh failed", {
        providerAccountId,
        error: tokens.error_description || tokens.error,
      });
      return null;
    }

    logger.info("Direct token refresh successful", { providerAccountId });

    // Update stored tokens in Account table
    const encryptedAccessToken = encryptToken(tokens.access_token);
    await prisma.account.updateMany({
      where: { provider: "microsoft", providerAccountId },
      data: {
        access_token: encryptedAccessToken,
        expires_at: new Date(Date.now() + tokens.expires_in * 1000),
      },
    });

    // If we got a new refresh token, update the MSAL cache
    if (tokens.refresh_token) {
      await updateRefreshTokenInCache(providerAccountId, tokens.refresh_token);
    }

    return {
      accessToken: tokens.access_token,
      expiresAt: new Date(Date.now() + tokens.expires_in * 1000),
      account: {
        localAccountId: providerAccountId,
        homeAccountId: providerAccountId,
        environment: "login.microsoftonline.com",
        tenantId: tenantId,
        username: "",
      } as AccountInfo,
    };
  } catch (error) {
    logger.error("Direct token refresh error", {
      providerAccountId,
      error: error instanceof Error ? error.message : String(error),
    });
    return null;
  }
}

/**
 * Update refresh token in stored MSAL cache
 */
async function updateRefreshTokenInCache(
  providerAccountId: string,
  newRefreshToken: string,
): Promise<void> {
  const account = await prisma.account.findFirst({
    where: { provider: "microsoft", providerAccountId },
    select: { msal_cache: true },
  });

  if (!account?.msal_cache) return;

  try {
    const decrypted = decryptToken(account.msal_cache);
    if (!decrypted) return;

    const cache = JSON.parse(decrypted);
    const refreshTokens = cache.RefreshToken || {};

    // Update existing refresh token entries
    for (const key of Object.keys(refreshTokens)) {
      if (key.toLowerCase().includes(providerAccountId.toLowerCase())) {
        refreshTokens[key].secret = newRefreshToken;
      }
    }

    cache.RefreshToken = refreshTokens;
    const encrypted = encryptToken(JSON.stringify(cache));

    await prisma.account.updateMany({
      where: { provider: "microsoft", providerAccountId },
      data: { 
        msal_cache: encrypted,
        msal_cache_updated: new Date(),
      },
    });
  } catch (error) {
    logger.error("Failed to update refresh token in cache", { 
      providerAccountId, 
      error: error instanceof Error ? error.message : String(error),
    });
  }
}
```

---

### Phase 5: Update Device Code Poll Endpoint

**File:** `/Users/hack/github/inbox-zero/apps/web/app/api/outlook/device-code/poll/route.ts`

#### 5.1 Add imports at top:

```typescript
import { getMSALApp } from "@/utils/outlook/msal-device-code";
```

#### 5.2 Update `completeDeviceCodeAuthentication` function (around line 219, after the account upsert):

Add this code block after the `prisma.account.upsert` call:

```typescript
  // After account is created, persist the MSAL cache for future token refresh
  try {
    const app = getMSALApp();
    const tokenCache = app.getTokenCache();
    const serializedCache = tokenCache.serialize();
    
    if (serializedCache) {
      const encryptedCache = encryptToken(serializedCache);
      await prisma.account.updateMany({
        where: { 
          provider: "microsoft", 
          providerAccountId 
        },
        data: { 
          msal_cache: encryptedCache,
          msal_cache_updated: new Date(),
        },
      });
      logger.info("Persisted initial MSAL cache", { providerAccountId });
    }
  } catch (error) {
    // Non-fatal - log but don't fail the auth flow
    logger.error("Failed to persist initial MSAL cache", { 
      providerAccountId,
      error: error instanceof Error ? error.message : String(error),
    });
  }
```

---

## Edge Cases and Error Handling

### Multi-Instance Deployment

**Problem:** Multiple server instances may have stale in-memory caches.

**Solution:** The `ICachePlugin.beforeCacheAccess` is called before every token operation, ensuring the latest cache is loaded from the database.

### Cache Invalidation

**Problem:** User revokes access or changes password at Microsoft.

**Solution:** 
1. Direct OAuth2 refresh will fail with specific error codes (AADSTS70008, AADSTS50173, etc.)
2. Existing error handling in `/Users/hack/github/inbox-zero/apps/web/utils/outlook/client.ts` (lines 182-232) already handles these errors
3. User will be prompted to re-authenticate

### Encryption Key Rotation

**Problem:** If `EMAIL_ENCRYPT_SECRET` or `EMAIL_ENCRYPT_SALT` change, cached tokens become unreadable.

**Solution:**
1. Existing encryption utilities in `/Users/hack/github/inbox-zero/apps/web/utils/encryption.ts` already handle decryption failures gracefully (return `null`)
2. When cache decryption fails, the direct OAuth2 refresh fallback will also fail
3. User must re-authenticate - document this in ops runbook

### Race Conditions

**Problem:** Concurrent requests may race to update the cache.

**Solution:**
1. MSAL's token cache is designed to handle concurrent access
2. The `cacheHasChanged` flag prevents unnecessary writes
3. Prisma's `updateMany` is atomic
4. Accept that in rare cases, slightly older cache may be persisted (acceptable trade-off)

---

## Testing Plan

### Manual Testing Checklist

1. [ ] Device-code login at `/login/device-code`
2. [ ] Verify `msal_cache` field populated in Account table
3. [ ] Verify email stats load on setup page
4. [ ] Navigate to calendars, connect Outlook calendar
5. [ ] Restart dev server (`pnpm dev`)
6. [ ] Return to app - verify still authenticated (token refresh works)
7. [ ] Wait 1+ hour (or manually expire access token in DB)
8. [ ] Verify token refresh works without re-authentication

### Verification Queries

```sql
-- Check if MSAL cache is being stored
SELECT providerAccountId, 
       msal_cache IS NOT NULL as has_cache,
       msal_cache_updated
FROM "Account"
WHERE provider = 'microsoft';
```

---

## Rollback Procedure

If issues arise:

1. **Quick Disable:** Set `MSAL_ENABLED=false` in environment
2. **Schema Rollback:** 
   ```bash
   npx prisma migrate rollback --target add_msal_cache_to_account
   ```
3. **Code Rollback:** `git revert` the commits from this implementation

---

## Summary of Changes

| File | Change Type | Description |
|------|-------------|-------------|
| `apps/web/prisma/schema.prisma` | Modify | Add `msal_cache` and `msal_cache_updated` fields |
| `apps/web/utils/outlook/msal-cache-plugin.ts` | New | ICachePlugin implementation |
| `apps/web/utils/outlook/msal-device-code.ts` | Modify | Update factory pattern, add fallback functions |
| `apps/web/app/api/outlook/device-code/poll/route.ts` | Modify | Persist cache after successful auth |

---

### Critical Files for Implementation

1. **`/Users/hack/github/inbox-zero/apps/web/prisma/schema.prisma`** - Add `msal_cache` and `msal_cache_updated` fields to Account model (around line 24-31)

2. **`/Users/hack/github/inbox-zero/apps/web/utils/outlook/msal-device-code.ts`** - Core MSAL logic to update with cache plugin integration, factory pattern, and direct OAuth2 fallback

3. **`/Users/hack/github/inbox-zero/apps/web/utils/encryption.ts`** - Existing encryption utilities (no changes needed, reference for `encryptToken`/`decryptToken` patterns)

4. **`/Users/hack/github/inbox-zero/apps/web/app/api/outlook/device-code/poll/route.ts`** - Persist MSAL cache after successful device-code authentication (around line 219)

5. **`/Users/hack/github/inbox-zero/apps/web/utils/outlook/msal-cache-plugin.ts`** (NEW FILE) - ICachePlugin implementation for Prisma persistence using the encryption utilities

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:10:56.176Z)**_

<think><details><summary>Thought Process</summary>
The Plan agent provided a comprehensive implementation plan. Now I need to update my plan file with this detailed implementation approach, then exit plan mode for user approval.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:10:56.644Z)**_

Excellent. Let me update the plan file with the detailed implementation approach from the Plan agent.

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:11:24.517Z)**_

<tool-use data-tool-type="write" data-tool-name="Edit"><details>
<summary>Tool use: **Edit**</summary>
```
The file /Users/hack/.claude/plans/cuddly-knitting-ember.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
   306→   - Add MSALCache model for persistent storage
   307→
   308→---
   309→
   310→## Verification Steps
   311→
   312→1. Authenticate via device-code flow
   313→2. Verify refresh token stored in database (encrypted)
   314→3. Restart server
   315→4. Verify token refresh works without re-authentication
   316→5. Wait for token expiry → verify automatic refresh
   317→6. Clear MSAL cache manually → verify direct refresh fallback works
   318→
   319→---
   320→
   321→## Detailed Implementation Plan
   322→
   323→### Phase 1: Database Schema Changes
   324→
   325→**File:** `apps/web/prisma/schema.prisma`
   326→
   327→Add two fields to the `Account` model:
   328→
   329→```prisma
   330→model Account {
   331→  // ... existing fields ...
   332→
   333→  // MSAL device-code flow cache persistence
   334→  msal_cache         String?       @db.Text
   335→  msal_cache_updated DateTime?
   336→}
   337→```
   338→
   339→**Migration:**
   340→```bash
   341→npx prisma migrate dev --name add_msal_cache_to_account
   342→```
   343→
   344→---
   345→
   346→### Phase 2: MSAL Cache Plugin
   347→
   348→**New File:** `apps/web/utils/outlook/msal-cache-plugin.ts`
   349→
   350→Implements `ICachePlugin` to persist MSAL's token cache to PostgreSQL:
   351→
   352→```typescript
   353→import type { ICachePlugin, TokenCacheContext } from "@azure/msal-node";
   354→import prisma from "@/utils/prisma";
   355→import { encryptToken, decryptToken } from "@/utils/encryption";
   356→
   357→export function createPrismaCachePlugin(providerAccountId: string): ICachePlugin {
   358→  return {
   359→    async beforeCacheAccess(cacheContext: TokenCacheContext): Promise<void> {
   360→      const account = await prisma.account.findFirst({
   361→        where: { provider: "microsoft", providerAccountId },
   362→        select: { msal_cache: true },
   363→      });
   364→      if (account?.msal_cache) {
   365→        const decrypted = decryptToken(account.msal_cache);
   366→        if (decrypted) cacheContext.tokenCache.deserialize(decrypted);
   367→      }
   368→    },
   369→
   370→    async afterCacheAccess(cacheContext: TokenCacheContext): Promise<void> {
   371→      if (!cacheContext.cacheHasChanged) return;
   372→      const serialized = cacheContext.tokenCache.serialize();
   373→      const encrypted = encryptToken(serialized);
   374→      await prisma.account.updateMany({
   375→        where: { provider: "microsoft", providerAccountId },
   376→        data: { msal_cache: encrypted, msal_cache_updated: new Date() },
   377→      });
   378→    },
   379→  };
   380→}
   381→```
   382→
   383→---
   384→
   385→### Phase 3: Update MSAL Application Factory
   386→
   387→**File:** `apps/web/utils/outlook/msal-device-code.ts`
   388→
   389→Replace singleton with factory pattern that creates per-account instances with cache plugins:
   390→
   391→```typescript
   392→const msalAppCache = new Map<string, PublicClientApplication>();
   393→
   394→function getMSALApp(providerAccountId?: string): PublicClientApplication {
   395→  const cacheKey = providerAccountId || "default";
   396→  if (msalAppCache.has(cacheKey)) return msalAppCache.get(cacheKey)!;
   397→
   398→  const config: Configuration = {
   399→    auth: { clientId, authority },
   400→    system: { loggerOptions, networkClient: new CustomNetworkModule() },
   401→  };
   402→
   403→  // Add cache plugin for known accounts
   404→  if (providerAccountId) {
   405→    config.cache = { cachePlugin: createPrismaCachePlugin(providerAccountId) };
   406→  }
   407→
   408→  const app = new PublicClientApplication(config);
   409→  msalAppCache.set(cacheKey, app);
   410→  return app;
   411→}
   412→```
   413→
   414→---
   415→
   416→### Phase 4: Direct OAuth2 Token Refresh Fallback
   417→
   418→**File:** `apps/web/utils/outlook/msal-device-code.ts`
   419→
   420→Add fallback when MSAL silent acquisition fails:
   421→
   422→```typescript
   423→async function directTokenRefresh(
   424→  providerAccountId: string,
   425→  scopes: string[] = MSAL_DEVICE_CODE_SCOPES,
   426→): Promise<TokenResult | null> {
   427→  const refreshToken = await extractRefreshTokenFromCache(providerAccountId);
   428→  if (!refreshToken) return null;
   429→
   430→  const response = await fetch(
   431→    `https://login.microsoftonline.com/${tenantId}/oauth2/v2.0/token`,
   432→    {
   433→      method: "POST",
   434→      headers: { "Content-Type": "application/x-www-form-urlencoded" },
   435→      body: new URLSearchParams({
   436→        client_id: clientId,
   437→        refresh_token: refreshToken,
   438→        grant_type: "refresh_token",
   439→        scope: scopes.join(" "),
   440→      }),
   441→    },
   442→  );
   443→
   444→  const tokens = await response.json();
   445→  if (!response.ok) return null;
   446→
   447→  // Update stored tokens
   448→  await prisma.account.updateMany({
   449→    where: { provider: "microsoft", providerAccountId },
   450→    data: {
   451→      access_token: encryptToken(tokens.access_token),
   452→      expires_at: new Date(Date.now() + tokens.expires_in * 1000),
   453→    },
   454→  });
   455→
   456→  return { accessToken: tokens.access_token, expiresAt: new Date(...) };
   457→}
   458→```
   459→
   460→---
   461→
   462→### Phase 5: Update Silent Token Acquisition
   463→
   464→**File:** `apps/web/utils/outlook/msal-device-code.ts`
   465→
   466→Update `acquireMSALTokenSilent()` to use direct fallback:
   467→
   468→```typescript
   469→export async function acquireMSALTokenSilent(providerAccountId: string, scopes: string[]) {
   470→  const app = getMSALApp(providerAccountId); // Uses cache plugin
   471→  const accounts = await app.getTokenCache().getAllAccounts();
   472→
   473→  if (accounts.length === 0) {
   474→    return await directTokenRefresh(providerAccountId, scopes); // Fallback
   475→  }
   476→
   477→  const account = accounts.find(a => a.localAccountId === providerAccountId);
   478→  if (!account) return await directTokenRefresh(providerAccountId, scopes);
   479→
   480→  try {
   481→    const result = await app.acquireTokenSilent({ account, scopes });
   482→    return result ? { accessToken: result.accessToken, ... } : null;
   483→  } catch (error) {
   484→    return await directTokenRefresh(providerAccountId, scopes); // Fallback
   485→  }
   486→}
   487→```
   488→
   489→---
   490→
   491→### Phase 6: Persist Cache After Initial Auth
   492→
   493→**File:** `apps/web/app/api/outlook/device-code/poll/route.ts`
   494→
   495→After account creation in `completeDeviceCodeAuthentication()`:
   496→
   497→```typescript
   498→// Persist the MSAL cache for future token refresh
   499→const app = getMSALApp();
   500→const serializedCache = app.getTokenCache().serialize();
   501→if (serializedCache) {
   502→  await prisma.account.updateMany({
   503→    where: { provider: "microsoft", providerAccountId },
   504→    data: {
   505→      msal_cache: encryptToken(serializedCache),
   506→      msal_cache_updated: new Date(),
   507→    },
   508→  });
   509→}
   510→```
   511→
   512→---
   513→
   514→## Files to Modify Summary
   515→
   516→| File | Action | Purpose |
   517→|------|--------|---------|
   518→| `prisma/schema.prisma` | Modify | Add `msal_cache` fields |
   519→| `utils/outlook/msal-cache-plugin.ts` | Create | ICachePlugin implementation |
   520→| `utils/outlook/msal-device-code.ts` | Modify | Factory pattern + direct refresh fallback |
   521→| `api/outlook/device-code/poll/route.ts` | Modify | Persist cache after auth |
   522→
   523→---
   524→
   525→## Testing Checklist
   526→
   527→1. [ ] Device-code login at `/login/device-code`
   528→2. [ ] Verify `msal_cache` populated in Account table
   529→3. [ ] Email stats load on setup page
   530→4. [ ] Connect Outlook calendar successfully
   531→5. [ ] Restart dev server → still authenticated
   532→6. [ ] Wait 1+ hour or manually expire token → automatic refresh works
   533→7. [ ] Clear MSAL in-memory cache → direct refresh fallback works
   534→
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:11:34.433Z)**_

<think><details><summary>Thought Process</summary>
The plan file now contains a comprehensive gap analysis and detailed implementation plan. Let me exit plan mode to request user approval.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:11:41.811Z)**_

The plan is complete. Here's a summary of the audit findings:

## MSAL Device-Code Flow Audit Summary

### Critical Gap Identified
The current inbox-zero implementation **discards refresh tokens** and uses only an in-memory MSAL cache. This means users must re-authenticate after server restarts or when the access token expires (~1 hour).

### Root Cause
In `poll/route.ts`, the code explicitly sets `refresh_token: null`:
```typescript
create: {
  refresh_token: null, // MSAL doesn't expose refresh token
```

However, MSAL **does** provide refresh tokens - they're stored in the token cache, not the `AuthenticationResult` object.

### Solution (6 phases)
1. **Schema Changes** - Add `msal_cache` field to Account model
2. **Cache Plugin** - Implement MSAL's `ICachePlugin` to persist to Postgres
3. **Factory Pattern** - Create per-account MSAL instances with cache plugins
4. **Direct Fallback** - Add OAuth2 token endpoint refresh when MSAL cache empty
5. **Update Acquisition** - Integrate fallback into `acquireMSALTokenSilent()`
6. **Persist on Auth** - Store MSAL cache after initial device-code authentication

### Files to Modify
- `prisma/schema.prisma` - Add fields
- `utils/outlook/msal-cache-plugin.ts` - New file
- `utils/outlook/msal-device-code.ts` - Major refactor
- `api/outlook/device-code/poll/route.ts` - Persist cache

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:11:41.947Z)**_

<tool-use data-tool-type="generic" data-tool-name="ExitPlanMode"><details>
<summary>Tool use: **ExitPlanMode**</summary>
```
User has approved your plan. You can now start coding. Start with updating your todo list if applicable

Your plan has been saved to: /Users/hack/.claude/plans/cuddly-knitting-ember.md
You can refer back to it if needed during implementation.

## Approved Plan:
# MSAL Device-Code Flow Audit: Gap Analysis

## Executive Summary

The inbox-zero MSAL device-code implementation has a **critical architectural gap**: it lacks persistent token storage, making it unsuitable for production use. When the server restarts or the in-memory MSAL cache clears, users must re-authenticate.

---

## Reference Implementation (outlook-creds)

The reference implementation demonstrates production-ready patterns:

### Token Storage Architecture
```
~/.config/outlook-creds/tokens/
├── {email}_refresh_only.txt        # Persistent refresh token
├── {email}_access_token.json       # Structured: {access_token, expires_at, scopes}
└── {email}_access_only.txt         # Raw access token for quick reads
```

### Key Patterns
1. **Persistent refresh token storage** - survives process restarts
2. **Direct token endpoint refresh** - uses OAuth2 `/token` endpoint with `grant_type=refresh_token`
3. **Pre-check validation** - validates token expiry before API calls
4. **Multi-format storage** - JSON for metadata, raw text for quick access

### Token Refresh Flow (reference)
```bash
# refresh_access_token.sh pattern
curl -X POST "https://login.microsoftonline.com/common/oauth2/v2.0/token" \
  -d "client_id=${CLIENT_ID}" \
  -d "grant_type=refresh_token" \
  -d "refresh_token=${refresh_token}" \
  -d "scope=https://graph.microsoft.com/.default"
```

---

## Current inbox-zero Implementation

### Architecture Overview
| Component | File | Purpose |
|-----------|------|---------|
| MSAL Core | `utils/outlook/msal-device-code.ts` | Device code flow, silent acquisition |
| Poll Route | `api/outlook/device-code/poll/route.ts` | Session creation, account storage |
| Email Client | `utils/outlook/client.ts` | Token refresh for email operations |
| Calendar Client | `utils/outlook/calendar-client.ts` | Token refresh for calendar operations |

### Token Flow Trace
1. User initiates device-code flow → `initiateDeviceCodeFlow()`
2. MSAL returns `{access_token, refresh_token, account}`
3. **Account stored**: `refresh_token: null` in database (intentionally omitted)
4. **Access token stored**: Encrypted in `Account.access_token`
5. **MSAL cache**: Account info stored in-memory only
6. Token refresh via `acquireTokenSilent(providerAccountId)` - **requires account in cache**

---

## Critical Gaps Identified

### Gap 1: No Refresh Token Persistence ⚠️ CRITICAL

**Reference:**
```python
# oauth.py - saves refresh token to persistent storage
if msal_result.get("refresh_token"):
    refresh_file = TOKENS_DIR / f"{email}_refresh_only.txt"
    secure_write_token(refresh_file, msal_result["refresh_token"])
```

**inbox-zero:**
```typescript
// poll/route.ts line ~95 - explicitly sets null
const accountRecord = await prisma.account.upsert({
  // ...
  create: {
    refresh_token: null, // MSAL doesn't expose refresh token
    // ...
  },
});
```

**Impact:** MSAL **does** return a refresh token, but inbox-zero discards it. This is the root cause of token expiration issues.

### Gap 2: In-Memory MSAL Cache Only ⚠️ CRITICAL

**Reference:**
- Stores tokens to disk files
- Survives process restarts
- Can be shared across instances

**inbox-zero:**
```typescript
// msal-device-code.ts - singleton in-memory only
let msalApp: PublicClientApplication | null = null;

function getMSALApp(): PublicClientApplication {
  if (!msalApp) {
    msalApp = new PublicClientApplication({
      // Uses default in-memory cache
    });
  }
  return msalApp;
}
```

**Impact:** Server restart = MSAL cache cleared = `acquireTokenSilent()` fails = users must re-authenticate.

### Gap 3: Silent Acquisition Dependency ⚠️ HIGH

**Current refresh path:**
```typescript
// client.ts - requires MSAL cache to have account
const msalResult = await acquireMSALTokenSilent(providerAccountId);
if (!msalResult) {
  throw new SafeError("Authentication expired. Please log in again...");
}
```

**Reference approach:**
```bash
# Uses stored refresh token directly - no cache dependency
curl -X POST "$TOKEN_ENDPOINT" -d "refresh_token=${stored_refresh_token}"
```

**Impact:** inbox-zero has no fallback when MSAL cache misses.

### Gap 4: No Direct Token Endpoint Refresh ⚠️ HIGH

**Reference has:**
```python
def acquire_outlook_token_via_refresh(refresh_token, params):
    token_endpoint = f"https://login.microsoftonline.com/{tenant_id}/oauth2/v2.0/token"
    data = {
        "client_id": params["client_id"],
        "grant_type": "refresh_token",
        "refresh_token": refresh_token,
        "scope": "https://graph.microsoft.com/.default",
    }
    # Direct HTTP call to token endpoint
```

**inbox-zero lacks:** Any direct token endpoint refresh capability. Relies entirely on MSAL's `acquireTokenSilent()`.

### Gap 5: Token Expiry Pre-validation ⚠️ MEDIUM

**Reference:**
```bash
is_token_valid() {
    local expires_at=$(jq -r '.expires_at' "$token_file")
    local expires_epoch=$(date -jf "%Y-%m-%dT%H:%M:%SZ" "$expires_at" +%s)
    [[ $((expires_epoch - 60)) -gt $(date +%s) ]]
}
```

**inbox-zero:** Has partial validation but inconsistent buffer times (10 min vs 5 min in different files).

---

## What inbox-zero Does Well

1. **Custom Network Module** - Handles Node.js 22+ undici issues
2. **Non-blocking Polling** - Uses `Promise.race` for responsive polling
3. **Encrypted Token Storage** - Access tokens encrypted in database
4. **Session Integration** - Proper Better Auth session creation
5. **Feature Flagging** - Clean `MSAL_ENABLED` toggle
6. **Provider Context** - `isDeviceCodeAuth` flag for UI differentiation

---

## Recommended Fixes

### Fix 1: Store Refresh Token (CRITICAL)

```typescript
// poll/route.ts - Store the refresh token from MSAL result
const accountRecord = await prisma.account.upsert({
  create: {
    // ...
    refresh_token: pollResult.result.account
      ? encryptToken(getRefreshTokenFromMSAL())
      : null,
  },
});
```

**Challenge:** MSAL Node.js doesn't expose `refresh_token` in `AuthenticationResult`. Need to:
- Access token cache directly, OR
- Use custom cache plugin to intercept tokens

### Fix 2: Implement Persistent MSAL Cache

```typescript
// Option A: Custom cache plugin
import { ICachePlugin } from "@azure/msal-node";

class PrismaCachePlugin implements ICachePlugin {
  async beforeCacheAccess(context) {
    const cache = await prisma.msalCache.findFirst({ where: { key: "default" } });
    if (cache) context.tokenCache.deserialize(cache.data);
  }

  async afterCacheAccess(context) {
    if (context.cacheHasChanged) {
      await prisma.msalCache.upsert({
        where: { key: "default" },
        update: { data: context.tokenCache.serialize() },
        create: { key: "default", data: context.tokenCache.serialize() },
      });
    }
  }
}
```

### Fix 3: Direct Token Endpoint Fallback

```typescript
// New function in msal-device-code.ts
async function refreshTokenDirectly(
  refreshToken: string,
  scopes: string[] = ["https://graph.microsoft.com/.default"]
): Promise<TokenResponse | null> {
  const clientId = env.MSAL_CLIENT_ID || MICROSOFT_OFFICE_CLIENT_ID;
  const tokenEndpoint = `https://login.microsoftonline.com/common/oauth2/v2.0/token`;

  const params = new URLSearchParams({
    client_id: clientId,
    grant_type: "refresh_token",
    refresh_token: refreshToken,
    scope: scopes.join(" "),
  });

  const response = await fetch(tokenEndpoint, {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body: params.toString(),
  });

  return response.json();
}
```

### Fix 4: Unified Token Refresh Strategy

```typescript
// client.ts - enhanced refresh logic
async function getTokenForDeviceCodeAccount(providerAccountId: string): Promise<string> {
  // 1. Try MSAL silent acquisition
  const msalResult = await acquireMSALTokenSilent(providerAccountId);
  if (msalResult) return msalResult.accessToken;

  // 2. Fallback: Direct token endpoint with stored refresh token
  const account = await prisma.account.findFirst({
    where: { providerAccountId },
    select: { refresh_token: true },
  });

  if (account?.refresh_token) {
    const decrypted = decryptToken(account.refresh_token);
    const result = await refreshTokenDirectly(decrypted);
    if (result?.access_token) {
      // Update stored tokens
      await updateAccountTokens(providerAccountId, result);
      return result.access_token;
    }
  }

  // 3. No options left - require re-authentication
  throw new SafeError("Authentication expired. Please log in again.");
}
```

---

## Implementation Priority

| Priority | Fix | Effort | Impact |
|----------|-----|--------|--------|
| P0 | Store refresh token from MSAL | Medium | Enables all other fixes |
| P0 | Implement persistent MSAL cache | High | Survives restarts |
| P1 | Direct token endpoint fallback | Medium | Recovery when cache empty |
| P2 | Unified refresh strategy | Low | Better UX |
| P3 | Consistent expiry buffer times | Low | Edge case improvement |

---

## Files to Modify

1. **`utils/outlook/msal-device-code.ts`**
   - Add persistent cache plugin
   - Add direct token refresh function
   - Extract refresh token from MSAL cache

2. **`app/api/outlook/device-code/poll/route.ts`**
   - Store refresh token in database
   - Update account creation logic

3. **`utils/outlook/client.ts`**
   - Add fallback refresh path
   - Unified token acquisition

4. **`utils/outlook/calendar-client.ts`**
   - Same fallback refresh path

5. **New: `prisma/schema.prisma`** (if using DB cache)
   - Add MSALCache model for persistent storage

---

## Verification Steps

1. Authenticate via device-code flow
2. Verify refresh token stored in database (encrypted)
3. Restart server
4. Verify token refresh works without re-authentication
5. Wait for token expiry → verify automatic refresh
6. Clear MSAL cache manually → verify direct refresh fallback works

---

## Detailed Implementation Plan

### Phase 1: Database Schema Changes

**File:** `apps/web/prisma/schema.prisma`

Add two fields to the `Account` model:

```prisma
model Account {
  // ... existing fields ...

  // MSAL device-code flow cache persistence
  msal_cache         String?       @db.Text
  msal_cache_updated DateTime?
}
```

**Migration:**
```bash
npx prisma migrate dev --name add_msal_cache_to_account
```

---

### Phase 2: MSAL Cache Plugin

**New File:** `apps/web/utils/outlook/msal-cache-plugin.ts`

Implements `ICachePlugin` to persist MSAL's token cache to PostgreSQL:

```typescript
import type { ICachePlugin, TokenCacheContext } from "@azure/msal-node";
import prisma from "@/utils/prisma";
import { encryptToken, decryptToken } from "@/utils/encryption";

export function createPrismaCachePlugin(providerAccountId: string): ICachePlugin {
  return {
    async beforeCacheAccess(cacheContext: TokenCacheContext): Promise<void> {
      const account = await prisma.account.findFirst({
        where: { provider: "microsoft", providerAccountId },
        select: { msal_cache: true },
      });
      if (account?.msal_cache) {
        const decrypted = decryptToken(account.msal_cache);
        if (decrypted) cacheContext.tokenCache.deserialize(decrypted);
      }
    },

    async afterCacheAccess(cacheContext: TokenCacheContext): Promise<void> {
      if (!cacheContext.cacheHasChanged) return;
      const serialized = cacheContext.tokenCache.serialize();
      const encrypted = encryptToken(serialized);
      await prisma.account.updateMany({
        where: { provider: "microsoft", providerAccountId },
        data: { msal_cache: encrypted, msal_cache_updated: new Date() },
      });
    },
  };
}
```

---

### Phase 3: Update MSAL Application Factory

**File:** `apps/web/utils/outlook/msal-device-code.ts`

Replace singleton with factory pattern that creates per-account instances with cache plugins:

```typescript
const msalAppCache = new Map<string, PublicClientApplication>();

function getMSALApp(providerAccountId?: string): PublicClientApplication {
  const cacheKey = providerAccountId || "default";
  if (msalAppCache.has(cacheKey)) return msalAppCache.get(cacheKey)!;

  const config: Configuration = {
    auth: { clientId, authority },
    system: { loggerOptions, networkClient: new CustomNetworkModule() },
  };

  // Add cache plugin for known accounts
  if (providerAccountId) {
    config.cache = { cachePlugin: createPrismaCachePlugin(providerAccountId) };
  }

  const app = new PublicClientApplication(config);
  msalAppCache.set(cacheKey, app);
  return app;
}
```

---

### Phase 4: Direct OAuth2 Token Refresh Fallback

**File:** `apps/web/utils/outlook/msal-device-code.ts`

Add fallback when MSAL silent acquisition fails:

```typescript
async function directTokenRefresh(
  providerAccountId: string,
  scopes: string[] = MSAL_DEVICE_CODE_SCOPES,
): Promise<TokenResult | null> {
  const refreshToken = await extractRefreshTokenFromCache(providerAccountId);
  if (!refreshToken) return null;

  const response = await fetch(
    `https://login.microsoftonline.com/${tenantId}/oauth2/v2.0/token`,
    {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: new URLSearchParams({
        client_id: clientId,
        refresh_token: refreshToken,
        grant_type: "refresh_token",
        scope: scopes.join(" "),
      }),
    },
  );

  const tokens = await response.json();
  if (!response.ok) return null;

  // Update stored tokens
  await prisma.account.updateMany({
    where: { provider: "microsoft", providerAccountId },
    data: {
      access_token: encryptToken(tokens.access_token),
      expires_at: new Date(Date.now() + tokens.expires_in * 1000),
    },
  });

  return { accessToken: tokens.access_token, expiresAt: new Date(...) };
}
```

---

### Phase 5: Update Silent Token Acquisition

**File:** `apps/web/utils/outlook/msal-device-code.ts`

Update `acquireMSALTokenSilent()` to use direct fallback:

```typescript
export async function acquireMSALTokenSilent(providerAccountId: string, scopes: string[]) {
  const app = getMSALApp(providerAccountId); // Uses cache plugin
  const accounts = await app.getTokenCache().getAllAccounts();

  if (accounts.length === 0) {
    return await directTokenRefresh(providerAccountId, scopes); // Fallback
  }

  const account = accounts.find(a => a.localAccountId === providerAccountId);
  if (!account) return await directTokenRefresh(providerAccountId, scopes);

  try {
    const result = await app.acquireTokenSilent({ account, scopes });
    return result ? { accessToken: result.accessToken, ... } : null;
  } catch (error) {
    return await directTokenRefresh(providerAccountId, scopes); // Fallback
  }
}
```

---

### Phase 6: Persist Cache After Initial Auth

**File:** `apps/web/app/api/outlook/device-code/poll/route.ts`

After account creation in `completeDeviceCodeAuthentication()`:

```typescript
// Persist the MSAL cache for future token refresh
const app = getMSALApp();
const serializedCache = app.getTokenCache().serialize();
if (serializedCache) {
  await prisma.account.updateMany({
    where: { provider: "microsoft", providerAccountId },
    data: {
      msal_cache: encryptToken(serializedCache),
      msal_cache_updated: new Date(),
    },
  });
}
```

---

## Files to Modify Summary

| File | Action | Purpose |
|------|--------|---------|
| `prisma/schema.prisma` | Modify | Add `msal_cache` fields |
| `utils/outlook/msal-cache-plugin.ts` | Create | ICachePlugin implementation |
| `utils/outlook/msal-device-code.ts` | Modify | Factory pattern + direct refresh fallback |
| `api/outlook/device-code/poll/route.ts` | Modify | Persist cache after auth |

---

## Testing Checklist

1. [ ] Device-code login at `/login/device-code`
2. [ ] Verify `msal_cache` populated in Account table
3. [ ] Email stats load on setup page
4. [ ] Connect Outlook calendar successfully
5. [ ] Restart dev server → still authenticated
6. [ ] Wait 1+ hour or manually expire token → automatic refresh works
7. [ ] Clear MSAL in-memory cache → direct refresh fallback works
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:16:08.129Z)**_

<think><details><summary>Thought Process</summary>
The user has approved the plan. Now I need to implement the fix. Let me create a task list to track the implementation phases and start working.

Let me:
1. Create tasks for the 6 implementation phases
2. Start with Phase 1 - Database Schema Changes
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:16:08.635Z)**_

The plan is approved. Let me create a task list to track implementation and begin work.

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:16:10.563Z)**_

<tool-use data-tool-type="unknown" data-tool-name="TaskCreate"><details>
<summary>Tool use: **TaskCreate**</summary>
Add msal_cache (String? @db.Text) and msal_cache_updated (DateTime?) fields to the Account model in prisma/schema.prisma. Run migration after.
```
Task #5 created successfully: Add msal_cache fields to Account schema
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:16:11.490Z)**_

<tool-use data-tool-type="unknown" data-tool-name="TaskCreate"><details>
<summary>Tool use: **TaskCreate**</summary>
Create utils/outlook/msal-cache-plugin.ts implementing ICachePlugin interface for Prisma persistence. Uses beforeCacheAccess to load from DB and afterCacheAccess to save changes.
```
Task #4 created successfully: Create MSAL cache plugin
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:16:13.321Z)**_

<tool-use data-tool-type="unknown" data-tool-name="TaskCreate"><details>
<summary>Tool use: **TaskCreate**</summary>
Replace singleton getMSALApp() with factory pattern that creates per-account instances with cache plugins when providerAccountId is provided.
```
Task #6 created successfully: Update MSAL app factory pattern
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:16:14.772Z)**_

<tool-use data-tool-type="unknown" data-tool-name="TaskCreate"><details>
<summary>Tool use: **TaskCreate**</summary>
Add directTokenRefresh() and extractRefreshTokenFromCache() functions to msal-device-code.ts for fallback when MSAL silent acquisition fails.
```
Task #2 created successfully: Add direct OAuth2 token refresh fallback
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:16:15.770Z)**_

<tool-use data-tool-type="unknown" data-tool-name="TaskCreate"><details>
<summary>Tool use: **TaskCreate**</summary>
Modify acquireMSALTokenSilent() to call directTokenRefresh() when MSAL cache is empty or silent acquisition fails.
```
Task #3 created successfully: Update acquireMSALTokenSilent with fallback
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:16:17.487Z)**_

<tool-use data-tool-type="unknown" data-tool-name="TaskCreate"><details>
<summary>Tool use: **TaskCreate**</summary>
Update poll/route.ts completeDeviceCodeAuthentication() to serialize and store MSAL cache to database after successful device-code authentication.
```
Task #1 created successfully: Persist MSAL cache after initial auth
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:16:35.839Z)**_

<think><details><summary>Thought Process</summary>
Now let me set up the task dependencies and start on the first task - adding the schema changes.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:16:36.423Z)**_

<tool-use data-tool-type="unknown" data-tool-name="TaskUpdate"><details>
<summary>Tool use: **TaskUpdate**</summary>
```
Updated task #4 blockedBy
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:16:36.843Z)**_

<tool-use data-tool-type="unknown" data-tool-name="TaskUpdate"><details>
<summary>Tool use: **TaskUpdate**</summary>
```
Updated task #6 blockedBy
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:16:37.215Z)**_

<tool-use data-tool-type="unknown" data-tool-name="TaskUpdate"><details>
<summary>Tool use: **TaskUpdate**</summary>
```
Updated task #2 blockedBy
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:16:37.677Z)**_

<tool-use data-tool-type="unknown" data-tool-name="TaskUpdate"><details>
<summary>Tool use: **TaskUpdate**</summary>
```
Updated task #3 blockedBy
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:16:38.114Z)**_

<tool-use data-tool-type="unknown" data-tool-name="TaskUpdate"><details>
<summary>Tool use: **TaskUpdate**</summary>
```
Updated task #1 blockedBy
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:16:38.556Z)**_

<tool-use data-tool-type="unknown" data-tool-name="TaskUpdate"><details>
<summary>Tool use: **TaskUpdate**</summary>
```
Updated task #5 status
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:16:47.425Z)**_

<think><details><summary>Thought Process</summary>
Now let me start implementing. First, I need to read the Prisma schema file to understand the current Account model structure.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:16:47.841Z)**_

Let me read the Prisma schema to add the new fields.

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:16:48.637Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./apps/web/prisma/schema.prisma`
```
     1→datasource db {
     2→  provider  = "postgresql"
     3→  url       = env("DATABASE_URL")
     4→  directUrl = env("DIRECT_URL")
     5→}
     6→
     7→generator client {
     8→  provider               = "prisma-client"
     9→  output                 = "../generated/prisma"
    10→  engineType             = "client"
    11→  generatedFileExtension = "ts"
    12→  importFileExtension    = "ts"
    13→}
    14→
    15→// Account, User, Session, and VerificationToken based on: https://authjs.dev/reference/adapter/prisma
    16→model Account {
    17→  id                    String        @id @default(cuid())
    18→  createdAt             DateTime      @default(now())
    19→  updatedAt             DateTime      @updatedAt
    20→  userId                String
    21→  provider              String
    22→  type                  String        @default("oidc") // next-auth deprecated field
    23→  providerAccountId     String
    24→  refresh_token         String?       @db.Text
    25→  refreshTokenExpiresAt DateTime?
    26→  access_token          String?       @db.Text
    27→  expires_at            DateTime?     @default(now())
    28→  disconnectedAt        DateTime? // When OAuth tokens were invalidated (password change, revoked access)
    29→  token_type            String?
    30→  scope                 String?
    31→  id_token              String?       @db.Text
    32→  session_state         String?
    33→  user                  User          @relation(fields: [userId], references: [id], onDelete: Cascade)
    34→  emailAccount          EmailAccount?
    35→
    36→  @@unique([provider, providerAccountId])
    37→  @@index([userId])
    38→}
    39→
    40→// not in use. we only use jwt for sessions
    41→model Session {
    42→  id           String   @id @default(cuid())
    43→  sessionToken String   @unique
    44→  userId       String
    45→  expires      DateTime
    46→  createdAt    DateTime @default(now())
    47→  updatedAt    DateTime @updatedAt
    48→  ipAddress    String?
    49→  userAgent    String?
    50→  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
    51→
    52→  activeOrganizationId String?
    53→  activeOrganization   Organization? @relation(fields: [activeOrganizationId], references: [id], onDelete: SetNull)
    54→
    55→  @@index([userId])
    56→  @@index([activeOrganizationId])
    57→}
    58→
    59→model User {
    60→  id            String    @id @default(cuid())
    61→  createdAt     DateTime  @default(now())
    62→  updatedAt     DateTime  @updatedAt
    63→  name          String?
    64→  email         String    @unique
    65→  emailVerified Boolean?  @default(false)
    66→  image         String?
    67→  accounts      Account[]
    68→  sessions      Session[]
    69→
    70→  // additional fields
    71→  completedOnboardingAt    DateTime? // questions about the user. e.g. their role
    72→  completedAppOnboardingAt DateTime? // how to use the app
    73→  onboardingAnswers        Json?
    74→  lastLogin                DateTime?
    75→  utms                     Json?
    76→  errorMessages            Json? // eg. user set incorrect AI API key
    77→
    78→  // survey answers (extracted from onboardingAnswers for easier querying)
    79→  surveyFeatures     String[] // multiple choice: features user is interested in
    80→  surveyRole         String? // single choice: user's role. Now using `EmailAccount.role` instead
    81→  surveyGoal         String? // single choice: what user wants to achieve
    82→  surveyCompanySize  Int? // numeric company size: 1 (solo), 5 (2-10), 50 (11-100), 500 (101-1000), 1000 (1000+)
    83→  surveySource       String? // single choice: how user heard about Inbox Zero
    84→  surveyImprovements String? // open text: what user wants to improve
    85→
    86→  // settings
    87→  aiProvider    String?
    88→  aiModel       String?
    89→  aiApiKey      String?
    90→  webhookSecret String?
    91→
    92→  // referral system
    93→  referralCode String? @unique // User's own referral code
    94→
    95→  // premium can be shared among multiple users
    96→  premiumId      String?
    97→  premium        Premium? @relation(name: "userPremium", fields: [premiumId], references: [id])
    98→  // only admin users can manage premium
    99→  premiumAdminId String?
   100→  premiumAdmin   Premium? @relation(fields: [premiumAdminId], references: [id])
   101→
   102→  apiKeys ApiKey[]
   103→
   104→  emailAccounts EmailAccount[]
   105→
   106→  // Referral relationships
   107→  referralsMade    Referral[] @relation("ReferrerUser")
   108→  referralReceived Referral?  @relation("ReferredUser")
   109→}
   110→
   111→// Migrating over to the new settings model. Currently most settings are in the User model, but will be moved to this model in the future.
   112→model EmailAccount {
   113→  id        String   @id @default(cuid())
   114→  email     String   @unique
   115→  createdAt DateTime @default(now())
   116→  updatedAt DateTime @updatedAt
   117→
   118→  name  String? // Name associated with the Google account
   119→  image String? // Profile image URL from the Google account
   120→
   121→  about                          String?
   122→  writingStyle                   String?
   123→  signature                      String? // User's email signature from provider or manually set
   124→  includeReferralSignature       Boolean   @default(false)
   125→  watchEmailsExpirationDate      DateTime?
   126→  watchEmailsSubscriptionId      String? // For Outlook subscription ID
   127→  watchEmailsSubscriptionHistory Json? // Historical Outlook subscription IDs: [{ subscriptionId, createdAt, replacedAt }]
   128→  lastSyncedHistoryId            String?
   129→  behaviorProfile                Json?
   130→  personaAnalysis                Json? // ai analysis of the user's persona
   131→  role                           String? // the role confirmed by the user - previously `User.surveyRole`
   132→  timezone                       String? // User's timezone (IANA tz database format, e.g., "America/Los_Angeles", "Asia/Jerusalem") - handles DST automatically
   133→  calendarBookingLink            String? // User's calendar booking link
   134→
   135→  statsEmailFrequency       Frequency         @default(WEEKLY)
   136→  summaryEmailFrequency     Frequency         @default(WEEKLY)
   137→  lastSummaryEmailAt        DateTime?
   138→  coldEmailBlocker          ColdEmailSetting? // @deprecated
   139→  coldEmailDigest           Boolean           @default(false) // @deprecated
   140→  coldEmailPrompt           String? // @deprecated
   141→  rulesPrompt               String? // @deprecated
   142→  autoCategorizeSenders     Boolean           @default(false)
   143→  multiRuleSelectionEnabled Boolean           @default(false)
   144→
   145→  meetingBriefingsEnabled       Boolean @default(false)
   146→  meetingBriefingsMinutesBefore Int     @default(240) // 4 hours in minutes
   147→
   148→  digestSchedule Schedule?
   149→
   150→  userId    String
   151→  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
   152→  accountId String  @unique
   153→  account   Account @relation(fields: [accountId], references: [id], onDelete: Cascade)
   154→
   155→  labels           Label[]
   156→  rules            Rule[]
   157→  executedRules    ExecutedRule[]
   158→  newsletters      Newsletter[]
   159→  coldEmails       ColdEmail[]
   160→  groups           Group[]
   161→  categories       Category[]
   162→  threadTrackers   ThreadTracker[]
   163→  cleanupJobs      CleanupJob[]
   164→  cleanupThreads   CleanupThread[]
   165→  emailMessages    EmailMessage[]
   166→  emailTokens      EmailToken[]
   167→  knowledge        Knowledge[]
   168→  chats            Chat[]
   169→  digests          Digest[]
   170→  scheduledActions ScheduledAction[]
   171→  responseTimes    ResponseTime[]
   172→
   173→  members             Member[]
   174→  invitations         Invitation[]
   175→  ssoproviders        SsoProvider[]
   176→  calendarConnections CalendarConnection[]
   177→  mcpConnections      McpConnection[]
   178→  meetingBriefings    MeetingBriefing[]
   179→
   180→  @@index([userId])
   181→  @@index([lastSummaryEmailAt])
   182→}
   183→
   184→model Organization {
   185→  id          String        @id @default(cuid())
   186→  name        String
   187→  slug        String        @unique
   188→  logo        String?
   189→  metadata    Json?
   190→  createdAt   DateTime      @default(now())
   191→  updatedAt   DateTime      @updatedAt
   192→  members     Member[]
   193→  SsoProvider SsoProvider[]
   194→  sessions    Session[]
   195→  invitations Invitation[]
   196→}
   197→
   198→model Member {
   199→  id             String       @id @default(cuid())
   200→  organizationId String
   201→  emailAccountId String
   202→  role           String       @default("member") // "admin" | "member"
   203→  createdAt      DateTime     @default(now())
   204→  updatedAt      DateTime     @updatedAt
   205→  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
   206→  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   207→
   208→  @@unique([organizationId, emailAccountId])
   209→  @@index([emailAccountId])
   210→}
   211→
   212→model Invitation {
   213→  id             String       @id @default(cuid())
   214→  organizationId String
   215→  organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
   216→  email          String
   217→  role           String?
   218→  status         String
   219→  expiresAt      DateTime
   220→  inviterId      String
   221→  inviter        EmailAccount @relation(fields: [inviterId], references: [id], onDelete: Cascade)
   222→
   223→  @@index([organizationId])
   224→  @@index([inviterId])
   225→  @@map("invitation")
   226→}
   227→
   228→model Verification {
   229→  id         String   @id @default(cuid())
   230→  identifier String
   231→  value      String
   232→  expiresAt  DateTime
   233→  createdAt  DateTime @default(now())
   234→  updatedAt  DateTime @default(now()) @updatedAt
   235→
   236→  @@map("verification")
   237→}
   238→
   239→model SsoProvider {
   240→  id             String        @id @default(cuid())
   241→  issuer         String
   242→  oidcConfig     String?
   243→  samlConfig     String?
   244→  emailAccountId String?
   245→  emailAccount   EmailAccount? @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   246→  providerId     String        @unique
   247→  organizationId String?
   248→  organization   Organization? @relation(fields: [organizationId], references: [id], onDelete: Cascade)
   249→  domain         String
   250→
   251→  @@index([emailAccountId])
   252→  @@index([organizationId])
   253→  @@map("ssoProvider")
   254→}
   255→
   256→model Digest {
   257→  id             String       @id @default(cuid())
   258→  createdAt      DateTime     @default(now())
   259→  updatedAt      DateTime     @updatedAt
   260→  emailAccountId String
   261→  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   262→  items          DigestItem[]
   263→  sentAt         DateTime?
   264→  status         DigestStatus @default(PENDING)
   265→
   266→  @@index([emailAccountId])
   267→}
   268→
   269→model DigestItem {
   270→  id          String          @id @default(cuid())
   271→  createdAt   DateTime        @default(now())
   272→  updatedAt   DateTime        @updatedAt
   273→  messageId   String
   274→  threadId    String
   275→  content     String          @db.Text
   276→  digestId    String
   277→  digest      Digest          @relation(fields: [digestId], references: [id], onDelete: Cascade)
   278→  actionId    String?
   279→  action      ExecutedAction? @relation(fields: [actionId], references: [id], onDelete: Cascade)
   280→  coldEmailId String?
   281→  coldEmail   ColdEmail?      @relation(fields: [coldEmailId], references: [id])
   282→
   283→  @@unique([digestId, threadId, messageId])
   284→  @@index([actionId])
   285→  @@index([coldEmailId])
   286→}
   287→
   288→model Schedule {
   289→  id        String   @id @default(cuid())
   290→  createdAt DateTime @default(now())
   291→  updatedAt DateTime @updatedAt
   292→
   293→  intervalDays Int? // Total interval in days
   294→  occurrences  Int? // Number of times within the interval
   295→
   296→  // Bit mask for days of week (0b0000000 to 0b1111111)
   297→  // Each bit represents a day (Sunday to Saturday)
   298→  // e.g., 0b1000001 means Sunday and Saturday
   299→  daysOfWeek Int? // 0-127 (2^7 - 1)
   300→
   301→  // Time of day stored as DateTime with canonical date (1970-01-01)
   302→  // Only the time portion is used, but DateTime preserves timezone info
   303→  // Example: "1970-01-01T09:30:00Z", "1970-01-01T14:15:00Z"
   304→  timeOfDay DateTime?
   305→
   306→  emailAccountId String
   307→  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   308→
   309→  lastOccurrenceAt DateTime?
   310→  nextOccurrenceAt DateTime?
   311→
   312→  @@unique([emailAccountId])
   313→}
   314→
   315→model Premium {
   316→  id        String   @id @default(cuid())
   317→  createdAt DateTime @default(now())
   318→  updatedAt DateTime @updatedAt
   319→
   320→  users  User[] @relation(name: "userPremium")
   321→  admins User[]
   322→
   323→  pendingInvites String[]
   324→
   325→  // lemon squeezy
   326→  lemonSqueezyRenewsAt           DateTime?
   327→  lemonSqueezyCustomerId         Int?
   328→  lemonSqueezySubscriptionId     Int?
   329→  lemonSqueezySubscriptionItemId Int?
   330→  lemonSqueezyOrderId            Int? // lifetime purchase is an order and not a subscription
   331→  lemonSqueezyProductId          Int?
   332→  lemonSqueezyVariantId          Int?
   333→  lemonLicenseKey                String?
   334→  lemonLicenseInstanceId         String?
   335→  lemonSubscriptionStatus        String?
   336→
   337→  // stripe
   338→  stripeCustomerId         String?   @unique
   339→  stripeSubscriptionId     String?   @unique
   340→  stripeSubscriptionItemId String?   @unique
   341→  stripePriceId            String?
   342→  stripeProductId          String?
   343→  stripeSubscriptionStatus String? // The current status from Stripe (e.g., 'active', 'trialing', 'past_due', 'canceled', 'unpaid').
   344→  stripeCancelAtPeriodEnd  Boolean? // If true, the subscription is set to cancel automatically at the end of the current billing period, rather than renew.
   345→  stripeRenewsAt           DateTime? // Timestamp for when the current billing period ends and the subscription attempts renewal (if not canceling). Derived from `current_period_end`.
   346→  stripeTrialEnd           DateTime? // Timestamp for when the free trial period ends (if applicable). Important for managing trial-to-paid transitions.
   347→  stripeCanceledAt         DateTime? // Timestamp for when the subscription was definitively marked as canceled in Stripe (might be immediate or after period end). Historical data.
   348→  stripeEndedAt            DateTime? // Timestamp for when the subscription ended permanently for any reason (cancellation, final payment failure). Historical data.
   349→
   350→  tier PremiumTier?
   351→
   352→  emailAccountsAccess Int?
   353→
   354→  // unsubscribe/ai credits
   355→  // if `unsubscribeMonth` not set to this month, set to current month
   356→  // reset `unsubscribeCredits` each time month is changed
   357→  unsubscribeMonth   Int? // 1-12
   358→  unsubscribeCredits Int?
   359→  aiMonth            Int? // 1-12
   360→  aiCredits          Int?
   361→
   362→  // Payment history
   363→  payments Payment[]
   364→
   365→  @@index([pendingInvites])
   366→}
   367→
   368→// not in use as it's only used for passwordless login
   369→model VerificationToken {
   370→  id         String   @id @default(cuid())
   371→  createdAt  DateTime @default(now())
   372→  updatedAt  DateTime @updatedAt
   373→  identifier String
   374→  token      String   @unique
   375→  expires    DateTime
   376→
   377→  @@unique([identifier, token])
   378→}
   379→
   380→model Label {
   381→  id           String   @id @default(cuid())
   382→  createdAt    DateTime @default(now())
   383→  updatedAt    DateTime @updatedAt
   384→  gmailLabelId String
   385→  name         String
   386→  description  String? // used in prompts
   387→  enabled      Boolean  @default(true)
   388→
   389→  emailAccountId String
   390→  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   391→
   392→  @@unique([gmailLabelId, emailAccountId])
   393→  @@unique([name, emailAccountId])
   394→}
   395→
   396→model Rule {
   397→  id           String   @id @default(cuid())
   398→  createdAt    DateTime @default(now())
   399→  updatedAt    DateTime @updatedAt
   400→  name         String
   401→  actions      Action[]
   402→  enabled      Boolean  @default(true)
   403→  automate     Boolean  @default(true) // @deprecated - No longer used. All rules are now automated. Kept for historical data only.
   404→  runOnThreads Boolean  @default(false) // if disabled, only runs on individual emails
   405→
   406→  emailAccountId String
   407→  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   408→
   409→  executedRules ExecutedRule[]
   410→
   411→  // conditions: ai, group, static, category
   412→  conditionalOperator LogicalOperator @default(AND)
   413→
   414→  // ai conditions
   415→  instructions String?
   416→
   417→  // group condition
   418→  groupId String? @unique
   419→  group   Group?  @relation(fields: [groupId], references: [id], onDelete: Cascade)
   420→
   421→  // static condition
   422→  // automatically apply this rule if it matches a filter. supports regex
   423→  from    String?
   424→  to      String?
   425→  subject String?
   426→  body    String?
   427→
   428→  // category condition
   429→  // only apply to (or do not apply to) senders in these categories
   430→  categoryFilterType CategoryFilterType? // deprecated
   431→  categoryFilters    Category[] // deprecated
   432→
   433→  systemType SystemType?
   434→
   435→  promptText String? // natural language for this rule for prompt file. prompt file is combination of these fields
   436→
   437→  history RuleHistory[]
   438→
   439→  @@unique([name, emailAccountId])
   440→  @@unique([emailAccountId, systemType])
   441→}
   442→
   443→model Action {
   444→  id        String     @id @default(cuid())
   445→  createdAt DateTime   @default(now())
   446→  updatedAt DateTime   @updatedAt
   447→  type      ActionType
   448→  ruleId    String
   449→  rule      Rule       @relation(fields: [ruleId], references: [id], onDelete: Cascade)
   450→
   451→  label          String? // labelName - labelId is the source of truth, and we use it when set
   452→  labelId        String? // Stable ID: Label ID (Gmail) or Category ID (Outlook)
   453→  subject        String?
   454→  content        String?
   455→  to             String?
   456→  cc             String?
   457→  bcc            String?
   458→  url            String?
   459→  folderName     String?
   460→  folderId       String?
   461→  delayInMinutes Int?
   462→
   463→  @@index([ruleId])
   464→}
   465→
   466→model RuleHistory {
   467→  id          String   @id @default(cuid())
   468→  createdAt   DateTime @default(now())
   469→  ruleId      String
   470→  rule        Rule     @relation(fields: [ruleId], references: [id], onDelete: Cascade)
   471→  version     Int
   472→  triggerType String // "ai_update" (AI), "manual_update" (user), "ai_creation" (AI), "manual_creation" (user), "system_creation" (system), "system_update" (system)
   473→  promptText  String? // The prompt text that generated this version
   474→
   475→  name                String
   476→  instructions        String?
   477→  enabled             Boolean
   478→  automate            Boolean
   479→  runOnThreads        Boolean
   480→  conditionalOperator String
   481→  from                String?
   482→  to                  String?
   483→  subject             String?
   484→  body                String?
   485→  categoryFilterType  String? // deprecated
   486→  systemType          String?
   487→
   488→  actions         Json
   489→  categoryFilters Json? // deprecated
   490→
   491→  @@unique([ruleId, version])
   492→  @@index([ruleId, createdAt])
   493→}
   494→
   495→// Rule/Action models represent the rules and actions that the AI can take.
   496→// ExecutedRule/ExecutedAction models represent the rules/actions that have been planned or executed by the AI.
   497→model ExecutedRule {
   498→  id            String             @id @default(cuid())
   499→  createdAt     DateTime           @default(now())
   500→  updatedAt     DateTime           @updatedAt
   501→  threadId      String
   502→  messageId     String
   503→  status        ExecutedRuleStatus
   504→  automated     Boolean
   505→  reason        String?
   506→  matchMetadata Json? // Stores structured match information (e.g., learned patterns, match types)
   507→
   508→  // may be null if the rule was deleted
   509→  ruleId String?
   510→  rule   Rule?   @relation(fields: [ruleId], references: [id])
   511→
   512→  // storing user here in case rule was deleted
   513→  emailAccountId String
   514→  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   515→
   516→  actionItems      ExecutedAction[]
   517→  scheduledActions ScheduledAction[]
   518→
   519→  @@index([emailAccountId, threadId, messageId, ruleId])
   520→  @@index([emailAccountId, messageId])
   521→  @@index([emailAccountId, status, createdAt])
   522→}
   523→
   524→model ExecutedAction {
   525→  id             String       @id @default(cuid())
   526→  createdAt      DateTime     @default(now())
   527→  updatedAt      DateTime     @updatedAt
   528→  type           ActionType
   529→  executedRuleId String
   530→  executedRule   ExecutedRule @relation(fields: [executedRuleId], references: [id], onDelete: Cascade)
   531→
   532→  // optional extra fields to be used with the action
   533→  label      String?
   534→  labelId    String? // Stable ID: Label ID (Gmail) or Category ID (Outlook)
   535→  subject    String?
   536→  content    String?
   537→  to         String?
   538→  cc         String?
   539→  bcc        String?
   540→  url        String?
   541→  folderName String?
   542→  folderId   String?
   543→
   544→  // additional fields as a result of the action
   545→  draftId         String? // Gmail draft ID created by DRAFT_EMAIL action
   546→  wasDraftSent    Boolean? // Tracks if the corresponding draft was sent (true) or ignored/superseded (false)
   547→  draftSendLog    DraftSendLog? // Will exist if the draft was sent
   548→  digestItems     DigestItem[] // Relation to digest items created by this action
   549→  scheduledAction ScheduledAction? // Reverse relation for delayed actions
   550→
   551→  @@index([executedRuleId])
   552→}
   553→
   554→model ScheduledAction {
   555→  id               String                @id @default(cuid())
   556→  createdAt        DateTime              @default(now())
   557→  updatedAt        DateTime              @updatedAt
   558→  executedRuleId   String
   559→  actionType       ActionType
   560→  messageId        String
   561→  threadId         String
   562→  scheduledFor     DateTime
   563→  emailAccountId   String
   564→  status           ScheduledActionStatus @default(PENDING)
   565→  schedulingStatus SchedulingStatus      @default(PENDING)
   566→
   567→  label       String?
   568→  labelId     String? // Stable ID: Label ID (Gmail) or Category ID (Outlook)
   569→  subject     String?
   570→  content     String?
   571→  to          String?
   572→  cc          String?
   573→  bcc         String?
   574→  url         String?
   575→  folderName  String?
   576→  folderId    String?
   577→  scheduledId String?
   578→
   579→  executedAt       DateTime?
   580→  executedActionId String?   @unique
   581→
   582→  executedRule   ExecutedRule    @relation(fields: [executedRuleId], references: [id], onDelete: Cascade)
   583→  executedAction ExecutedAction? @relation(fields: [executedActionId], references: [id], onDelete: Cascade)
   584→  emailAccount   EmailAccount    @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   585→
   586→  @@index([executedRuleId])
   587→  @@index([status, scheduledFor])
   588→  @@index([emailAccountId, messageId])
   589→}
   590→
   591→// Notes:
   592→// In the past groups stood on their own. Now they are attached to a rule.
   593→// A group without a rule does not do anything anymore. I may delete all detached groups in the future, and then make rule required
   594→// "Prompt" is no longer in use. It was used to generate the group, but now it's based on the rule the group is attached to.
   595→// "Name" is no longer in use although still required.
   596→// If we really wanted we could remove Group and just have a relation between Rule and GroupItem, but leaving as is for now.
   597→model Group {
   598→  id        String   @id @default(cuid())
   599→  createdAt DateTime @default(now())
   600→  updatedAt DateTime @updatedAt
   601→  name      String
   602→  prompt    String?
   603→
   604→  items GroupItem[]
   605→  rule  Rule?
   606→
   607→  emailAccountId String
   608→  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   609→
   610→  @@unique([name, emailAccountId])
   611→}
   612→
   613→model GroupItem {
   614→  id        String        @id @default(cuid())
   615→  createdAt DateTime      @default(now())
   616→  updatedAt DateTime      @updatedAt
   617→  groupId   String?
   618→  group     Group?        @relation(fields: [groupId], references: [id], onDelete: Cascade)
   619→  type      GroupItemType
   620→  value     String // eg "@gmail.com", "matt@gmail.com", "Receipt from"
   621→  exclude   Boolean       @default(false) // Whether this pattern should be excluded rather than included
   622→
   623→  @@unique([groupId, type, value])
   624→}
   625→
   626→model Category {
   627→  id          String   @id @default(cuid())
   628→  createdAt   DateTime @default(now())
   629→  updatedAt   DateTime @updatedAt
   630→  name        String
   631→  description String?
   632→
   633→  emailAccountId String
   634→  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   635→
   636→  emailSenders Newsletter[]
   637→  rules        Rule[]
   638→
   639→  @@unique([name, emailAccountId])
   640→}
   641→
   642→// Represents a sender (`email`) that a user can unsubscribe from,
   643→// or that our AI can mark as a cold email.
   644→// `Newsletter` is a bad name for this. Will rename this model in the future.
   645→model Newsletter {
   646→  id        String            @id @default(cuid())
   647→  createdAt DateTime          @default(now())
   648→  updatedAt DateTime          @updatedAt
   649→  email     String
   650→  status    NewsletterStatus?
   651→
   652→  // For learned patterns for rules
   653→  patternAnalyzed Boolean   @default(false)
   654→  lastAnalyzedAt  DateTime?
   655→
   656→  emailAccountId String
   657→  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   658→
   659→  categoryId String?
   660→  category   Category? @relation(fields: [categoryId], references: [id])
   661→
   662→  @@unique([email, emailAccountId])
   663→  @@index([emailAccountId, status])
   664→  @@index([categoryId])
   665→}
   666→
   667→model ColdEmail {
   668→  id        String           @id @default(cuid())
   669→  createdAt DateTime         @default(now())
   670→  updatedAt DateTime         @updatedAt
   671→  fromEmail String
   672→  messageId String?
   673→  threadId  String?
   674→  status    ColdEmailStatus?
   675→  reason    String?
   676→
   677→  emailAccountId String
   678→  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   679→
   680→  digestItems DigestItem[]
   681→
   682→  @@unique([emailAccountId, fromEmail])
   683→  @@index([emailAccountId, status])
   684→  @@index([emailAccountId, createdAt])
   685→}
   686→
   687→model EmailMessage {
   688→  id              String   @id @default(cuid())
   689→  createdAt       DateTime @default(now())
   690→  updatedAt       DateTime @updatedAt
   691→  threadId        String
   692→  messageId       String
   693→  date            DateTime // date of the email
   694→  from            String
   695→  fromName        String? // sender's display name
   696→  fromDomain      String
   697→  to              String
   698→  unsubscribeLink String?
   699→  read            Boolean
   700→  sent            Boolean
   701→  draft           Boolean
   702→  inbox           Boolean
   703→
   704→  emailAccountId String
   705→  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   706→
   707→  @@unique([emailAccountId, threadId, messageId])
   708→  @@index([emailAccountId, threadId])
   709→  @@index([emailAccountId, date])
   710→  @@index([emailAccountId, from])
   711→  @@index([emailAccountId, fromName])
   712→}
   713→
   714→model ResponseTime {
   715→  id                String   @id @default(cuid())
   716→  createdAt         DateTime @default(now())
   717→  threadId          String
   718→  sentMessageId     String
   719→  receivedMessageId String
   720→  responseTimeMins  Int // Denormalized: (sentAt - receivedAt) in minutes
   721→  receivedAt        DateTime
   722→  sentAt            DateTime
   723→
   724→  emailAccountId String
   725→  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   726→
   727→  @@unique([emailAccountId, sentMessageId])
   728→  @@index([emailAccountId, sentAt])
   729→}
   730→
   731→model ThreadTracker {
   732→  id        String            @id @default(cuid())
   733→  createdAt DateTime          @default(now())
   734→  updatedAt DateTime          @updatedAt
   735→  sentAt    DateTime
   736→  threadId  String
   737→  messageId String
   738→  resolved  Boolean           @default(false)
   739→  type      ThreadTrackerType
   740→
   741→  emailAccountId String
   742→  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   743→
   744→  @@unique([emailAccountId, threadId, messageId])
   745→  @@index([emailAccountId, resolved])
   746→  @@index([emailAccountId, resolved, sentAt, type])
   747→  @@index([emailAccountId, type, resolved, sentAt])
   748→}
   749→
   750→model CleanupJob {
   751→  id               String      @id @default(cuid())
   752→  createdAt        DateTime    @default(now())
   753→  updatedAt        DateTime    @updatedAt
   754→  action           CleanAction @default(ARCHIVE)
   755→  daysOld          Int         @default(7)
   756→  instructions     String?
   757→  skipReply        Boolean?
   758→  skipStarred      Boolean?
   759→  skipCalendar     Boolean?
   760→  skipReceipt      Boolean?
   761→  skipAttachment   Boolean?
   762→  skipConversation Boolean?
   763→
   764→  emailAccountId String
   765→  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   766→
   767→  threads CleanupThread[]
   768→
   769→  @@index([emailAccountId])
   770→}
   771→
   772→model CleanupThread {
   773→  id        String     @id @default(cuid())
   774→  createdAt DateTime   @default(now())
   775→  updatedAt DateTime   @updatedAt
   776→  threadId  String
   777→  archived  Boolean // this can also mean "mark as read". depends on CleanupJob.action
   778→  jobId     String
   779→  job       CleanupJob @relation(fields: [jobId], references: [id], onDelete: Cascade)
   780→
   781→  emailAccountId String
   782→  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   783→
   784→  @@index([jobId])
   785→}
   786→
   787→model Knowledge {
   788→  id        String   @id @default(cuid())
   789→  createdAt DateTime @default(now())
   790→  updatedAt DateTime @updatedAt
   791→  title     String
   792→  content   String
   793→
   794→  emailAccountId String
   795→  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   796→
   797→  @@unique([emailAccountId, title])
   798→}
   799→
   800→model ApiKey {
   801→  id        String   @id @default(cuid())
   802→  createdAt DateTime @default(now())
   803→  updatedAt DateTime @updatedAt
   804→  name      String?
   805→  hashedKey String   @unique
   806→  isActive  Boolean  @default(true)
   807→
   808→  userId String
   809→  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
   810→
   811→  @@index([userId, isActive])
   812→}
   813→
   814→model EmailToken {
   815→  id        String   @id @default(cuid())
   816→  createdAt DateTime @default(now())
   817→  token     String   @unique
   818→  expiresAt DateTime
   819→  // action    EmailTokenAction @default(UNSUBSCRIBE)
   820→
   821→  emailAccountId String
   822→  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   823→
   824→  @@index([emailAccountId])
   825→}
   826→
   827→model Payment {
   828→  id        String   @id @default(cuid())
   829→  createdAt DateTime // from processor
   830→  updatedAt DateTime // from processor
   831→
   832→  // Relation to Premium
   833→  premiumId String?
   834→  premium   Premium? @relation(fields: [premiumId], references: [id], onDelete: SetNull)
   835→
   836→  // Payment processor information
   837→  processorType           ProcessorType @default(LEMON_SQUEEZY)
   838→  processorId             String?       @unique // External payment ID from Stripe/Lemon Squeezy
   839→  processorSubscriptionId String? // External subscription ID
   840→  processorCustomerId     String? // External customer ID
   841→
   842→  // Core payment information
   843→  amount       Int // Total amount in cents
   844→  currency     String // 3-letter currency code: USD, EUR, etc.
   845→  status       String // paid, failed, refunded, etc.
   846→  tax          Int
   847→  taxInclusive Boolean
   848→
   849→  // Refund information
   850→  refunded       Boolean   @default(false)
   851→  refundedAt     DateTime?
   852→  refundedAmount Int? // in cents
   853→
   854→  // Metadata
   855→  billingReason String? // initial, renewal, update, etc.
   856→
   857→  @@index([premiumId])
   858→}
   859→
   860→model DraftSendLog {
   861→  id        String   @id @default(cuid())
   862→  createdAt DateTime @default(now())
   863→
   864→  executedActionId String         @unique
   865→  executedAction   ExecutedAction @relation(fields: [executedActionId], references: [id], onDelete: Cascade)
   866→
   867→  sentMessageId   String
   868→  similarityScore Float // Similarity score (0.0 to 1.0) between original draft and sent message
   869→
   870→  @@index([executedActionId])
   871→}
   872→
   873→model Chat {
   874→  id        String   @id @default(cuid())
   875→  createdAt DateTime @default(now())
   876→  updatedAt DateTime @updatedAt
   877→
   878→  messages       ChatMessage[]
   879→  emailAccountId String
   880→  emailAccount   EmailAccount  @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   881→
   882→  @@index([emailAccountId])
   883→}
   884→
   885→model ChatMessage {
   886→  id        String   @id @default(cuid())
   887→  createdAt DateTime @default(now())
   888→  updatedAt DateTime @updatedAt
   889→
   890→  role  String
   891→  parts Json
   892→  // attachments Json?
   893→
   894→  chatId String
   895→  chat   Chat   @relation(fields: [chatId], references: [id], onDelete: Cascade)
   896→
   897→  @@index([chatId])
   898→}
   899→
   900→model CalendarConnection {
   901→  id        String   @id @default(cuid())
   902→  createdAt DateTime @default(now())
   903→  updatedAt DateTime @updatedAt
   904→
   905→  provider     String // "google" or "microsoft"
   906→  email        String // Google account email (e.g., "elie@gmail.com")
   907→  accessToken  String?
   908→  refreshToken String?
   909→  expiresAt    DateTime?
   910→  isConnected  Boolean   @default(true)
   911→
   912→  emailAccountId String
   913→  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   914→
   915→  calendars Calendar[]
   916→
   917→  @@unique([emailAccountId, provider, email]) // Allow multiple Google accounts per user
   918→}
   919→
   920→model Calendar {
   921→  id        String   @id @default(cuid())
   922→  createdAt DateTime @default(now())
   923→  updatedAt DateTime @updatedAt
   924→
   925→  calendarId  String // External calendar ID from provider
   926→  name        String
   927→  description String?
   928→  primary     Boolean @default(false)
   929→  isEnabled   Boolean @default(true)
   930→  timezone    String?
   931→
   932→  connectionId String
   933→  connection   CalendarConnection @relation(fields: [connectionId], references: [id], onDelete: Cascade)
   934→
   935→  @@unique([connectionId, calendarId])
   936→}
   937→
   938→model MeetingBriefing {
   939→  id        String   @id @default(cuid())
   940→  createdAt DateTime @default(now())
   941→
   942→  calendarEventId String // External event ID from Google/Microsoft
   943→  eventTitle      String
   944→  eventStartTime  DateTime
   945→  guestCount      Int
   946→  status          MeetingBriefingStatus
   947→
   948→  emailAccountId String
   949→  emailAccount   EmailAccount @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
   950→
   951→  @@unique([emailAccountId, calendarEventId]) // Prevent duplicate briefings
   952→  @@index([emailAccountId])
   953→}
   954→
   955→model Referral {
   956→  id        String   @id @default(cuid())
   957→  createdAt DateTime @default(now())
   958→  updatedAt DateTime @updatedAt
   959→
   960→  // The user who made the referral (referrer)
   961→  referrerUserId String
   962→  referrerUser   User   @relation(name: "ReferrerUser", fields: [referrerUserId], references: [id], onDelete: Cascade)
   963→
   964→  // The user who was referred
   965→  referredUserId String @unique // Each user can only be referred once
   966→  referredUser   User   @relation(name: "ReferredUser", fields: [referredUserId], references: [id], onDelete: Cascade)
   967→
   968→  // The referral code used (stored as string)
   969→  referralCodeUsed String
   970→
   971→  // Status tracking
   972→  status ReferralStatus @default(PENDING)
   973→
   974→  // Reward tracking - using Stripe balance transactions
   975→  rewardGrantedAt            DateTime?
   976→  stripeBalanceTransactionId String? // Store Stripe txn ID for reference
   977→  rewardAmount               Int? // Amount in cents (e.g., 2000 for $20)
   978→
   979→  @@index([referrerUserId])
   980→  @@index([status])
   981→}
   982→
   983→model McpIntegration {
   984→  id        String   @id @default(cuid())
   985→  createdAt DateTime @default(now())
   986→  updatedAt DateTime @updatedAt
   987→
   988→  name String @unique // Lookup key to MCP_INTEGRATIONS config
   989→
   990→  // OAuth registration metadata (captured during dynamic registration)
   991→  // These represent what the credentials below were registered for
   992→  registeredServerUrl        String? // Server URL credentials are registered with
   993→  registeredAuthorizationUrl String? // OAuth authorization endpoint used
   994→  registeredTokenUrl         String? // OAuth token endpoint used
   995→
   996→  // OAuth client credentials (from dynamic registration - shared across all users)
   997→  oauthClientId     String?
   998→  oauthClientSecret String?
   999→
  1000→  connections McpConnection[]
  1001→}
  1002→
  1003→model McpConnection {
  1004→  id        String   @id @default(cuid())
  1005→  createdAt DateTime @default(now())
  1006→  updatedAt DateTime @updatedAt
  1007→
  1008→  name     String
  1009→  isActive Boolean @default(true)
  1010→
  1011→  // Encrypted credentials
  1012→  accessToken  String?
  1013→  refreshToken String?
  1014→  apiKey       String?
  1015→  expiresAt    DateTime?
  1016→
  1017→  integrationId  String
  1018→  integration    McpIntegration @relation(fields: [integrationId], references: [id], onDelete: Cascade)
  1019→  emailAccountId String?
  1020→  emailAccount   EmailAccount?  @relation(fields: [emailAccountId], references: [id], onDelete: Cascade)
  1021→  tools          McpTool[]
  1022→
  1023→  @@unique([emailAccountId, integrationId])
  1024→}
  1025→
  1026→model McpTool {
  1027→  id        String   @id @default(cuid())
  1028→  createdAt DateTime @default(now())
  1029→  updatedAt DateTime @updatedAt
  1030→
  1031→  name        String
  1032→  description String?
  1033→  schema      Json?
  1034→  isEnabled   Boolean @default(true)
  1035→
  1036→  connectionId String
  1037→  connection   McpConnection @relation(fields: [connectionId], references: [id], onDelete: Cascade)
  1038→
  1039→  @@unique([connectionId, name])
  1040→}
  1041→
  1042→enum ActionType {
  1043→  ARCHIVE
  1044→  LABEL
  1045→  REPLY
  1046→  SEND_EMAIL
  1047→  FORWARD
  1048→  DRAFT_EMAIL
  1049→  MARK_SPAM
  1050→  CALL_WEBHOOK
  1051→  MARK_READ
  1052→  // TRACK_THREAD // @deprecated - No longer used. We rely on rule SystemType instead to run this.
  1053→  DIGEST
  1054→  MOVE_FOLDER
  1055→  NOTIFY_SENDER // Sends notification from Inbox Zero (not user's email). Only for cold email rules.
  1056→  // SUMMARIZE
  1057→  // SNOOZE
  1058→  // ADD_TO_DO
  1059→  // INTEGRATION // for example, add to Notion
  1060→}
  1061→
  1062→enum Frequency {
  1063→  NEVER
  1064→  DAILY
  1065→  WEEKLY
  1066→  // MONTHLY
  1067→  // ANNUALLY
  1068→}
  1069→
  1070→enum NewsletterStatus {
  1071→  APPROVED
  1072→  UNSUBSCRIBED
  1073→  AUTO_ARCHIVED
  1074→}
  1075→
  1076→enum ColdEmailStatus {
  1077→  AI_LABELED_COLD
  1078→  USER_REJECTED_COLD
  1079→}
  1080→
  1081→// @deprecated - No longer used
  1082→enum ColdEmailSetting {
  1083→  DISABLED
  1084→  LIST
  1085→  LABEL
  1086→  ARCHIVE_AND_LABEL
  1087→  ARCHIVE_AND_READ_AND_LABEL
  1088→}
  1089→
  1090→enum PremiumTier {
  1091→  BASIC_MONTHLY
  1092→  BASIC_ANNUALLY
  1093→  PRO_MONTHLY
  1094→  PRO_ANNUALLY
  1095→  BUSINESS_MONTHLY
  1096→  BUSINESS_ANNUALLY
  1097→  BUSINESS_PLUS_MONTHLY
  1098→  BUSINESS_PLUS_ANNUALLY
  1099→  COPILOT_MONTHLY
  1100→  LIFETIME
  1101→}
  1102→
  1103→enum ExecutedRuleStatus {
  1104→  APPLIED
  1105→  APPLYING
  1106→  REJECTED // @deprecated - No longer created. Kept for historical data only.
  1107→  PENDING // @deprecated - No longer created. Kept for historical data only.
  1108→  SKIPPED
  1109→  ERROR
  1110→}
  1111→
  1112→enum GroupItemType {
  1113→  FROM
  1114→  SUBJECT
  1115→  BODY
  1116→}
  1117→
  1118→enum CategoryFilterType {
  1119→  INCLUDE
  1120→  EXCLUDE
  1121→}
  1122→
  1123→enum LogicalOperator {
  1124→  AND
  1125→  OR
  1126→}
  1127→
  1128→enum ThreadTrackerType {
  1129→  AWAITING // We're waiting for their reply
  1130→  NEEDS_REPLY // We need to reply to this
  1131→  NEEDS_ACTION // We need to do something else
  1132→}
  1133→
  1134→enum ProcessorType {
  1135→  LEMON_SQUEEZY
  1136→  STRIPE
  1137→}
  1138→
  1139→enum CleanAction {
  1140→  ARCHIVE
  1141→  MARK_READ
  1142→}
  1143→
  1144→enum SystemType {
  1145→  // conversation trackers
  1146→  TO_REPLY
  1147→  FYI
  1148→  AWAITING_REPLY
  1149→  ACTIONED
  1150→  // cold email blocker
  1151→  COLD_EMAIL
  1152→  // other labels
  1153→  NEWSLETTER
  1154→  MARKETING
  1155→  CALENDAR
  1156→  RECEIPT
  1157→  NOTIFICATION
  1158→}
  1159→
  1160→enum ReferralStatus {
  1161→  PENDING // Referral created, waiting for trial completion
  1162→  COMPLETED // Referral completed and reward granted
  1163→}
  1164→
  1165→enum DigestStatus {
  1166→  PENDING
  1167→  PROCESSING
  1168→  SENT
  1169→  FAILED
  1170→}
  1171→
  1172→enum ScheduledActionStatus {
  1173→  PENDING
  1174→  EXECUTING
  1175→  COMPLETED
  1176→  FAILED
  1177→  CANCELLED
  1178→}
  1179→
  1180→enum SchedulingStatus {
  1181→  PENDING
  1182→  SCHEDULED
  1183→  FAILED
  1184→}
  1185→
  1186→enum MeetingBriefingStatus {
  1187→  PENDING
  1188→  SENT
  1189→  FAILED
  1190→  SKIPPED
  1191→}
  1192→
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:16:58.850Z)**_

<think><details><summary>Thought Process</summary>
Now I need to add the msal_cache fields to the Account model. Looking at the schema, I see the Account model starts at line 16. I'll add the new fields after `emailAccount` on line 34.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:16:59.222Z)**_

Now I'll add the `msal_cache` fields to the Account model.

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:17:03.303Z)**_

<tool-use data-tool-type="write" data-tool-name="Edit"><details>
<summary>Tool use: **Edit**</summary>
```
The file /Users/hack/github/inbox-zero/apps/web/prisma/schema.prisma has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
    29→  token_type            String?
    30→  scope                 String?
    31→  id_token              String?       @db.Text
    32→  session_state         String?
    33→  user                  User          @relation(fields: [userId], references: [id], onDelete: Cascade)
    34→  emailAccount          EmailAccount?
    35→
    36→  // MSAL device-code flow cache persistence
    37→  // Stores serialized MSAL token cache for accounts authenticated via device-code flow
    38→  // This enables token refresh to survive server restarts
    39→  msal_cache            String?       @db.Text
    40→  msal_cache_updated    DateTime?
    41→
    42→  @@unique([provider, providerAccountId])
    43→  @@index([userId])
    44→}
    45→
    46→// not in use. we only use jwt for sessions
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:17:16.503Z)**_

<think><details><summary>Thought Process</summary>
Now I need to generate the Prisma client to reflect the schema changes. Let me run the prisma generate command to update the client.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:17:17.195Z)**_

<tool-use data-tool-type="unknown" data-tool-name="TaskUpdate"><details>
<summary>Tool use: **TaskUpdate**</summary>
```
Updated task #5 status
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:17:18.048Z)**_

<tool-use data-tool-type="unknown" data-tool-name="TaskUpdate"><details>
<summary>Tool use: **TaskUpdate**</summary>
```
Updated task #4 status
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:17:25.579Z)**_

<think><details><summary>Thought Process</summary>
Now I need to create the MSAL cache plugin. Let me first read the existing encryption utilities to understand the encryption pattern.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:17:25.991Z)**_

Let me read the encryption utilities and create the cache plugin.

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:17:26.347Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./apps/web/utils/encryption.ts`
```
     1→import {
     2→  createCipheriv,
     3→  createDecipheriv,
     4→  randomBytes,
     5→  scryptSync,
     6→} from "node:crypto";
     7→import { env } from "@/env";
     8→import { createScopedLogger } from "@/utils/logger";
     9→
    10→const logger = createScopedLogger("encryption");
    11→
    12→// Cryptographic constants
    13→const ALGORITHM = "aes-256-gcm";
    14→const IV_LENGTH = 16; // 16 bytes for AES GCM
    15→const AUTH_TAG_LENGTH = 16; // 16 bytes for authentication tag
    16→const KEY_LENGTH = 32; // 32 bytes for AES-256
    17→
    18→// Derive encryption key from environment variables
    19→const key = scryptSync(
    20→  env.EMAIL_ENCRYPT_SECRET,
    21→  env.EMAIL_ENCRYPT_SALT,
    22→  KEY_LENGTH,
    23→);
    24→
    25→/**
    26→ * Encrypts a string using AES-256-GCM
    27→ * Returns a hex string containing: IV + Auth Tag + Encrypted content
    28→ */
    29→export function encryptToken(text: string | null): string | null {
    30→  if (text === null || text === undefined) return null;
    31→
    32→  try {
    33→    // Generate a random IV for each encryption
    34→    const iv = randomBytes(IV_LENGTH);
    35→
    36→    const cipher = createCipheriv(ALGORITHM, key, iv);
    37→    const encrypted = Buffer.concat([
    38→      cipher.update(text, "utf8"),
    39→      cipher.final(),
    40→    ]);
    41→
    42→    // Get authentication tag
    43→    const authTag = cipher.getAuthTag();
    44→
    45→    // Return IV + Auth Tag + Encrypted content as hex
    46→    return Buffer.concat([iv, authTag, encrypted]).toString("hex");
    47→  } catch (error) {
    48→    logger.error("Encryption failed", { error });
    49→    return null;
    50→  }
    51→}
    52→
    53→/**
    54→ * Decrypts a string that was encrypted with encryptToken
    55→ * Expects a hex string containing: IV + Auth Tag + Encrypted content
    56→ */
    57→export function decryptToken(encryptedText: string | null): string | null {
    58→  if (encryptedText === null || encryptedText === undefined) return null;
    59→
    60→  try {
    61→    const buffer = Buffer.from(encryptedText, "hex");
    62→
    63→    // Extract IV (first 16 bytes)
    64→    const iv = buffer.subarray(0, IV_LENGTH);
    65→
    66→    // Extract auth tag (next 16 bytes)
    67→    const authTag = buffer.subarray(IV_LENGTH, IV_LENGTH + AUTH_TAG_LENGTH);
    68→
    69→    // Extract encrypted content (remaining bytes)
    70→    const encrypted = buffer.subarray(IV_LENGTH + AUTH_TAG_LENGTH);
    71→
    72→    const decipher = createDecipheriv(ALGORITHM, key, iv);
    73→    decipher.setAuthTag(authTag);
    74→
    75→    const decrypted = Buffer.concat([
    76→      decipher.update(encrypted),
    77→      decipher.final(),
    78→    ]);
    79→
    80→    return decrypted.toString("utf8");
    81→  } catch (error) {
    82→    logger.error("Decryption failed", { error });
    83→    return null;
    84→  }
    85→}
    86→
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:17:36.051Z)**_

<think><details><summary>Thought Process</summary>
Now let me read the existing msal-device-code.ts file to understand the structure and imports used.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:17:37.091Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./apps/web/utils/outlook/msal-device-code.ts`
```
     1→/**
     2→ * MSAL Device Code Flow Authentication
     3→ *
     4→ * Provides device-code authentication for Microsoft accounts as an alternative
     5→ * to browser-based OAuth. Useful for CLI/headless environments.
     6→ *
     7→ * Key Features:
     8→ * - Uses MSAL Node.js library for device code flow
     9→ * - In-memory storage for pending flows (15-min expiration)
    10→ * - Integrates with existing token encryption system
    11→ * - Non-breaking: runs parallel to existing Better Auth OAuth
    12→ */
    13→
    14→import {
    15→  PublicClientApplication,
    16→  type DeviceCodeRequest,
    17→  type AuthenticationResult,
    18→  type AccountInfo,
    19→  LogLevel,
    20→  type INetworkModule,
    21→  type NetworkRequestOptions,
    22→  type NetworkResponse,
    23→} from "@azure/msal-node";
    24→import { env } from "@/env";
    25→import { createScopedLogger } from "@/utils/logger";
    26→
    27→/**
    28→ * Custom network module to handle fetch issues in Node.js 22+
    29→ * Uses fresh fetch calls with abort controller timeouts to avoid
    30→ * undici connection pool issues that cause "fetch failed" errors
    31→ */
    32→class CustomNetworkModule implements INetworkModule {
    33→  private readonly logger = createScopedLogger("msal-network");
    34→
    35→  async sendGetRequestAsync<T>(
    36→    url: string,
    37→    options?: NetworkRequestOptions,
    38→  ): Promise<NetworkResponse<T>> {
    39→    return this.sendRequest<T>(url, "GET", options);
    40→  }
    41→
    42→  async sendPostRequestAsync<T>(
    43→    url: string,
    44→    options?: NetworkRequestOptions,
    45→  ): Promise<NetworkResponse<T>> {
    46→    return this.sendRequest<T>(url, "POST", options);
    47→  }
    48→
    49→  private async sendRequest<T>(
    50→    url: string,
    51→    method: string,
    52→    options?: NetworkRequestOptions,
    53→  ): Promise<NetworkResponse<T>> {
    54→    const controller = new AbortController();
    55→    const timeoutId = setTimeout(() => controller.abort(), 30_000); // 30 second timeout
    56→
    57→    try {
    58→      const response = await fetch(url, {
    59→        method,
    60→        headers: options?.headers as Record<string, string>,
    61→        body: options?.body,
    62→        signal: controller.signal,
    63→        // Disable keep-alive to avoid connection pool issues
    64→        keepalive: false,
    65→      });
    66→
    67→      clearTimeout(timeoutId);
    68→
    69→      const headers: Record<string, string> = {};
    70→      response.headers.forEach((value, key) => {
    71→        headers[key] = value;
    72→      });
    73→
    74→      const body = (await response.json()) as T;
    75→
    76→      return {
    77→        headers,
    78→        body,
    79→        status: response.status,
    80→      };
    81→    } catch (error) {
    82→      clearTimeout(timeoutId);
    83→      this.logger.error("Network request failed", {
    84→        url,
    85→        method,
    86→        error: error instanceof Error ? error.message : String(error),
    87→      });
    88→      throw error;
    89→    }
    90→  }
    91→}
    92→
    93→// Use .default scope for device code flow with Microsoft Office client ID
    94→// This requests all pre-authorized permissions without requiring explicit consent
    95→const MSAL_DEVICE_CODE_SCOPES = ["https://graph.microsoft.com/.default"];
    96→
    97→// DeviceCodeResponse type matches what MSAL passes to the deviceCodeCallback
    98→// Defined locally to avoid importing from @azure/msal-common which is a transitive dep
    99→interface DeviceCodeResponse {
   100→  deviceCode: string;
   101→  userCode: string;
   102→  verificationUri: string;
   103→  expiresIn: number; // seconds until expiration
   104→  interval: number; // polling interval in seconds
   105→  message: string;
   106→}
   107→
   108→const logger = createScopedLogger("msal-device-code");
   109→
   110→// Default Microsoft Office client ID - works without app registration
   111→const MICROSOFT_OFFICE_CLIENT_ID = "d3590ed6-52b3-4102-aeff-aad2292ab01c";
   112→
   113→// Singleton MSAL application instance
   114→let msalApp: PublicClientApplication | null = null;
   115→
   116→function getMSALApp(): PublicClientApplication {
   117→  if (!msalApp) {
   118→    const clientId =
   119→      env.MSAL_CLIENT_ID ||
   120→      env.MICROSOFT_CLIENT_ID ||
   121→      MICROSOFT_OFFICE_CLIENT_ID;
   122→    const tenantId = env.MSAL_TENANT_ID || env.MICROSOFT_TENANT_ID || "common";
   123→    const debugEnabled = env.MSAL_DEBUG === "true";
   124→
   125→    msalApp = new PublicClientApplication({
   126→      auth: {
   127→        clientId,
   128→        authority: `https://login.microsoftonline.com/${tenantId}`,
   129→      },
   130→      system: {
   131→        loggerOptions: {
   132→          loggerCallback: (
   133→            level: LogLevel,
   134→            message: string,
   135→            containsPii: boolean,
   136→          ) => {
   137→            if (containsPii) return; // Don't log PII
   138→            if (debugEnabled || level === LogLevel.Error) {
   139→              logger.info(`MSAL [${LogLevel[level]}]: ${message}`);
   140→            }
   141→          },
   142→          piiLoggingEnabled: false,
   143→          logLevel: debugEnabled ? LogLevel.Verbose : LogLevel.Error,
   144→        },
   145→        // Use custom network module to avoid Node.js 22+ undici connection pool issues
   146→        networkClient: new CustomNetworkModule(),
   147→      },
   148→    });
   149→  }
   150→  return msalApp;
   151→}
   152→
   153→// Feature flag - defaults to disabled until explicitly enabled
   154→export function isMSALDeviceCodeEnabled(): boolean {
   155→  return env.MSAL_ENABLED === "true";
   156→}
   157→
   158→// Active device code flows (for polling)
   159→interface ActiveFlow {
   160→  deviceCode: string;
   161→  userCode: string;
   162→  verificationUri: string;
   163→  expiresAt: Date;
   164→  message: string;
   165→  promise: Promise<AuthenticationResult | null>;
   166→  resolve: (result: AuthenticationResult | null) => void;
   167→  reject: (error: Error) => void;
   168→}
   169→
   170→// Use globalThis to persist flows across Next.js hot reloads in development
   171→const globalForFlows = globalThis as unknown as {
   172→  msalActiveFlows: Map<string, ActiveFlow> | undefined;
   173→};
   174→
   175→const activeFlows =
   176→  globalForFlows.msalActiveFlows ?? new Map<string, ActiveFlow>();
   177→
   178→if (process.env.NODE_ENV !== "production") {
   179→  globalForFlows.msalActiveFlows = activeFlows;
   180→}
   181→
   182→// Cleanup expired flows periodically
   183→function cleanupExpiredFlows(): void {
   184→  const now = new Date();
   185→  for (const [sessionId, flow] of activeFlows.entries()) {
   186→    if (now > flow.expiresAt) {
   187→      activeFlows.delete(sessionId);
   188→      logger.info("Cleaned up expired device code flow", { sessionId });
   189→    }
   190→  }
   191→}
   192→
   193→// Run cleanup every 5 minutes
   194→setInterval(cleanupExpiredFlows, 5 * 60 * 1000);
   195→
   196→export interface DeviceCodeInitResponse {
   197→  sessionId: string;
   198→  userCode: string;
   199→  verificationUri: string;
   200→  expiresAt: Date;
   201→  message: string;
   202→}
   203→
   204→/**
   205→ * Initiate device code flow
   206→ * Returns the device code info for display to user
   207→ */
   208→export async function initiateDeviceCodeFlow(
   209→  sessionId: string,
   210→): Promise<DeviceCodeInitResponse> {
   211→  if (!isMSALDeviceCodeEnabled()) {
   212→    throw new Error("MSAL device code flow is not enabled");
   213→  }
   214→
   215→  const app = getMSALApp();
   216→
   217→  // Clean up expired flows
   218→  cleanupExpiredFlows();
   219→
   220→  // Check if session already exists
   221→  if (activeFlows.has(sessionId)) {
   222→    throw new Error("Session already exists");
   223→  }
   224→
   225→  let flowResolve: (result: AuthenticationResult | null) => void;
   226→  let flowReject: (error: Error) => void;
   227→  let capturedDeviceCode: DeviceCodeResponse | null = null;
   228→
   229→  const flowPromise = new Promise<AuthenticationResult | null>(
   230→    (resolve, reject) => {
   231→      flowResolve = resolve;
   232→      flowReject = reject;
   233→    },
   234→  );
   235→
   236→  const deviceCodeRequest: DeviceCodeRequest = {
   237→    scopes: MSAL_DEVICE_CODE_SCOPES,
   238→    deviceCodeCallback: (response: DeviceCodeResponse) => {
   239→      capturedDeviceCode = response;
   240→
   241→      // Calculate expiration time from expiresIn (seconds)
   242→      const expiresAt = new Date(Date.now() + response.expiresIn * 1000);
   243→
   244→      // Store flow info for polling
   245→      activeFlows.set(sessionId, {
   246→        deviceCode: response.deviceCode,
   247→        userCode: response.userCode,
   248→        verificationUri: response.verificationUri,
   249→        expiresAt,
   250→        message: response.message,
   251→        promise: flowPromise,
   252→        resolve: flowResolve!,
   253→        reject: flowReject!,
   254→      });
   255→
   256→      logger.info("Device code flow initiated", {
   257→        sessionId,
   258→        userCode: response.userCode,
   259→        expiresAt: expiresAt.toISOString(),
   260→      });
   261→    },
   262→    timeout: 900, // 15 minutes
   263→  };
   264→
   265→  // Start the flow (don't await - it blocks until user completes)
   266→  const authPromise = app.acquireTokenByDeviceCode(deviceCodeRequest);
   267→
   268→  // Wait for the callback to be called (provides device code)
   269→  await new Promise<void>((resolve, reject) => {
   270→    const checkInterval = setInterval(() => {
   271→      if (capturedDeviceCode) {
   272→        clearInterval(checkInterval);
   273→        resolve();
   274→      }
   275→    }, 100);
   276→
   277→    // Timeout after 10 seconds if callback not called
   278→    setTimeout(() => {
   279→      clearInterval(checkInterval);
   280→      if (!capturedDeviceCode) {
   281→        reject(new Error("Device code callback timeout"));
   282→      }
   283→    }, 10_000);
   284→  });
   285→
   286→  const flow = activeFlows.get(sessionId);
   287→  // Cast is needed because TypeScript doesn't track assignment in async callbacks
   288→  const deviceCodeInfo = capturedDeviceCode as DeviceCodeResponse | null;
   289→  if (!flow || !deviceCodeInfo) {
   290→    throw new Error("Failed to initiate device code flow");
   291→  }
   292→
   293→  // Wire up the auth promise to resolve/reject the flow
   294→  authPromise
   295→    .then((result: AuthenticationResult | null) => {
   296→      logger.info("Device code flow completed", { sessionId });
   297→      flow.resolve(result);
   298→    })
   299→    .catch((error: Error) => {
   300→      // Log detailed error info for debugging network issues
   301→      const errorDetails = {
   302→        sessionId,
   303→        error: error.message,
   304→        name: error.name,
   305→        stack: error.stack?.split("\n").slice(0, 5).join("\n"),
   306→        cause: error.cause ? String(error.cause) : undefined,
   307→      };
   308→      logger.error("Device code flow failed", errorDetails);
   309→      flow.reject(error);
   310→    });
   311→
   312→  // Calculate expiration time from expiresIn (seconds)
   313→  const expiresAt = new Date(Date.now() + deviceCodeInfo.expiresIn * 1000);
   314→
   315→  return {
   316→    sessionId,
   317→    userCode: deviceCodeInfo.userCode,
   318→    verificationUri: deviceCodeInfo.verificationUri,
   319→    expiresAt,
   320→    message: deviceCodeInfo.message,
   321→  };
   322→}
   323→
   324→export interface PollResult {
   325→  status: "pending" | "complete" | "expired" | "error";
   326→  error?: string;
   327→  result?: {
   328→    accessToken: string;
   329→    expiresAt: Date;
   330→    scopes: string[];
   331→    account: AccountInfo | null;
   332→  };
   333→}
   334→
   335→/**
   336→ * Poll for device code completion
   337→ */
   338→export async function pollDeviceCodeFlow(
   339→  sessionId: string,
   340→): Promise<PollResult> {
   341→  logger.info("Poll called", {
   342→    sessionId,
   343→    activeFlowCount: activeFlows.size,
   344→    hasFlow: activeFlows.has(sessionId),
   345→  });
   346→
   347→  const flow = activeFlows.get(sessionId);
   348→
   349→  if (!flow) {
   350→    logger.info("Flow not found in activeFlows", { sessionId });
   351→    return { status: "expired" };
   352→  }
   353→
   354→  if (new Date() > flow.expiresAt) {
   355→    logger.info("Flow expired", { sessionId, expiresAt: flow.expiresAt });
   356→    activeFlows.delete(sessionId);
   357→    return { status: "expired" };
   358→  }
   359→
   360→  // Check if promise is resolved (non-blocking check)
   361→  const raceResult = await Promise.race([
   362→    flow.promise
   363→      .then((result) => ({ done: true as const, result, error: null }))
   364→      .catch((error) => ({ done: true as const, result: null, error })),
   365→    new Promise<{ done: false }>((resolve) =>
   366→      setTimeout(() => resolve({ done: false }), 100),
   367→    ),
   368→  ]);
   369→
   370→  if (!raceResult.done) {
   371→    return { status: "pending" };
   372→  }
   373→
   374→  // Flow completed - clean up
   375→  activeFlows.delete(sessionId);
   376→
   377→  if (raceResult.error) {
   378→    const errorMessage =
   379→      raceResult.error instanceof Error
   380→        ? raceResult.error.message
   381→        : String(raceResult.error);
   382→
   383→    // Check for user cancellation
   384→    if (errorMessage.includes("authorization_pending")) {
   385→      return { status: "pending" };
   386→    }
   387→
   388→    logger.error("Device code flow error", { sessionId, error: errorMessage });
   389→    return { status: "error", error: errorMessage };
   390→  }
   391→
   392→  if (!raceResult.result) {
   393→    return { status: "error", error: "No authentication result" };
   394→  }
   395→
   396→  return {
   397→    status: "complete",
   398→    result: {
   399→      accessToken: raceResult.result.accessToken,
   400→      expiresAt:
   401→        raceResult.result.expiresOn || new Date(Date.now() + 3_600_000),
   402→      scopes: raceResult.result.scopes,
   403→      account: raceResult.result.account,
   404→    },
   405→  };
   406→}
   407→
   408→/**
   409→ * Cancel an active device code flow
   410→ */
   411→export function cancelDeviceCodeFlow(sessionId: string): boolean {
   412→  const flow = activeFlows.get(sessionId);
   413→  if (flow) {
   414→    flow.reject(new Error("Flow cancelled by user"));
   415→    activeFlows.delete(sessionId);
   416→    logger.info("Device code flow cancelled", { sessionId });
   417→    return true;
   418→  }
   419→  return false;
   420→}
   421→
   422→/**
   423→ * Get count of active flows (for monitoring)
   424→ */
   425→export function getActiveFlowCount(): number {
   426→  cleanupExpiredFlows();
   427→  return activeFlows.size;
   428→}
   429→
   430→/**
   431→ * Acquire token silently from MSAL cache
   432→ * Used for device-code authenticated accounts to get fresh tokens for calendar operations
   433→ *
   434→ * @param providerAccountId - The MSAL account's localAccountId (stored as providerAccountId in DB)
   435→ * @param scopes - Optional scopes to request (defaults to .default which includes all permissions)
   436→ * @returns Token info or null if account not in cache
   437→ */
   438→export async function acquireMSALTokenSilent(
   439→  providerAccountId: string,
   440→  scopes: string[] = MSAL_DEVICE_CODE_SCOPES,
   441→): Promise<{
   442→  accessToken: string;
   443→  expiresAt: Date;
   444→  account: AccountInfo;
   445→} | null> {
   446→  if (!isMSALDeviceCodeEnabled()) {
   447→    logger.warn("MSAL device code flow is not enabled");
   448→    return null;
   449→  }
   450→
   451→  const app = getMSALApp();
   452→  const tokenCache = app.getTokenCache();
   453→
   454→  try {
   455→    // Get all accounts from MSAL cache
   456→    const accounts = await tokenCache.getAllAccounts();
   457→
   458→    if (accounts.length === 0) {
   459→      logger.info("No accounts found in MSAL cache");
   460→      return null;
   461→    }
   462→
   463→    // Find the account matching the providerAccountId
   464→    const account = accounts.find(
   465→      (acc: AccountInfo) => acc.localAccountId === providerAccountId,
   466→    );
   467→
   468→    if (!account) {
   469→      logger.info("Account not found in MSAL cache", {
   470→        providerAccountId,
   471→        cachedAccountIds: accounts.map((a: AccountInfo) => a.localAccountId),
   472→      });
   473→      return null;
   474→    }
   475→
   476→    // Acquire token silently using cached credentials
   477→    const result = await app.acquireTokenSilent({
   478→      account,
   479→      scopes,
   480→    });
   481→
   482→    if (!result) {
   483→      logger.warn("acquireTokenSilent returned null", { providerAccountId });
   484→      return null;
   485→    }
   486→
   487→    logger.info("Successfully acquired token silently", {
   488→      providerAccountId,
   489→      expiresOn: result.expiresOn?.toISOString(),
   490→    });
   491→
   492→    return {
   493→      accessToken: result.accessToken,
   494→      expiresAt: result.expiresOn || new Date(Date.now() + 3_600_000), // Default 1 hour
   495→      account,
   496→    };
   497→  } catch (error) {
   498→    logger.error("Failed to acquire token silently", {
   499→      providerAccountId,
   500→      error: error instanceof Error ? error.message : String(error),
   501→    });
   502→    return null;
   503→  }
   504→}
   505→
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:17:46.488Z)**_

<think><details><summary>Thought Process</summary>
Now I have a good understanding of the existing code. Let me create the MSAL cache plugin first, then update the msal-device-code.ts file to use it.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:17:46.998Z)**_

Now I'll create the MSAL cache plugin.

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:18:14.790Z)**_

<tool-use data-tool-type="write" data-tool-name="Write"><details>
<summary>Tool use: **Write**</summary>

```typescript
/**
 * MSAL Token Cache Persistence Plugin
 *
 * Implements ICachePlugin to persist MSAL's token cache to PostgreSQL.
 * This enables device-code authenticated accounts to refresh tokens
 * after server restarts.
 *
 * The cache is stored encrypted in the Account.msal_cache field.
 */

import type { ICachePlugin, TokenCacheContext } from "@azure/msal-node";
import prisma from "@/utils/prisma";
import { encryptToken, decryptToken } from "@/utils/encryption";
import { createScopedLogger } from "@/utils/logger";

const logger = createScopedLogger("msal-cache-plugin");

/**
 * Creates a Prisma-backed cache plugin for MSAL
 * Each instance is scoped to a specific Microsoft account (providerAccountId)
 */
export function createPrismaCachePlugin(
  providerAccountId: string,
): ICachePlugin {
  return {
    /**
     * Called before MSAL accesses the token cache
     * Loads the cache from the database if it exists
     */
    async beforeCacheAccess(cacheContext: TokenCacheContext): Promise<void> {
      try {
        const account = await prisma.account.findFirst({
          where: {
            provider: "microsoft",
            providerAccountId,
          },
          select: { msal_cache: true },
        });

        if (account?.msal_cache) {
          const decrypted = decryptToken(account.msal_cache);
          if (decrypted) {
            cacheContext.tokenCache.deserialize(decrypted);
            logger.info("Loaded MSAL cache from database", { providerAccountId });
          } else {
            logger.warn("Failed to decrypt MSAL cache", { providerAccountId });
          }
        }
      } catch (error) {
        logger.error("Failed to load MSAL cache from database", {
          providerAccountId,
          error: error instanceof Error ? error.message : String(error),
        });
        // Don't throw - allow MSAL to continue with empty cache
        // User will need to re-authenticate if cache can't be loaded
      }
    },

    /**
     * Called after MSAL modifies the token cache
     * Persists the cache to the database if it has changed
     */
    async afterCacheAccess(cacheContext: TokenCacheContext): Promise<void> {
      if (!cacheContext.cacheHasChanged) {
        return;
      }

      try {
        const serialized = cacheContext.tokenCache.serialize();
        const encrypted = encryptToken(serialized);

        if (!encrypted) {
          logger.error("Failed to encrypt MSAL cache", { providerAccountId });
          return;
        }

        await prisma.account.updateMany({
          where: {
            provider: "microsoft",
            providerAccountId,
          },
          data: {
            msal_cache: encrypted,
            msal_cache_updated: new Date(),
          },
        });

        logger.info("Persisted MSAL cache to database", { providerAccountId });
      } catch (error) {
        logger.error("Failed to persist MSAL cache to database", {
          providerAccountId,
          error: error instanceof Error ? error.message : String(error),
        });
        // Don't throw - cache will be re-populated on next successful token acquisition
      }
    },
  };
}

/**
 * Extracts the refresh token from a stored MSAL cache
 * Used as a fallback when MSAL silent acquisition fails but we have a stored cache
 *
 * MSAL cache JSON structure:
 * {
 *   "Account": { ... },
 *   "AccessToken": { ... },
 *   "RefreshToken": {
 *     "cache-key": {
 *       "secret": "actual-refresh-token",
 *       "home_account_id": "...",
 *       ...
 *     }
 *   },
 *   "IdToken": { ... }
 * }
 */
export async function extractRefreshTokenFromCache(
  providerAccountId: string,
): Promise<string | null> {
  try {
    const account = await prisma.account.findFirst({
      where: {
        provider: "microsoft",
        providerAccountId,
      },
      select: { msal_cache: true },
    });

    if (!account?.msal_cache) {
      logger.info("No MSAL cache found for account", { providerAccountId });
      return null;
    }

    const decrypted = decryptToken(account.msal_cache);
    if (!decrypted) {
      logger.warn("Failed to decrypt MSAL cache", { providerAccountId });
      return null;
    }

    const cache = JSON.parse(decrypted) as {
      RefreshToken?: Record<string, { secret?: string; home_account_id?: string }>;
    };
    const refreshTokens = cache.RefreshToken || {};

    // Find refresh token for this account
    // The cache key format is: {home_account_id}-{environment}-refreshtoken-{client_id}--
    for (const key of Object.keys(refreshTokens)) {
      const tokenEntry = refreshTokens[key];
      // Match by home_account_id containing the providerAccountId
      if (
        tokenEntry?.secret &&
        (key.toLowerCase().includes(providerAccountId.toLowerCase()) ||
          tokenEntry.home_account_id?.includes(providerAccountId))
      ) {
        logger.info("Found refresh token in MSAL cache", { providerAccountId });
        return tokenEntry.secret;
      }
    }

    // Fallback: return first available refresh token if only one account
    const tokenEntries = Object.values(refreshTokens);
    if (tokenEntries.length === 1 && tokenEntries[0]?.secret) {
      logger.info("Using single refresh token from MSAL cache", { providerAccountId });
      return tokenEntries[0].secret;
    }

    logger.warn("No matching refresh token found in MSAL cache", {
      providerAccountId,
      tokenCount: tokenEntries.length,
    });
    return null;
  } catch (error) {
    logger.error("Failed to extract refresh token from MSAL cache", {
      providerAccountId,
      error: error instanceof Error ? error.message : String(error),
    });
    return null;
  }
}

/**
 * Updates the refresh token in a stored MSAL cache
 * Called after a direct OAuth2 token refresh to keep the cache in sync
 */
export async function updateRefreshTokenInCache(
  providerAccountId: string,
  newRefreshToken: string,
): Promise<void> {
  try {
    const account = await prisma.account.findFirst({
      where: {
        provider: "microsoft",
        providerAccountId,
      },
      select: { msal_cache: true },
    });

    if (!account?.msal_cache) {
      logger.info("No MSAL cache to update", { providerAccountId });
      return;
    }

    const decrypted = decryptToken(account.msal_cache);
    if (!decrypted) {
      logger.warn("Failed to decrypt MSAL cache for update", { providerAccountId });
      return;
    }

    const cache = JSON.parse(decrypted) as {
      RefreshToken?: Record<string, { secret?: string }>;
    };
    const refreshTokens = cache.RefreshToken || {};

    // Update all refresh token entries for this account
    let updated = false;
    for (const key of Object.keys(refreshTokens)) {
      if (
        key.toLowerCase().includes(providerAccountId.toLowerCase()) ||
        Object.keys(refreshTokens).length === 1
      ) {
        if (refreshTokens[key]) {
          refreshTokens[key].secret = newRefreshToken;
          updated = true;
        }
      }
    }

    if (!updated) {
      logger.warn("No refresh token entry to update in MSAL cache", { providerAccountId });
      return;
    }

    cache.RefreshToken = refreshTokens;
    const encrypted = encryptToken(JSON.stringify(cache));

    if (!encrypted) {
      logger.error("Failed to encrypt updated MSAL cache", { providerAccountId });
      return;
    }

    await prisma.account.updateMany({
      where: {
        provider: "microsoft",
        providerAccountId,
      },
      data: {
        msal_cache: encrypted,
        msal_cache_updated: new Date(),
      },
    });

    logger.info("Updated refresh token in MSAL cache", { providerAccountId });
  } catch (error) {
    logger.error("Failed to update refresh token in MSAL cache", {
      providerAccountId,
      error: error instanceof Error ? error.message : String(error),
    });
  }
}

```
```
File created successfully at: /Users/hack/github/inbox-zero/apps/web/utils/outlook/msal-cache-plugin.ts
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:18:24.561Z)**_

<think><details><summary>Thought Process</summary>
Now I need to update the msal-device-code.ts file to:
1. Replace singleton with factory pattern
2. Add direct OAuth2 token refresh fallback
3. Update acquireMSALTokenSilent to use the fallback

Let me edit the msal-device-code.ts file.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:18:25.040Z)**_

<tool-use data-tool-type="unknown" data-tool-name="TaskUpdate"><details>
<summary>Tool use: **TaskUpdate**</summary>
```
Updated task #4 status
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:18:25.464Z)**_

<tool-use data-tool-type="unknown" data-tool-name="TaskUpdate"><details>
<summary>Tool use: **TaskUpdate**</summary>
```
Updated task #6 status
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:18:33.435Z)**_

<think><details><summary>Thought Process</summary>
The TypeScript error is just a transient diagnostic issue - the module exists and is imported in msal-device-code.ts. Let me continue with updating the msal-device-code.ts file to use the factory pattern and add the direct token refresh fallback.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:18:33.836Z)**_

Now let me update the msal-device-code.ts file to use the factory pattern and add direct token refresh.

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:18:38.053Z)**_

<tool-use data-tool-type="write" data-tool-name="Edit"><details>
<summary>Tool use: **Edit**</summary>
```
The file /Users/hack/github/inbox-zero/apps/web/utils/outlook/msal-device-code.ts has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
    10→ * - Integrates with existing token encryption system
    11→ * - Non-breaking: runs parallel to existing Better Auth OAuth
    12→ */
    13→
    14→import {
    15→  PublicClientApplication,
    16→  type DeviceCodeRequest,
    17→  type AuthenticationResult,
    18→  type AccountInfo,
    19→  type Configuration,
    20→  LogLevel,
    21→  type INetworkModule,
    22→  type NetworkRequestOptions,
    23→  type NetworkResponse,
    24→} from "@azure/msal-node";
    25→import { env } from "@/env";
    26→import { createScopedLogger } from "@/utils/logger";
    27→import prisma from "@/utils/prisma";
    28→import { encryptToken } from "@/utils/encryption";
    29→import {
    30→  createPrismaCachePlugin,
    31→  extractRefreshTokenFromCache,
    32→  updateRefreshTokenInCache,
    33→} from "./msal-cache-plugin";
    34→
    35→/**
    36→ * Custom network module to handle fetch issues in Node.js 22+
    37→ * Uses fresh fetch calls with abort controller timeouts to avoid
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:18:47.338Z)**_

<think><details><summary>Thought Process</summary>
Good, the imports are added. Now I need to replace the singleton pattern with a factory pattern. Let me update the getMSALApp function.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:18:47.627Z)**_

Now let me update the singleton pattern to a factory pattern.

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:19:05.397Z)**_

<tool-use data-tool-type="write" data-tool-name="Edit"><details>
<summary>Tool use: **Edit**</summary>
```
The file /Users/hack/github/inbox-zero/apps/web/utils/outlook/msal-device-code.ts has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
   114→}
   115→
   116→const logger = createScopedLogger("msal-device-code");
   117→
   118→// Default Microsoft Office client ID - works without app registration
   119→const MICROSOFT_OFFICE_CLIENT_ID = "d3590ed6-52b3-4102-aeff-aad2292ab01c";
   120→
   121→// MSAL application instances cache
   122→// Key: providerAccountId or "default" for device code initiation
   123→// Use globalThis to persist across Next.js hot reloads in development
   124→const globalForMsalApps = globalThis as unknown as {
   125→  msalAppCache: Map<string, PublicClientApplication> | undefined;
   126→};
   127→
   128→const msalAppCache =
   129→  globalForMsalApps.msalAppCache ?? new Map<string, PublicClientApplication>();
   130→
   131→if (process.env.NODE_ENV !== "production") {
   132→  globalForMsalApps.msalAppCache = msalAppCache;
   133→}
   134→
   135→/**
   136→ * Get or create an MSAL application instance
   137→ *
   138→ * @param providerAccountId - Optional account ID for per-account cache plugin.
   139→ *                           If provided, creates instance with Prisma cache plugin.
   140→ *                           If not provided, uses default instance (for device code initiation).
   141→ */
   142→export function getMSALApp(providerAccountId?: string): PublicClientApplication {
   143→  const cacheKey = providerAccountId || "default";
   144→
   145→  if (msalAppCache.has(cacheKey)) {
   146→    return msalAppCache.get(cacheKey)!;
   147→  }
   148→
   149→  const clientId =
   150→    env.MSAL_CLIENT_ID ||
   151→    env.MICROSOFT_CLIENT_ID ||
   152→    MICROSOFT_OFFICE_CLIENT_ID;
   153→  const tenantId = env.MSAL_TENANT_ID || env.MICROSOFT_TENANT_ID || "common";
   154→  const debugEnabled = env.MSAL_DEBUG === "true";
   155→
   156→  const config: Configuration = {
   157→    auth: {
   158→      clientId,
   159→      authority: `https://login.microsoftonline.com/${tenantId}`,
   160→    },
   161→    system: {
   162→      loggerOptions: {
   163→        loggerCallback: (
   164→          level: LogLevel,
   165→          message: string,
   166→          containsPii: boolean,
   167→        ) => {
   168→          if (containsPii) return; // Don't log PII
   169→          if (debugEnabled || level === LogLevel.Error) {
   170→            logger.info(`MSAL [${LogLevel[level]}]: ${message}`);
   171→          }
   172→        },
   173→        piiLoggingEnabled: false,
   174→        logLevel: debugEnabled ? LogLevel.Verbose : LogLevel.Error,
   175→      },
   176→      // Use custom network module to avoid Node.js 22+ undici connection pool issues
   177→      networkClient: new CustomNetworkModule(),
   178→    },
   179→  };
   180→
   181→  // Add cache plugin for known accounts to enable persistent token storage
   182→  if (providerAccountId) {
   183→    config.cache = {
   184→      cachePlugin: createPrismaCachePlugin(providerAccountId),
   185→    };
   186→  }
   187→
   188→  const app = new PublicClientApplication(config);
   189→  msalAppCache.set(cacheKey, app);
   190→
   191→  return app;
   192→}
   193→
   194→/**
   195→ * Get MSAL configuration values
   196→ * Exported for use in direct token refresh
   197→ */
   198→export function getMSALConfig(): { clientId: string; tenantId: string } {
   199→  return {
   200→    clientId:
   201→      env.MSAL_CLIENT_ID ||
   202→      env.MICROSOFT_CLIENT_ID ||
   203→      MICROSOFT_OFFICE_CLIENT_ID,
   204→    tenantId: env.MSAL_TENANT_ID || env.MICROSOFT_TENANT_ID || "common",
   205→  };
   206→}
   207→
   208→// Feature flag - defaults to disabled until explicitly enabled
   209→export function isMSALDeviceCodeEnabled(): boolean {
   210→  return env.MSAL_ENABLED === "true";
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:19:17.059Z)**_

<think><details><summary>Thought Process</summary>
Good progress. Now I need to:
1. Update acquireMSALTokenSilent to use the factory pattern and add direct fallback
2. Add the direct token refresh function

Let me read the current acquireMSALTokenSilent function to see what I need to update.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:19:17.620Z)**_

<tool-use data-tool-type="unknown" data-tool-name="TaskUpdate"><details>
<summary>Tool use: **TaskUpdate**</summary>
```
Updated task #6 status
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:19:18.010Z)**_

<tool-use data-tool-type="unknown" data-tool-name="TaskUpdate"><details>
<summary>Tool use: **TaskUpdate**</summary>
```
Updated task #2 status
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:19:25.693Z)**_

<think><details><summary>Thought Process</summary>
Now I need to add the direct token refresh function and update acquireMSALTokenSilent. Let me read the end of the file to see the current function.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:19:26.727Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./apps/web/utils/outlook/msal-device-code.ts`
```
   480→export function getActiveFlowCount(): number {
   481→  cleanupExpiredFlows();
   482→  return activeFlows.size;
   483→}
   484→
   485→/**
   486→ * Acquire token silently from MSAL cache
   487→ * Used for device-code authenticated accounts to get fresh tokens for calendar operations
   488→ *
   489→ * @param providerAccountId - The MSAL account's localAccountId (stored as providerAccountId in DB)
   490→ * @param scopes - Optional scopes to request (defaults to .default which includes all permissions)
   491→ * @returns Token info or null if account not in cache
   492→ */
   493→export async function acquireMSALTokenSilent(
   494→  providerAccountId: string,
   495→  scopes: string[] = MSAL_DEVICE_CODE_SCOPES,
   496→): Promise<{
   497→  accessToken: string;
   498→  expiresAt: Date;
   499→  account: AccountInfo;
   500→} | null> {
   501→  if (!isMSALDeviceCodeEnabled()) {
   502→    logger.warn("MSAL device code flow is not enabled");
   503→    return null;
   504→  }
   505→
   506→  const app = getMSALApp();
   507→  const tokenCache = app.getTokenCache();
   508→
   509→  try {
   510→    // Get all accounts from MSAL cache
   511→    const accounts = await tokenCache.getAllAccounts();
   512→
   513→    if (accounts.length === 0) {
   514→      logger.info("No accounts found in MSAL cache");
   515→      return null;
   516→    }
   517→
   518→    // Find the account matching the providerAccountId
   519→    const account = accounts.find(
   520→      (acc: AccountInfo) => acc.localAccountId === providerAccountId,
   521→    );
   522→
   523→    if (!account) {
   524→      logger.info("Account not found in MSAL cache", {
   525→        providerAccountId,
   526→        cachedAccountIds: accounts.map((a: AccountInfo) => a.localAccountId),
   527→      });
   528→      return null;
   529→    }
   530→
   531→    // Acquire token silently using cached credentials
   532→    const result = await app.acquireTokenSilent({
   533→      account,
   534→      scopes,
   535→    });
   536→
   537→    if (!result) {
   538→      logger.warn("acquireTokenSilent returned null", { providerAccountId });
   539→      return null;
   540→    }
   541→
   542→    logger.info("Successfully acquired token silently", {
   543→      providerAccountId,
   544→      expiresOn: result.expiresOn?.toISOString(),
   545→    });
   546→
   547→    return {
   548→      accessToken: result.accessToken,
   549→      expiresAt: result.expiresOn || new Date(Date.now() + 3_600_000), // Default 1 hour
   550→      account,
   551→    };
   552→  } catch (error) {
   553→    logger.error("Failed to acquire token silently", {
   554→      providerAccountId,
   555→      error: error instanceof Error ? error.message : String(error),
   556→    });
   557→    return null;
   558→  }
   559→}
   560→
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:19:36.773Z)**_

<think><details><summary>Thought Process</summary>
Now I need to:
1. Add the directTokenRefresh function
2. Update acquireMSALTokenSilent to use the factory pattern with providerAccountId and add the fallback

Let me first replace the acquireMSALTokenSilent function with the updated version, and then add the new directTokenRefresh function.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:19:37.445Z)**_

Now let me update the `acquireMSALTokenSilent` function to use the factory pattern and add the direct refresh fallback.

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:20:03.813Z)**_

<tool-use data-tool-type="write" data-tool-name="Edit"><details>
<summary>Tool use: **Edit**</summary>
```
The file /Users/hack/github/inbox-zero/apps/web/utils/outlook/msal-device-code.ts has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
   481→  cleanupExpiredFlows();
   482→  return activeFlows.size;
   483→}
   484→
   485→/**
   486→ * Direct OAuth2 token refresh using Microsoft token endpoint
   487→ * Fallback for when MSAL silent acquisition fails but we have a stored refresh token
   488→ *
   489→ * @param providerAccountId - The account's providerAccountId
   490→ * @param scopes - Scopes to request
   491→ * @returns Token info or null if refresh fails
   492→ */
   493→async function directTokenRefresh(
   494→  providerAccountId: string,
   495→  scopes: string[] = MSAL_DEVICE_CODE_SCOPES,
   496→): Promise<{
   497→  accessToken: string;
   498→  expiresAt: Date;
   499→  account: AccountInfo;
   500→} | null> {
   501→  logger.info("Attempting direct token refresh", { providerAccountId });
   502→
   503→  const refreshToken = await extractRefreshTokenFromCache(providerAccountId);
   504→
   505→  if (!refreshToken) {
   506→    logger.warn("No refresh token available for direct refresh", { providerAccountId });
   507→    return null;
   508→  }
   509→
   510→  const { clientId, tenantId } = getMSALConfig();
   511→
   512→  try {
   513→    const response = await fetch(
   514→      `https://login.microsoftonline.com/${tenantId}/oauth2/v2.0/token`,
   515→      {
   516→        method: "POST",
   517→        headers: {
   518→          "Content-Type": "application/x-www-form-urlencoded",
   519→        },
   520→        body: new URLSearchParams({
   521→          client_id: clientId,
   522→          refresh_token: refreshToken,
   523→          grant_type: "refresh_token",
   524→          scope: scopes.join(" "),
   525→        }),
   526→      },
   527→    );
   528→
   529→    const tokens = (await response.json()) as {
   530→      access_token?: string;
   531→      refresh_token?: string;
   532→      expires_in?: number;
   533→      error?: string;
   534→      error_description?: string;
   535→    };
   536→
   537→    if (!response.ok || !tokens.access_token) {
   538→      logger.error("Direct token refresh failed", {
   539→        providerAccountId,
   540→        error: tokens.error_description || tokens.error || "Unknown error",
   541→        status: response.status,
   542→      });
   543→      return null;
   544→    }
   545→
   546→    logger.info("Direct token refresh successful", { providerAccountId });
   547→
   548→    const expiresAt = new Date(Date.now() + (tokens.expires_in || 3600) * 1000);
   549→
   550→    // Update stored access token in Account table
   551→    const encryptedAccessToken = encryptToken(tokens.access_token);
   552→    if (encryptedAccessToken) {
   553→      await prisma.account.updateMany({
   554→        where: {
   555→          provider: "microsoft",
   556→          providerAccountId,
   557→        },
   558→        data: {
   559→          access_token: encryptedAccessToken,
   560→          expires_at: expiresAt,
   561→        },
   562→      });
   563→    }
   564→
   565→    // If we got a new refresh token, update the MSAL cache
   566→    if (tokens.refresh_token) {
   567→      await updateRefreshTokenInCache(providerAccountId, tokens.refresh_token);
   568→    }
   569→
   570→    return {
   571→      accessToken: tokens.access_token,
   572→      expiresAt,
   573→      account: {
   574→        localAccountId: providerAccountId,
   575→        homeAccountId: providerAccountId,
   576→        environment: "login.microsoftonline.com",
   577→        tenantId,
   578→        username: "",
   579→      } as AccountInfo,
   580→    };
   581→  } catch (error) {
   582→    logger.error("Direct token refresh error", {
   583→      providerAccountId,
   584→      error: error instanceof Error ? error.message : String(error),
   585→    });
   586→    return null;
   587→  }
   588→}
   589→
   590→/**
   591→ * Acquire token silently from MSAL cache with direct refresh fallback
   592→ * Used for device-code authenticated accounts to get fresh tokens
   593→ *
   594→ * Strategy:
   595→ * 1. Try MSAL silent acquisition (uses persistent cache plugin)
   596→ * 2. If MSAL cache empty or fails, try direct OAuth2 token refresh
   597→ * 3. Return null if both fail (user must re-authenticate)
   598→ *
   599→ * @param providerAccountId - The MSAL account's localAccountId (stored as providerAccountId in DB)
   600→ * @param scopes - Optional scopes to request (defaults to .default which includes all permissions)
   601→ * @returns Token info or null if both methods fail
   602→ */
   603→export async function acquireMSALTokenSilent(
   604→  providerAccountId: string,
   605→  scopes: string[] = MSAL_DEVICE_CODE_SCOPES,
   606→): Promise<{
   607→  accessToken: string;
   608→  expiresAt: Date;
   609→  account: AccountInfo;
   610→} | null> {
   611→  if (!isMSALDeviceCodeEnabled()) {
   612→    logger.warn("MSAL device code flow is not enabled");
   613→    return null;
   614→  }
   615→
   616→  // Use per-account MSAL instance with cache plugin for persistent storage
   617→  const app = getMSALApp(providerAccountId);
   618→  const tokenCache = app.getTokenCache();
   619→
   620→  try {
   621→    // Get all accounts from MSAL cache (will load from DB via cache plugin)
   622→    const accounts = await tokenCache.getAllAccounts();
   623→
   624→    if (accounts.length === 0) {
   625→      logger.info("No accounts found in MSAL cache, trying direct refresh", {
   626→        providerAccountId,
   627→      });
   628→      return await directTokenRefresh(providerAccountId, scopes);
   629→    }
   630→
   631→    // Find the account matching the providerAccountId
   632→    const account = accounts.find(
   633→      (acc: AccountInfo) => acc.localAccountId === providerAccountId,
   634→    );
   635→
   636→    if (!account) {
   637→      logger.info("Account not found in MSAL cache, trying direct refresh", {
   638→        providerAccountId,
   639→        cachedAccountIds: accounts.map((a: AccountInfo) => a.localAccountId),
   640→      });
   641→      return await directTokenRefresh(providerAccountId, scopes);
   642→    }
   643→
   644→    // Acquire token silently using cached credentials
   645→    const result = await app.acquireTokenSilent({
   646→      account,
   647→      scopes,
   648→    });
   649→
   650→    if (!result) {
   651→      logger.warn("acquireTokenSilent returned null, trying direct refresh", {
   652→        providerAccountId,
   653→      });
   654→      return await directTokenRefresh(providerAccountId, scopes);
   655→    }
   656→
   657→    logger.info("Successfully acquired token silently", {
   658→      providerAccountId,
   659→      expiresOn: result.expiresOn?.toISOString(),
   660→    });
   661→
   662→    return {
   663→      accessToken: result.accessToken,
   664→      expiresAt: result.expiresOn || new Date(Date.now() + 3_600_000),
   665→      account,
   666→    };
   667→  } catch (error) {
   668→    logger.error("Failed to acquire token silently, trying direct refresh", {
   669→      providerAccountId,
   670→      error: error instanceof Error ? error.message : String(error),
   671→    });
   672→    return await directTokenRefresh(providerAccountId, scopes);
   673→  }
   674→}
   675→
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:20:15.649Z)**_

<think><details><summary>Thought Process</summary>
Tasks 2 and 3 are now complete. Let me update the task status and then work on task 1 - persisting the MSAL cache after initial auth in the poll route.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:20:16.050Z)**_

<tool-use data-tool-type="unknown" data-tool-name="TaskUpdate"><details>
<summary>Tool use: **TaskUpdate**</summary>
```
Updated task #2 status
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:20:16.345Z)**_

<tool-use data-tool-type="unknown" data-tool-name="TaskUpdate"><details>
<summary>Tool use: **TaskUpdate**</summary>
```
Updated task #3 status
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:20:16.869Z)**_

<tool-use data-tool-type="unknown" data-tool-name="TaskUpdate"><details>
<summary>Tool use: **TaskUpdate**</summary>
```
Updated task #1 status
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:20:26.709Z)**_

<think><details><summary>Thought Process</summary>
Now I need to update the poll/route.ts to persist the MSAL cache after successful device-code authentication. Let me read that file to find the right place to add the cache persistence.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:20:27.241Z)**_

Now let me update the poll route to persist the MSAL cache after initial authentication.

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:20:28.516Z)**_

<tool-use data-tool-type="read" data-tool-name="Read"><details>
<summary>Tool use: **Read**</summary>
 `./apps/web/app/api/outlook/device-code/poll/route.ts`
```
     1→import { type NextRequest, NextResponse } from "next/server";
     2→import { z } from "zod";
     3→import { serializeSignedCookie } from "better-call";
     4→import {
     5→  pollDeviceCodeFlow,
     6→  isMSALDeviceCodeEnabled,
     7→} from "@/utils/outlook/msal-device-code";
     8→import { createOutlookClient } from "@/utils/outlook/client";
     9→import { encryptToken } from "@/utils/encryption";
    10→import { createScopedLogger } from "@/utils/logger";
    11→import prisma from "@/utils/prisma";
    12→import { env } from "@/env";
    13→import { WELCOME_PATH } from "@/utils/config";
    14→
    15→const logger = createScopedLogger("api:msal:device-code:poll");
    16→
    17→interface CompletionResult {
    18→  email: string;
    19→  redirectUrl: string;
    20→  message: string;
    21→  signedSessionToken: string;
    22→  sessionExpires: Date;
    23→}
    24→
    25→interface CompletionEntry {
    26→  promise: Promise<CompletionResult>;
    27→  expiresAt: Date;
    28→}
    29→
    30→type PollCompleteResult = NonNullable<
    31→  Awaited<ReturnType<typeof pollDeviceCodeFlow>>["result"]
    32→>;
    33→
    34→const COMPLETION_CACHE_TTL_MS = 5 * 60 * 1000;
    35→const completionCache = getCompletionCache();
    36→
    37→const pollRequestSchema = z.object({
    38→  sessionId: z.string().min(1, "Session ID is required"),
    39→});
    40→
    41→export async function POST(request: NextRequest) {
    42→  if (!isMSALDeviceCodeEnabled()) {
    43→    return NextResponse.json(
    44→      { error: "MSAL device code authentication is not enabled" },
    45→      { status: 403 },
    46→    );
    47→  }
    48→
    49→  try {
    50→    const body = await request.json();
    51→    const { sessionId } = pollRequestSchema.parse(body);
    52→
    53→    logger.info("Poll request received", { sessionId });
    54→
    55→    cleanupCompletionCache();
    56→    const cachedCompletion = completionCache.get(sessionId);
    57→    if (cachedCompletion) {
    58→      return respondWithCompletionPromise({
    59→        sessionId,
    60→        entry: cachedCompletion,
    61→      });
    62→    }
    63→
    64→    const pollResult = await pollDeviceCodeFlow(sessionId);
    65→
    66→    logger.info("Poll result", { sessionId, status: pollResult.status });
    67→
    68→    if (pollResult.status === "pending") {
    69→      return NextResponse.json({ status: "pending" });
    70→    }
    71→
    72→    if (pollResult.status === "expired") {
    73→      const completedEntry = completionCache.get(sessionId);
    74→      if (completedEntry) {
    75→        return respondWithCompletionPromise({
    76→          sessionId,
    77→          entry: completedEntry,
    78→        });
    79→      }
    80→      logger.info("Flow expired or not found", { sessionId });
    81→      return NextResponse.json({ status: "expired" });
    82→    }
    83→
    84→    if (pollResult.status === "error") {
    85→      logger.error("Flow error", { sessionId, error: pollResult.error });
    86→      return NextResponse.json({
    87→        status: "error",
    88→        error: pollResult.error,
    89→      });
    90→    }
    91→
    92→    // Authentication complete - create/update account
    93→    if (pollResult.status === "complete" && pollResult.result) {
    94→      const completionPromise = completeDeviceCodeAuthentication({
    95→        pollResult: pollResult.result,
    96→        request,
    97→      });
    98→
    99→      completionCache.set(sessionId, {
   100→        promise: completionPromise,
   101→        expiresAt: new Date(Date.now() + COMPLETION_CACHE_TTL_MS),
   102→      });
   103→
   104→      return respondWithCompletionPromise({
   105→        sessionId,
   106→        entry: completionCache.get(sessionId)!,
   107→      });
   108→    }
   109→
   110→    return NextResponse.json({ status: pollResult.status });
   111→  } catch (error) {
   112→    if (error instanceof z.ZodError) {
   113→      return NextResponse.json(
   114→        { status: "error", error: "Invalid request body" },
   115→        { status: 400 },
   116→      );
   117→    }
   118→
   119→    logger.error("Poll failed", { error });
   120→    return NextResponse.json(
   121→      { status: "error", error: "Poll failed" },
   122→      { status: 500 },
   123→    );
   124→  }
   125→}
   126→
   127→async function respondWithCompletionPromise({
   128→  sessionId,
   129→  entry,
   130→}: {
   131→  sessionId: string;
   132→  entry: CompletionEntry;
   133→}): Promise<NextResponse> {
   134→  try {
   135→    const completion = await entry.promise;
   136→    return buildCompletionResponse(completion);
   137→  } catch (error) {
   138→    const errorMessage =
   139→      error instanceof Error ? error.message : "Authentication failed";
   140→    logger.error("MSAL device code completion failed", {
   141→      sessionId,
   142→      error: errorMessage,
   143→    });
   144→    return NextResponse.json({ status: "error", error: errorMessage });
   145→  }
   146→}
   147→
   148→async function completeDeviceCodeAuthentication({
   149→  pollResult,
   150→  request,
   151→}: {
   152→  pollResult: PollCompleteResult;
   153→  request: NextRequest;
   154→}): Promise<CompletionResult> {
   155→  const { accessToken, expiresAt, scopes, account } = pollResult;
   156→
   157→  if (!account) {
   158→    throw new Error("No account info in token response");
   159→  }
   160→
   161→  // Get user profile from Microsoft Graph
   162→  const client = createOutlookClient(accessToken, logger);
   163→  const profile = await client.getUserProfile();
   164→
   165→  const email =
   166→    profile.mail?.toLowerCase() || profile.userPrincipalName?.toLowerCase();
   167→  const name = profile.displayName;
   168→  const providerAccountId = account.localAccountId;
   169→
   170→  if (!email) {
   171→    throw new Error("Could not determine user email");
   172→  }
   173→
   174→  // Encrypt tokens
   175→  const encryptedAccessToken = encryptToken(accessToken);
   176→
   177→  // Find or create user
   178→  let user = await prisma.user.findUnique({
   179→    where: { email },
   180→  });
   181→
   182→  if (!user) {
   183→    user = await prisma.user.create({
   184→      data: {
   185→        email,
   186→        name: name || email,
   187→        emailVerified: true,
   188→      },
   189→    });
   190→    logger.info("Created new user via MSAL device code", { email });
   191→  }
   192→
   193→  // Create or update account
   194→  // Note: MSAL device code flow doesn't provide refresh_token directly
   195→  // The token cache handles refresh internally, but for our purposes
   196→  // we need to use the existing OAuth refresh mechanism
   197→  const accountRecord = await prisma.account.upsert({
   198→    where: {
   199→      provider_providerAccountId: {
   200→        provider: "microsoft",
   201→        providerAccountId,
   202→      },
   203→    },
   204→    create: {
   205→      userId: user.id,
   206→      provider: "microsoft",
   207→      providerAccountId,
   208→      access_token: encryptedAccessToken,
   209→      refresh_token: null, // MSAL doesn't expose refresh token
   210→      expires_at: expiresAt,
   211→      token_type: "Bearer",
   212→      scope: scopes.join(" "),
   213→    },
   214→    update: {
   215→      access_token: encryptedAccessToken,
   216→      expires_at: expiresAt,
   217→      scope: scopes.join(" "),
   218→    },
   219→  });
   220→
   221→  logger.info("MSAL device code authentication complete", {
   222→    email,
   223→    providerAccountId,
   224→  });
   225→
   226→  await prisma.$transaction([
   227→    prisma.emailAccount.upsert({
   228→      where: { email },
   229→      update: {
   230→        userId: user.id,
   231→        accountId: accountRecord.id,
   232→        name: name || email,
   233→      },
   234→      create: {
   235→        email,
   236→        userId: user.id,
   237→        accountId: accountRecord.id,
   238→        name: name || email,
   239→      },
   240→    }),
   241→    prisma.account.update({
   242→      where: { id: accountRecord.id },
   243→      data: { disconnectedAt: null },
   244→    }),
   245→  ]);
   246→
   247→  // Create a Better Auth session for the user
   248→  const sessionToken = crypto.randomUUID();
   249→  const sessionExpires = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000); // 30 days
   250→
   251→  await prisma.session.create({
   252→    data: {
   253→      sessionToken,
   254→      userId: user.id,
   255→      expires: sessionExpires,
   256→      ipAddress: request.headers.get("x-forwarded-for") || "unknown",
   257→      userAgent: request.headers.get("user-agent") || "unknown",
   258→    },
   259→  });
   260→
   261→  logger.info("Created session for MSAL device code user", {
   262→    email,
   263→    userId: user.id,
   264→  });
   265→
   266→  const signedSessionToken = await signSessionToken(sessionToken);
   267→
   268→  return {
   269→    email,
   270→    redirectUrl: WELCOME_PATH,
   271→    message: "Authentication successful! Redirecting...",
   272→    signedSessionToken,
   273→    sessionExpires,
   274→  };
   275→}
   276→
   277→function buildCompletionResponse({
   278→  email,
   279→  redirectUrl,
   280→  message,
   281→  signedSessionToken,
   282→  sessionExpires,
   283→}: CompletionResult): NextResponse {
   284→  const isProduction = env.NODE_ENV === "production";
   285→  const cookieName = getSessionCookieName(isProduction);
   286→  const response = NextResponse.json({
   287→    status: "complete",
   288→    email,
   289→    redirectUrl,
   290→    message,
   291→  });
   292→
   293→  response.cookies.set(cookieName, signedSessionToken, {
   294→    httpOnly: true,
   295→    secure: isProduction,
   296→    sameSite: "lax",
   297→    path: "/",
   298→    expires: sessionExpires,
   299→  });
   300→
   301→  logger.info("Set session cookie", {
   302→    cookieName,
   303→    email,
   304→  });
   305→
   306→  return response;
   307→}
   308→
   309→async function signSessionToken(sessionToken: string): Promise<string> {
   310→  const secret = env.AUTH_SECRET || env.NEXTAUTH_SECRET;
   311→  if (!secret) {
   312→    throw new Error("Missing auth secret for session cookie signing");
   313→  }
   314→  const signed = await serializeSignedCookie("", sessionToken, secret);
   315→  return normalizeSignedCookie(signed);
   316→}
   317→
   318→function normalizeSignedCookie(signed: string): string {
   319→  const decodedOnce = decodeURIComponent(signed);
   320→  const decodedTwice = decodedOnce.includes("%")
   321→    ? decodeURIComponent(decodedOnce)
   322→    : decodedOnce;
   323→  return decodedTwice.replace(/^=/, "");
   324→}
   325→
   326→function getSessionCookieName(isProduction: boolean): string {
   327→  return isProduction
   328→    ? "__Secure-better-auth.session_token"
   329→    : "better-auth.session_token";
   330→}
   331→
   332→function cleanupCompletionCache(): void {
   333→  const now = Date.now();
   334→  for (const [sessionId, entry] of completionCache.entries()) {
   335→    if (entry.expiresAt.getTime() <= now) {
   336→      completionCache.delete(sessionId);
   337→    }
   338→  }
   339→}
   340→
   341→function getCompletionCache(): Map<string, CompletionEntry> {
   342→  const globalForCompletion = globalThis as unknown as {
   343→    msalCompletionCache: Map<string, CompletionEntry> | undefined;
   344→  };
   345→
   346→  const cache = globalForCompletion.msalCompletionCache ?? new Map();
   347→  if (process.env.NODE_ENV !== "production") {
   348→    globalForCompletion.msalCompletionCache = cache;
   349→  }
   350→
   351→  return cache;
   352→}
   353→
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:20:39.918Z)**_

<think><details><summary>Thought Process</summary>
Now I need to update the completeDeviceCodeAuthentication function to persist the MSAL cache after the account is created. I need to:
1. Import getMSALApp from msal-device-code
2. After the account is created, serialize the MSAL cache and store it

Let me add the import and then add the cache persistence after the account upsert.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:20:40.543Z)**_

Let me update the poll route to import getMSALApp and persist the cache after authentication.

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:20:43.920Z)**_

<tool-use data-tool-type="write" data-tool-name="Edit"><details>
<summary>Tool use: **Edit**</summary>
```
The file /Users/hack/github/inbox-zero/apps/web/app/api/outlook/device-code/poll/route.ts has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
     1→import { type NextRequest, NextResponse } from "next/server";
     2→import { z } from "zod";
     3→import { serializeSignedCookie } from "better-call";
     4→import {
     5→  pollDeviceCodeFlow,
     6→  isMSALDeviceCodeEnabled,
     7→  getMSALApp,
     8→} from "@/utils/outlook/msal-device-code";
     9→import { createOutlookClient } from "@/utils/outlook/client";
    10→import { encryptToken } from "@/utils/encryption";
    11→import { createScopedLogger } from "@/utils/logger";
    12→import prisma from "@/utils/prisma";
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:20:54.560Z)**_

<think><details><summary>Thought Process</summary>
Good, now I need to add the cache persistence after the account is created. Let me edit the completeDeviceCodeAuthentication function to add cache persistence after the account upsert.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:20:54.812Z)**_

Now let me add the cache persistence after the account is created.

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:21:01.263Z)**_

<tool-use data-tool-type="write" data-tool-name="Edit"><details>
<summary>Tool use: **Edit**</summary>
```
The file /Users/hack/github/inbox-zero/apps/web/app/api/outlook/device-code/poll/route.ts has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
   218→      scope: scopes.join(" "),
   219→    },
   220→  });
   221→
   222→  logger.info("MSAL device code authentication complete", {
   223→    email,
   224→    providerAccountId,
   225→  });
   226→
   227→  // Persist the MSAL cache for future token refresh
   228→  // This enables token refresh to survive server restarts
   229→  try {
   230→    const app = getMSALApp();
   231→    const tokenCache = app.getTokenCache();
   232→    const serializedCache = tokenCache.serialize();
   233→
   234→    if (serializedCache) {
   235→      const encryptedCache = encryptToken(serializedCache);
   236→      if (encryptedCache) {
   237→        await prisma.account.updateMany({
   238→          where: {
   239→            provider: "microsoft",
   240→            providerAccountId,
   241→          },
   242→          data: {
   243→            msal_cache: encryptedCache,
   244→            msal_cache_updated: new Date(),
   245→          },
   246→        });
   247→        logger.info("Persisted initial MSAL cache", { providerAccountId });
   248→      }
   249→    }
   250→  } catch (cacheError) {
   251→    // Non-fatal - log but don't fail the auth flow
   252→    // Cache will be re-populated on next successful token acquisition
   253→    logger.error("Failed to persist initial MSAL cache", {
   254→      providerAccountId,
   255→      error: cacheError instanceof Error ? cacheError.message : String(cacheError),
   256→    });
   257→  }
   258→
   259→  await prisma.$transaction([
   260→    prisma.emailAccount.upsert({
   261→      where: { email },
   262→      update: {
   263→        userId: user.id,
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:21:13.357Z)**_

<think><details><summary>Thought Process</summary>
All the tasks are now complete. Let me update the task status and then run a quick check to make sure everything compiles.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:21:13.794Z)**_

<tool-use data-tool-type="unknown" data-tool-name="TaskUpdate"><details>
<summary>Tool use: **TaskUpdate**</summary>
```
Updated task #1 status
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:21:21.998Z)**_

<think><details><summary>Thought Process</summary>
All tasks are complete. Let me run a type check to make sure everything compiles correctly.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:21:22.035Z)**_

<tool-use data-tool-type="unknown" data-tool-name="TaskList"><details>
<summary>Tool use: **TaskList**</summary>
```
No tasks found
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:21:29.752Z)**_

<think><details><summary>Thought Process</summary>
All tasks are completed. Let me run TypeScript type checking to ensure the implementation is correct.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:21:30.312Z)**_

Let me run the TypeScript check to verify the implementation compiles.

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:21:31.842Z)**_

<tool-use data-tool-type="shell" data-tool-name="Bash"><details>
<summary>Tool use: **Bash**</summary>
Type check the new MSAL cache persistence code

`cd /Users/hack/github/inbox-zero/apps/web && npx tsc --noEmit --skipLibCheck 2>&1 | head -50`
```
app/(app)/[emailAccountId]/stats/EmailActionsAnalytics.tsx(15,3): error TS1005: ',' expected.
app/(app)/[emailAccountId]/stats/EmailActionsAnalytics.tsx(15,13): error TS1005: ',' expected.
app/(app)/[emailAccountId]/stats/MainStatChart.tsx(18,3): error TS1005: ',' expected.
app/(app)/[emailAccountId]/stats/MainStatChart.tsx(18,13): error TS1005: ',' expected.
tsconfig.json(2,14): error TS6053: File 'tsconfig/nextjs.json' not found.
utils/actions/clean.ts(163,19): error TS1005: ',' expected.
utils/actions/clean.ts(163,29): error TS1005: ',' expected.
utils/brands.ts(45,12): error TS1005: ',' expected.
utils/brands.ts(45,22): error TS1005: ',' expected.
utils/brands.ts(45,28): error TS1005: ',' expected.
utils/brands.ts(45,35): error TS1005: '>' expected.
utils/brands.ts(45,43): error TS1109: Expression expected.
utils/brands.ts(69,3): error TS1005: ',' expected.
utils/brands.ts(69,13): error TS1005: ',' expected.
utils/brands.ts(69,19): error TS1005: ',' expected.
utils/brands.ts(69,26): error TS1005: '>' expected.
utils/brands.ts(69,34): error TS1011: An element access expression should take an argument.
utils/brands.ts(69,36): error TS1109: Expression expected.
utils/upstash/categorize-senders.ts(52,11): error TS1005: ',' expected.
utils/upstash/categorize-senders.ts(52,21): error TS1005: ',' expected.
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:22:10.793Z)**_

<think><details><summary>Thought Process</summary>
These are pre-existing TypeScript errors in other files that are unrelated to my changes. Let me specifically check the files I modified to make sure they're correct.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:22:12.463Z)**_

<tool-use data-tool-type="shell" data-tool-name="Bash"><details>
<summary>Tool use: **Bash**</summary>
Type check only the modified MSAL files

`npx tsc --noEmit --skipLibCheck utils/outlook/msal-device-code.ts utils/outlook/msal-cache-plugin.ts app/api/outlook/device-code/poll/route.ts 2>&1`
```
Exit code 2
app/api/outlook/device-code/poll/route.ts(1,48): error TS2307: Cannot find module 'next/server' or its corresponding type declarations.
app/api/outlook/device-code/poll/route.ts(3,39): error TS2307: Cannot find module 'better-call' or its corresponding type declarations.
app/api/outlook/device-code/poll/route.ts(8,8): error TS2307: Cannot find module '@/utils/outlook/msal-device-code' or its corresponding type declarations.
app/api/outlook/device-code/poll/route.ts(9,37): error TS2307: Cannot find module '@/utils/outlook/client' or its corresponding type declarations.
app/api/outlook/device-code/poll/route.ts(10,30): error TS2307: Cannot find module '@/utils/encryption' or its corresponding type declarations.
app/api/outlook/device-code/poll/route.ts(11,36): error TS2307: Cannot find module '@/utils/logger' or its corresponding type declarations.
app/api/outlook/device-code/poll/route.ts(12,20): error TS2307: Cannot find module '@/utils/prisma' or its corresponding type declarations.
app/api/outlook/device-code/poll/route.ts(13,21): error TS2307: Cannot find module '@/env' or its corresponding type declarations.
app/api/outlook/device-code/poll/route.ts(14,30): error TS2307: Cannot find module '@/utils/config' or its corresponding type declarations.
app/api/outlook/device-code/poll/route.ts(367,36): error TS2802: Type 'IterableIterator<[string, CompletionEntry]>' can only be iterated through when using the '--downlevelIteration' flag or with a '--target' of 'es2015' or higher.
utils/outlook/msal-cache-plugin.ts(11,54): error TS2307: Cannot find module '@azure/msal-node' or its corresponding type declarations.
utils/outlook/msal-cache-plugin.ts(12,20): error TS2307: Cannot find module '@/utils/prisma' or its corresponding type declarations.
utils/outlook/msal-cache-plugin.ts(13,44): error TS2307: Cannot find module '@/utils/encryption' or its corresponding type declarations.
utils/outlook/msal-cache-plugin.ts(14,36): error TS2307: Cannot find module '@/utils/logger' or its corresponding type declarations.
utils/outlook/msal-device-code.ts(24,8): error TS2307: Cannot find module '@azure/msal-node' or its corresponding type declarations.
utils/outlook/msal-device-code.ts(25,21): error TS2307: Cannot find module '@/env' or its corresponding type declarations.
utils/outlook/msal-device-code.ts(26,36): error TS2307: Cannot find module '@/utils/logger' or its corresponding type declarations.
utils/outlook/msal-device-code.ts(27,20): error TS2307: Cannot find module '@/utils/prisma' or its corresponding type declarations.
utils/outlook/msal-device-code.ts(28,30): error TS2307: Cannot find module '@/utils/encryption' or its corresponding type declarations.
utils/outlook/msal-device-code.ts(240,35): error TS2802: Type 'IterableIterator<[string, ActiveFlow]>' can only be iterated through when using the '--downlevelIteration' flag or with a '--target' of 'es2015' or higher.
utils/outlook/msal-device-code.ts(361,22): error TS2550: Property 'cause' does not exist on type 'Error'. Do you need to change your target library? Try changing the 'lib' compiler option to 'es2022' or later.
utils/outlook/msal-device-code.ts(361,43): error TS2550: Property 'cause' does not exist on type 'Error'. Do you need to change your target library? Try changing the 'lib' compiler option to 'es2022' or later.
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:22:29.149Z)**_

<think><details><summary>Thought Process</summary>
The errors are about module resolution because I'm running tsc directly without the proper tsconfig context. Let me use the project's build/lint tooling instead to check for real issues.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:22:30.900Z)**_

<tool-use data-tool-type="shell" data-tool-name="Bash"><details>
<summary>Tool use: **Bash**</summary>
Lint the modified MSAL files

`pnpm lint 2>&1 | grep -E "(msal|poll/route)" | head -20`
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:22:42.655Z)**_

<think><details><summary>Thought Process</summary>
No lint errors related to my changes. Let me also run the prisma generate to make sure the schema is valid.
</details></think>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:22:44.000Z)**_

<tool-use data-tool-type="shell" data-tool-name="Bash"><details>
<summary>Tool use: **Bash**</summary>
Generate Prisma client to validate schema changes

`npx prisma generate 2>&1`
```
Exit code 1
npm warn exec The following package was not found and will be installed: prisma@7.3.0
Failed to load config file "/Users/hack/github/inbox-zero/apps/web/prisma.config.ts" as a TypeScript/JavaScript module. Error: Error: Cannot find module 'prisma/config'
Require stack:
- /Users/hack/github/inbox-zero/apps/web/prisma.config.ts
```
</details></tool-use>

_**Agent (claude-opus-4-5-20251101 2026-01-24T04:23:20.676Z)**_

<think><details><summary>Thought Process</summary>
Let me try running it from the right directory with pnpm.
</details></think>

---

_**User (2026-01-24T04:23:21.297Z)**_

[Request interrupted by user]
